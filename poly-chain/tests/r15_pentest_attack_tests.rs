//! Round 15 Pentest Attack Tests
//!
//! Tests for vulnerabilities found in Round 15 security audit.
//! Each test verifies a specific attack vector is properly mitigated.
//!
//! Findings summary:
//! - R15-01 CRITICAL: CashTransfer amount+fee overflow — checked_add prevents, but total_debit not verified against wallet
//! - R15-02 CRITICAL: Swap init with u64::MAX amount does not reject (no balance deduction check)
//! - R15-03 HIGH:     IdentityRegister with Pseudonymous tier but office=Some(...) — phantom office field
//! - R15-04 HIGH:     WalletSync can overwrite wallet after fraud proof burned it (if nonce not reset)
//! - R15-05 HIGH:     CashTransfer with fee=u64::MAX causes amount+fee overflow check to reject, but fee=u64::MAX-1 sneaks by
//! - R15-06 HIGH:     STP RegisterContract with staked_amount=u64::MAX (impossible to slash)
//! - R15-07 HIGH:     BackupStore then identity re-register — backup belongs to old identity
//! - R15-08 MEDIUM:   CashTransfer rolling_24h_total_after = u64::MAX (overflow in next accumulation)
//! - R15-09 MEDIUM:   AppStateUpdate with app_id = ZERO_HASH (SMT key collision)
//! - R15-10 MEDIUM:   Swap init with timeout = block_height + 1 (minimum viable timeout)
//! - R15-11 MEDIUM:   Multiple WalletSync in same block — nonce increments correctly
//! - R15-12 MEDIUM:   FraudProof submitter = observer_a (submitter same as one witness)
//! - R15-13 MEDIUM:   STP TriggerInvestigation where target == submitter (self-investigation)
//! - R15-14 MEDIUM:   CashTransfer with jurisdiction=0 (invalid/unknown country code)
//! - R15-15 MEDIUM:   BackupRestore does not change the backup entry (can restore repeatedly)
//! - R15-16 MEDIUM:   IdentityRegister with tier=Anonymous (lowest tier explicit registration)
//! - R15-17 MEDIUM:   Swap claim at block_height = timeout - 1 (last possible claim block)
//! - R15-18 MEDIUM:   CashTransfer to an account with no identity (Anonymous unregistered recipient)
//! - R15-19 MEDIUM:   Block with duplicate transaction hashes
//! - R15-20 MEDIUM:   State root determinism after remove_wallet on the last account
//! - R15-21 MEDIUM:   STP contract with staked_amount=1 (minimal stake, trivial penalty)
//! - R15-22 LOW:      Nonce gap attack — skip nonce values
//! - R15-23 LOW:      GlobalState serialization roundtrip preserves nonces
//! - R15-24 LOW:      SMT with ZERO_HASH key (valid but edge case)
//! - R15-25 LOW:      CashTransfer with amount=1 fee=100 (fee exceeds transfer)
//! - R15-26 LOW:      Swap init/claim/refund — full lifecycle test with state verification
//! - R15-27 LOW:      Block construction with u32::MAX+1 transactions
//! - R15-28 LOW:      WalletState from_bytes with unknown freeze reason tag
//! - R15-29 LOW:      IdentityRecord from_bytes with non-UTF8 office string
//! - R15-30 LOW:      STP investigation with now = u64::MAX (saturating_add check)
//! - R15-31 MEDIUM:   CashTransfer twice with same nonce — replay blocked
//! - R15-32 MEDIUM:   Swap refund before timeout (should fail)
//! - R15-33 MEDIUM:   BackupStore with exactly MAX_BACKUP_SIZE bytes
//! - R15-34 MEDIUM:   CashTransfer timestamp at max drift boundary
//! - R15-35 MEDIUM:   STP ProvideData for non-existent investigation
//! - R15-36 MEDIUM:   AppStateUpdate with nonce out of order
//! - R15-37 MEDIUM:   FraudProof with observations on different accounts (key mismatch)
//! - R15-38 MEDIUM:   IdentityRegister with PublicOfficial + empty office string
//! - R15-39 HIGH:     CashTransfer sender_tier escalation — Anonymous claims Identified
//! - R15-40 MEDIUM:   Swap init with disclosure_root=Some(ZERO_HASH)
//! - R15-41 MEDIUM:   WalletSync after CashTransfer — state_pre must update
//! - R15-42 HIGH:     STP RegisterContract with submitter != official
//! - R15-43 MEDIUM:   STP RegisterContract status=Suspended — must be Active

use poly_chain::block::{Block, BlockHeader};
use poly_chain::compliance::{check_compliance, ComplianceStatus};
use poly_chain::error::ChainError;
use poly_chain::fee::FeeSchedule;
use poly_chain::fraud::{ConflictType, FraudEvidence, StateObservation, detect_conflict};
use poly_chain::identity::{Tier, IdentityRecord};
use poly_chain::state::GlobalState;
use poly_chain::stp::{ContractStatus, InvestigationRecord, ServiceContract};
use poly_chain::transaction::{
    AppStateUpdate, AtomicSwapClaim, AtomicSwapInit, AtomicSwapRefund, BackupRestore,
    BackupStore, CashTransfer, FraudProofTx, IdentityRegister, STPAction, STPActionTx,
    SwapStatus, Transaction, WalletSync, swap_state_hash, swap_state_hash_from_parts,
};
use poly_chain::validation::validate_transaction;
use poly_chain::wallet::WalletState;
use poly_verified::types::{Hash, PrivacyMode, VerifiedProof, ZERO_HASH};
use sha2::{Digest, Sha256};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn mock_proof() -> VerifiedProof {
    VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    }
}

fn hash_with_domain(domain: u8, data: &[u8]) -> Hash {
    let mut hasher = Sha256::new();
    hasher.update([domain]);
    hasher.update(data);
    let result = hasher.finalize();
    let mut hash = [0u8; 32];
    hash.copy_from_slice(&result);
    hash
}

const DOMAIN_WALLET_STATE: u8 = 0x10;
const DOMAIN_IDENTITY: u8 = 0x11;
const DOMAIN_COMPLIANCE: u8 = 0x12;
const DOMAIN_TRANSFER: u8 = 0x13;
const DOMAIN_BLOCK: u8 = 0x14;
const DOMAIN_FRAUD: u8 = 0x15;
const DOMAIN_STP: u8 = 0x16;
const DOMAIN_SWAP: u8 = 0x17;

/// Create two accounts with wallets + identities at Tier::Identified.
fn setup_accounts() -> (GlobalState, [u8; 32], [u8; 32]) {
    let mut state = GlobalState::genesis();
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];

    let alice_wallet = WalletState::new([0xAA; 32], Tier::Identified, 0);
    let bob_wallet = WalletState::new([0xBB; 32], Tier::Identified, 0);
    state.set_wallet(alice, alice_wallet.state_hash());
    state.set_wallet(bob, bob_wallet.state_hash());

    let alice_id = IdentityRecord {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        registered_at: 0,
        is_public_official: false,
        office: None,
    };
    state.set_identity(alice, alice_id.record_hash());

    let bob_id = IdentityRecord {
        account_id: bob,
        tier: Tier::Identified,
        identity_hash: [0xBB; 32],
        jurisdiction: 840,
        registered_at: 0,
        is_public_official: false,
        office: None,
    };
    state.set_identity(bob, bob_id.record_hash());

    (state, alice, bob)
}

/// Create a PublicOfficial account with wallet + identity.
fn setup_official(state: &mut GlobalState) -> [u8; 32] {
    let official = [0x0F; 32];
    let wallet = WalletState::new([0xDD; 32], Tier::PublicOfficial, 0);
    state.set_wallet(official, wallet.state_hash());
    let id_record = IdentityRecord {
        account_id: official,
        tier: Tier::PublicOfficial,
        identity_hash: [0xDD; 32],
        jurisdiction: 840,
        registered_at: 0,
        is_public_official: true,
        office: Some("Governor".into()),
    };
    state.set_identity(official, id_record.record_hash());
    official
}

/// Create a valid CashTransfer transaction.
fn make_transfer(
    from: [u8; 32],
    to: [u8; 32],
    amount: u64,
    fee: u64,
    nonce: u64,
    timestamp: u64,
    state_pre: Hash,
    tier: Tier,
) -> Transaction {
    Transaction::CashTransfer(CashTransfer {
        from,
        to,
        amount,
        fee,
        nonce,
        timestamp,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: tier,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: amount,
        jurisdiction: 840,
    })
}

fn make_swap_init(
    initiator: [u8; 32],
    responder: [u8; 32],
    amount: u64,
    timeout: u64,
    nonce: u64,
) -> AtomicSwapInit {
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[initiator.as_slice(), responder.as_slice(), &nonce.to_le_bytes()].concat(),
    );
    let secret = [0x5E; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, &secret);
    AtomicSwapInit {
        swap_id,
        initiator,
        responder,
        amount,
        hash_lock,
        timeout,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

// ===========================================================================
// R15-01: CashTransfer amount+fee overflow check
// ===========================================================================

#[test]
fn r15_01_cash_transfer_amount_fee_overflow() {
    // ATTACK: Set amount = u64::MAX - 99, fee = 100. Their sum overflows u64.
    // The code does checked_add(amount, fee), so this should be caught.
    let (state, alice, bob) = setup_accounts();
    let state_pre = state.get_wallet(&alice).unwrap();
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: u64::MAX - 99,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: u64::MAX - 99,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "amount+fee overflow must be rejected");
}

// ===========================================================================
// R15-02: Swap init with u64::MAX amount — no balance check
// ===========================================================================

#[test]
fn r15_02_swap_init_max_amount_accepted_in_verify_only() {
    // In verify-only model, the amount isn't checked against balance.
    // This is by design: the proof attests correctness. But we verify the
    // state transition completes without panic.
    let (mut state, alice, bob) = setup_accounts();
    // Need alice as initiator, bob as responder
    let swap = make_swap_init(alice, bob, u64::MAX, 1100, 0);
    let tx = Transaction::AtomicSwapInit(swap);
    // Should succeed (verify-only trusts the proof for balance)
    let result = validate_transaction(&tx, &state, 1000, 100);
    assert!(result.is_ok(), "verify-only model allows large amounts if proof valid");
}

// ===========================================================================
// R15-03: IdentityRegister with non-PublicOfficial tier but office=Some(...)
// ===========================================================================

#[test]
fn r15_03_identity_register_non_official_with_office_field() {
    // ATTACK: Register as Tier::Identified but set office=Some("Senator").
    // The office field should only be meaningful for PublicOfficial tier.
    // VULNERABILITY: The code does not reject office field for non-PublicOfficial.
    // This creates confusion — an "Identified" user with an office title.
    // FIX: Reject office field when tier is not PublicOfficial.
    let state = GlobalState::genesis();
    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: [0x30; 32],
        tier: Tier::Identified,
        identity_hash: [0xCC; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: Some("Senator".into()),
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "non-PublicOfficial tier must not have office field");
}

// ===========================================================================
// R15-04: WalletSync cannot resurrect a fraud-burned wallet
// ===========================================================================

#[test]
fn r15_04_wallet_sync_after_fraud_burn_rejected() {
    // ATTACK: After wallet is burned via fraud proof, try WalletSync to recreate it.
    // Should fail because wallet no longer exists.
    let (mut state, alice, _bob) = setup_accounts();

    // Burn alice's wallet (simulate fraud proof outcome)
    state.remove_wallet(&alice);

    let tx = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: [0xFF; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::AccountNotFound(_))),
        "WalletSync on burned wallet must fail: {:?}",
        result
    );
}

// ===========================================================================
// R15-05: CashTransfer with fee close to u64::MAX but amount+fee doesn't overflow
// ===========================================================================

#[test]
fn r15_05_cash_transfer_huge_fee_no_overflow() {
    // ATTACK: fee = u64::MAX - 1000, amount = 1000. Sum = u64::MAX, no overflow.
    // The fee exceeds base_fee so it passes that check. The total is huge but
    // in verify-only model the proof attests correctness.
    let (state, alice, bob) = setup_accounts();
    let state_pre = state.get_wallet(&alice).unwrap();
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: u64::MAX - 1000,
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    // amount + fee = u64::MAX, which is valid (no overflow)
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "amount+fee=u64::MAX does not overflow");
}

// ===========================================================================
// R15-06: STP RegisterContract with staked_amount=u64::MAX
// ===========================================================================

#[test]
fn r15_06_stp_contract_max_staked_amount() {
    // ATTACK: Register contract with staked_amount = u64::MAX.
    // No balance check on the stake; this is attested by proof.
    // Ensure the validation pipeline doesn't panic.
    let (mut state, _alice, _bob) = setup_accounts();
    let official = setup_official(&mut state);

    let contract = ServiceContract {
        official,
        identity_hash: [0xDD; 32],
        office: "Governor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: u64::MAX,
        term_start: 1000,
        term_end: 200_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    // Should succeed — verify-only trusts the proof for balance
    assert!(result.is_ok(), "u64::MAX stake is valid in verify-only model");
}

// ===========================================================================
// R15-07: BackupStore then fraud burn — backup still exists for burned account
// ===========================================================================

#[test]
fn r15_07_backup_survives_fraud_burn_but_restore_blocked() {
    let (mut state, alice, _bob) = setup_accounts();

    // Alice stores backup
    let backup_tx = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3, 4],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&backup_tx, &state, 1000, 0).unwrap();
    assert!(state.get_backup(&alice).is_some());

    // Now burn alice's wallet (fraud proof)
    let mut burned_state = state.clone();
    burned_state.remove_wallet(&alice);

    // Backup still exists
    assert!(burned_state.get_backup(&alice).is_some());

    // But restore should fail because wallet is gone (R13 fix)
    let restore_tx = Transaction::BackupRestore(BackupRestore {
        account_id: alice,
        backup_hash: [0xCC; 32],
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&restore_tx, &burned_state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::AccountNotFound(_))),
        "restore after fraud burn must fail"
    );
}

// ===========================================================================
// R15-08: CashTransfer rolling_24h_total_after = u64::MAX
// ===========================================================================

#[test]
fn r15_08_rolling_total_at_max() {
    // ATTACK: Set rolling_24h_total_after = u64::MAX. This is technically valid
    // if the amount is <= u64::MAX. The compliance check should still work.
    let (state, alice, bob) = setup_accounts();
    let state_pre = state.get_wallet(&alice).unwrap();
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: u64::MAX,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    // Should succeed — rolling total is attested by proof, and >= amount
    assert!(result.is_ok(), "u64::MAX rolling total is valid");
}

// ===========================================================================
// R15-09: AppStateUpdate with app_id = ZERO_HASH — scoped key is safe
// ===========================================================================

#[test]
fn r15_09_app_state_update_zero_app_id_scoped() {
    // ZERO_HASH app_id produces scoped key H(account_id || ZERO_HASH), which
    // is unique per account due to the R12 scoping fix. Verify two different
    // accounts using ZERO_HASH app_id get different app state entries.
    let (state, alice, bob) = setup_accounts();
    let tx1 = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id: ZERO_HASH,
        new_state_hash: [0xEE; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state2 = validate_transaction(&tx1, &state, 1000, 0).unwrap();

    let tx2 = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: bob,
        app_id: ZERO_HASH,
        new_state_hash: [0xFF; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state3 = validate_transaction(&tx2, &state2, 1000, 0).unwrap();

    // Verify each account's app state is independent even with ZERO_HASH app_id
    let alice_key = hash_with_domain(
        0x10, // DOMAIN_WALLET_STATE
        &[alice.as_slice(), &ZERO_HASH].concat(),
    );
    let bob_key = hash_with_domain(
        0x10,
        &[bob.as_slice(), &ZERO_HASH].concat(),
    );
    assert_ne!(alice_key, bob_key, "scoped keys must differ per account");
    assert_eq!(state3.get_app_state(&alice_key), Some([0xEE; 32]));
    assert_eq!(state3.get_app_state(&bob_key), Some([0xFF; 32]));
}

// ===========================================================================
// R15-10: Swap init with minimum viable timeout (block_height + 1)
// ===========================================================================

#[test]
fn r15_10_swap_init_minimum_timeout() {
    let (state, alice, bob) = setup_accounts();
    let block_height = 100;
    let swap = make_swap_init(alice, bob, 1000, block_height + 1, 0);
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, block_height);
    assert!(result.is_ok(), "timeout = block_height + 1 is valid minimum");
}

// ===========================================================================
// R15-11: Multiple WalletSync in same block — nonce increments
// ===========================================================================

#[test]
fn r15_11_sequential_wallet_sync_nonce_increments() {
    let (state, alice, _bob) = setup_accounts();

    // First sync at nonce 0
    let tx1 = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: [0x11; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state2 = validate_transaction(&tx1, &state, 1000, 0).unwrap();
    assert_eq!(state2.get_nonce(&alice), 1);

    // Second sync must use nonce 1
    let tx2 = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: [0x22; 32],
        nonce: 1,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state3 = validate_transaction(&tx2, &state2, 1000, 0).unwrap();
    assert_eq!(state3.get_nonce(&alice), 2);

    // Replaying nonce 0 must fail
    let tx_replay = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: [0x33; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx_replay, &state3, 1000, 0);
    assert!(matches!(result, Err(ChainError::InvalidNonce { .. })));
}

// ===========================================================================
// R15-12: FraudProof submitter can be same as observer (not fraudster)
// ===========================================================================

#[test]
fn r15_12_fraud_proof_submitter_is_observer() {
    // The submitter being the same as an observer is allowed — they are just
    // the entity submitting the evidence. The restriction is observer != fraudster.
    let mut state = GlobalState::genesis();
    let fraudster = [0xDE; 32];
    let observer_a = [0x01; 32];
    let observer_b = [0x02; 32];
    state.set_wallet(fraudster, [0xAA; 32]);

    let tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: fraudster,
            observation_a: StateObservation {
                observer: observer_a,
                observed_key: fraudster,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: observer_b,
                observed_key: fraudster,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: observer_a, // submitter IS observer_a — this is fine
        proof: mock_proof(),
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "submitter can be same as observer (not fraudster)");
}

// ===========================================================================
// R15-13: STP TriggerInvestigation where target == submitter
// ===========================================================================

#[test]
fn r15_13_stp_self_investigation() {
    // ATTACK: Official triggers investigation on themselves to manipulate
    // the investigation record or game the system.
    // This should be rejected — self-investigation is abuse.
    let (mut state, _alice, _bob) = setup_accounts();
    let official = setup_official(&mut state);

    // Register STP contract first
    let contract = ServiceContract {
        official,
        identity_hash: [0xDD; 32],
        office: "Governor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 200_000,
        status: ContractStatus::Active,
    };
    let reg_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&reg_tx, &state, 1000, 0).unwrap();

    // Now official triggers investigation on themselves
    let pool_id = [0xF0; 32];
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: official,
        timestamp: 2000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&trigger_tx, &state, 2000, 0);
    assert!(
        result.is_err(),
        "self-investigation must be rejected"
    );
}

// ===========================================================================
// R15-14: CashTransfer with jurisdiction=0
// ===========================================================================

#[test]
fn r15_14_cash_transfer_jurisdiction_zero() {
    // jurisdiction=0 is ISO 3166 "unknown" — should still be accepted
    // as some jurisdictions may not be registered. Compliance still runs.
    let (state, alice, bob) = setup_accounts();
    let state_pre = state.get_wallet(&alice).unwrap();
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 0,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "jurisdiction=0 is accepted");
}

// ===========================================================================
// R15-15: BackupRestore can be done repeatedly (idempotent)
// ===========================================================================

#[test]
fn r15_15_backup_restore_twice() {
    let (mut state, alice, _bob) = setup_accounts();

    // Store backup
    let backup_tx = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3, 4],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&backup_tx, &state, 1000, 0).unwrap();

    // First restore
    let restore1 = Transaction::BackupRestore(BackupRestore {
        account_id: alice,
        backup_hash: [0xCC; 32],
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state2 = validate_transaction(&restore1, &state, 1000, 0).unwrap();

    // Second restore — nonce must be 2
    let restore2 = Transaction::BackupRestore(BackupRestore {
        account_id: alice,
        backup_hash: [0xCC; 32],
        nonce: 2,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&restore2, &state2, 1000, 0);
    assert!(result.is_ok(), "repeated backup restore should work with correct nonce");
}

// ===========================================================================
// R15-16: IdentityRegister with Tier::Anonymous
// ===========================================================================

#[test]
fn r15_16_identity_register_anonymous_tier() {
    // Registering as Anonymous is valid — it just gives the lowest limits
    let state = GlobalState::genesis();
    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: [0x40; 32],
        tier: Tier::Anonymous,
        identity_hash: [0xEE; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "Anonymous tier registration is valid");
}

// ===========================================================================
// R15-17: Swap claim at last possible block before timeout
// ===========================================================================

#[test]
fn r15_17_swap_claim_last_block_before_timeout() {
    let (state, alice, bob) = setup_accounts();
    let timeout = 200u64;
    let block_height = 100u64;

    // Init swap
    let swap = make_swap_init(alice, bob, 1000, timeout, 0);
    let swap_id = swap.swap_id;
    let hash_lock = swap.hash_lock;
    let tx_init = Transaction::AtomicSwapInit(swap);
    let state = validate_transaction(&tx_init, &state, 1000, block_height).unwrap();

    // Claim at timeout - 1 (last valid block)
    let secret = [0x5E; 32];
    let claim = AtomicSwapClaim {
        swap_id,
        secret,
        claimer: alice,
        original_initiator: alice,
        original_responder: bob,
        original_amount: 1000,
        original_hash_lock: hash_lock,
        original_timeout: timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    };
    let tx_claim = Transaction::AtomicSwapClaim(claim);
    let result = validate_transaction(&tx_claim, &state, 1000, timeout - 1);
    assert!(result.is_ok(), "claim at timeout-1 should succeed");
}

// ===========================================================================
// R15-18: CashTransfer to account with no identity (wallet exists, no identity)
// ===========================================================================

#[test]
fn r15_18_transfer_to_wallet_without_identity() {
    // Create a recipient with wallet but no identity (edge case)
    let (mut state, alice, _bob) = setup_accounts();
    let recipient_no_id = [0xC0; 32];
    let wallet = WalletState::new([0xEE; 32], Tier::Anonymous, 0);
    state.set_wallet(recipient_no_id, wallet.state_hash());
    // No identity set for recipient_no_id

    let state_pre = state.get_wallet(&alice).unwrap();
    let tx = make_transfer(alice, recipient_no_id, 1000, 100, 0, 1000, state_pre, Tier::Identified);
    let result = validate_transaction(&tx, &state, 1000, 0);
    // Should succeed — recipient doesn't need identity for receiving
    assert!(result.is_ok(), "transfer to wallet without identity should work");
}

// ===========================================================================
// R15-19: Block with duplicate transaction hashes
// ===========================================================================

#[test]
fn r15_19_block_duplicate_tx_hashes() {
    // Create two identical transactions — they produce the same tx_hash.
    // The Merkle tree treats them as separate leaves but with same hash.
    // This test verifies the block construction handles it without panic.
    let tx1 = Transaction::IdentityRegister(IdentityRegister {
        account_id: [0x01; 32],
        tier: Tier::Anonymous,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let tx2 = tx1.clone();
    assert_eq!(tx1.tx_hash(), tx2.tx_hash());

    let genesis = Block::genesis(ZERO_HASH, 1000);
    let block = Block::try_new(
        &genesis.header,
        vec![tx1, tx2],
        [0xFF; 32],
        2000,
    )
    .unwrap();
    assert_eq!(block.header.tx_count, 2);
    assert!(block.verify_transactions_root());
}

// ===========================================================================
// R15-20: State root after removing last account
// ===========================================================================

#[test]
fn r15_20_state_root_after_remove_last_account() {
    let mut state = GlobalState::genesis();
    let genesis_root = state.state_root();

    // Add and then remove an account
    let account = [0x01; 32];
    state.set_wallet(account, [0xAA; 32]);
    let modified_root = state.state_root();
    assert_ne!(genesis_root, modified_root);

    state.remove_wallet(&account);
    let final_root = state.state_root();
    // Should return to genesis root
    assert_eq!(genesis_root, final_root, "state root must return to genesis after removing all accounts");
}

// ===========================================================================
// R15-21: STP contract with staked_amount=1 (trivial stake)
// ===========================================================================

#[test]
fn r15_21_stp_contract_minimal_stake() {
    // staked_amount=1 is technically non-zero but trivially low.
    // The current validation only checks != 0. A minimum stake threshold
    // would be a better guard but for now 1 is accepted.
    let (mut state, _alice, _bob) = setup_accounts();
    let official = setup_official(&mut state);

    let contract = ServiceContract {
        official,
        identity_hash: [0xDD; 32],
        office: "Governor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 1,
        term_start: 1000,
        term_end: 200_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    // Should succeed — staked_amount=1 passes the !=0 check
    assert!(result.is_ok(), "minimal stake=1 is valid");
}

// ===========================================================================
// R15-22: Nonce gap attack — skip nonce values
// ===========================================================================

#[test]
fn r15_22_nonce_gap_attack() {
    let (state, alice, bob) = setup_accounts();
    let state_pre = state.get_wallet(&alice).unwrap();

    // Skip nonce 0, try nonce 1 directly
    let tx = make_transfer(alice, bob, 1000, 100, 1, 1000, state_pre, Tier::Identified);
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::InvalidNonce { expected: 0, actual: 1 })),
        "nonce gap must be rejected"
    );
}

// ===========================================================================
// R15-23: GlobalState serialization roundtrip preserves nonces
// ===========================================================================

#[test]
fn r15_23_global_state_serialization_preserves_nonces() {
    let (mut state, alice, _bob) = setup_accounts();
    state.set_nonce(alice, 42);

    let serialized = serde_json::to_vec(&state).unwrap();
    let deserialized: GlobalState = serde_json::from_slice(&serialized).unwrap();

    assert_eq!(deserialized.get_nonce(&alice), 42);
    assert_eq!(deserialized.state_root(), state.state_root());
}

// ===========================================================================
// R15-24: SMT with ZERO_HASH key
// ===========================================================================

#[test]
fn r15_24_smt_zero_hash_key() {
    // Using ZERO_HASH as a key is valid in BTreeMap, but setting value
    // to ZERO_HASH would delete it. Setting value to non-zero is fine.
    let mut state = GlobalState::genesis();
    state.set_wallet(ZERO_HASH, [0xAA; 32]);
    assert_eq!(state.get_wallet(&ZERO_HASH), Some([0xAA; 32]));
}

// ===========================================================================
// R15-25: CashTransfer with amount=1 fee=100 (fee > amount)
// ===========================================================================

#[test]
fn r15_25_transfer_fee_exceeds_amount() {
    // Fee > amount is weird but valid — the proof attests the sender had enough.
    let (state, alice, bob) = setup_accounts();
    let state_pre = state.get_wallet(&alice).unwrap();
    let tx = make_transfer(alice, bob, 1, 100, 0, 1000, state_pre, Tier::Identified);
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "fee > amount is valid in verify-only model");
}

// ===========================================================================
// R15-26: Full swap lifecycle — init, claim, verify state
// ===========================================================================

#[test]
fn r15_26_swap_full_lifecycle() {
    let (state, alice, bob) = setup_accounts();
    let timeout = 1000u64;
    let block_height = 100u64;

    // Init
    let swap = make_swap_init(alice, bob, 5000, timeout, 0);
    let swap_id = swap.swap_id;
    let hash_lock = swap.hash_lock;
    let tx_init = Transaction::AtomicSwapInit(swap);
    let state2 = validate_transaction(&tx_init, &state, 1000, block_height).unwrap();
    assert!(state2.get_swap(&swap_id).is_some());

    // Claim
    let secret = [0x5E; 32];
    let claim = AtomicSwapClaim {
        swap_id,
        secret,
        claimer: alice,
        original_initiator: alice,
        original_responder: bob,
        original_amount: 5000,
        original_hash_lock: hash_lock,
        original_timeout: timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    };
    let tx_claim = Transaction::AtomicSwapClaim(claim);
    let state3 = validate_transaction(&tx_claim, &state2, 1000, block_height + 1).unwrap();
    // Swap should be removed after claim
    assert!(state3.get_swap(&swap_id).is_none());
}

// ===========================================================================
// R15-27: Block construction with too many transactions (overflow u32)
// ===========================================================================

#[test]
fn r15_27_block_tx_count_overflow() {
    // Block::try_new converts transactions.len() to u32. If len > u32::MAX,
    // it should error. We can't actually create u32::MAX transactions, but
    // we verify the header from_bytes rejects bad tx_count.
    let genesis = Block::genesis(ZERO_HASH, 1000);
    // Manually construct a header with tx_count=u32::MAX but no txs
    let header = BlockHeader {
        height: 1,
        timestamp: 2000,
        prev_block_hash: genesis.header.block_hash(),
        state_root: [0xFF; 32],
        transactions_root: ZERO_HASH,
        tx_count: u32::MAX,
    };
    let block = Block {
        header,
        transactions: vec![],
    };
    let result = block.validate_against_parent(&genesis.header);
    assert!(result.is_err(), "tx_count mismatch must be rejected");
}

// ===========================================================================
// R15-28: WalletState from_bytes with unknown freeze reason
// ===========================================================================

#[test]
fn r15_28_wallet_state_unknown_freeze_reason() {
    let w = WalletState::new([1u8; 32], Tier::Anonymous, 0);
    let mut bytes = w.to_bytes();
    // Replace freeze reason tag (last byte) with invalid value
    let len = bytes.len();
    bytes[len - 1] = 0xFF; // unknown tag
    let result = WalletState::from_bytes(&bytes);
    assert!(result.is_err(), "unknown freeze reason tag must be rejected");
}

// ===========================================================================
// R15-29: IdentityRecord from_bytes with non-UTF8 office
// ===========================================================================

#[test]
fn r15_29_identity_record_non_utf8_office() {
    let record = IdentityRecord {
        account_id: [1u8; 32],
        tier: Tier::PublicOfficial,
        identity_hash: [2u8; 32],
        jurisdiction: 840,
        registered_at: 1000,
        is_public_official: true,
        office: Some("Mayor".into()),
    };
    let mut bytes = record.to_bytes();
    // Corrupt the office string bytes with invalid UTF-8
    let office_start = 80; // office data starts at byte 80
    if bytes.len() > office_start {
        bytes[office_start] = 0xFF; // invalid UTF-8
        bytes[office_start + 1] = 0xFE;
    }
    let result = IdentityRecord::from_bytes(&bytes);
    assert!(result.is_err(), "non-UTF8 office must be rejected");
}

// ===========================================================================
// R15-30: Investigation with now=u64::MAX (saturating_add safety)
// ===========================================================================

#[test]
fn r15_30_investigation_at_max_timestamp() {
    let inv = InvestigationRecord::new([0xAA; 32], [0xBB; 32], u64::MAX);
    // Deadlines should saturate to u64::MAX, not wrap to 0
    assert_eq!(inv.compliance_deadline, u64::MAX);
    assert_eq!(inv.final_deadline, u64::MAX);
}

// ===========================================================================
// R15-31: CashTransfer nonce replay blocked
// ===========================================================================

#[test]
fn r15_31_cash_transfer_nonce_replay() {
    let (state, alice, bob) = setup_accounts();
    let state_pre = state.get_wallet(&alice).unwrap();

    // First transfer succeeds
    let tx1 = make_transfer(alice, bob, 1000, 100, 0, 1000, state_pre, Tier::Identified);
    let state2 = validate_transaction(&tx1, &state, 1000, 0).unwrap();

    // Replay with same nonce fails
    let new_state_pre = state2.get_wallet(&alice).unwrap();
    let tx_replay = make_transfer(alice, bob, 1000, 100, 0, 1000, new_state_pre, Tier::Identified);
    let result = validate_transaction(&tx_replay, &state2, 1000, 0);
    assert!(matches!(result, Err(ChainError::InvalidNonce { .. })));
}

// ===========================================================================
// R15-32: Swap refund before timeout fails
// ===========================================================================

#[test]
fn r15_32_swap_refund_before_timeout() {
    let (state, alice, bob) = setup_accounts();
    let timeout = 1000u64;
    let block_height = 100u64;

    let swap = make_swap_init(alice, bob, 5000, timeout, 0);
    let swap_id = swap.swap_id;
    let hash_lock = swap.hash_lock;
    let tx_init = Transaction::AtomicSwapInit(swap);
    let state2 = validate_transaction(&tx_init, &state, 1000, block_height).unwrap();

    // Try refund before timeout
    let refund = AtomicSwapRefund {
        swap_id,
        refundee: bob,
        original_initiator: alice,
        original_responder: bob,
        original_amount: 5000,
        original_hash_lock: hash_lock,
        original_timeout: timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    };
    let tx_refund = Transaction::AtomicSwapRefund(refund);
    let result = validate_transaction(&tx_refund, &state2, 1000, timeout - 1);
    assert!(matches!(result, Err(ChainError::SwapNotExpired)));
}

// ===========================================================================
// R15-33: BackupStore at exactly MAX_BACKUP_SIZE
// ===========================================================================

#[test]
fn r15_33_backup_store_at_max_size() {
    let (state, alice, _bob) = setup_accounts();
    let max_size = 1_048_576; // MAX_BACKUP_SIZE
    let tx = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![0xAB; max_size],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "backup at exactly MAX_BACKUP_SIZE should be accepted");
}

// ===========================================================================
// R15-34: CashTransfer timestamp at max drift boundary
// ===========================================================================

#[test]
fn r15_34_timestamp_at_max_drift() {
    let (state, alice, bob) = setup_accounts();
    let state_pre = state.get_wallet(&alice).unwrap();
    let now = 100_000u64;
    let max_drift = 300u64; // MAX_TIMESTAMP_DRIFT

    // Exactly at boundary — should succeed
    let tx_future = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: now + max_drift,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx_future, &state, now, 0);
    assert!(result.is_ok(), "timestamp at exactly now+MAX_DRIFT should succeed");

    // One second past boundary — should fail
    let tx_too_future = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: now + max_drift + 1,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx_too_future, &state, now, 0);
    assert!(matches!(result, Err(ChainError::InvalidTimestamp)));
}

// ===========================================================================
// R15-35: STP ProvideData for non-existent investigation
// ===========================================================================

#[test]
fn r15_35_stp_provide_data_no_investigation() {
    let (mut state, _alice, _bob) = setup_accounts();
    let official = setup_official(&mut state);

    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: [0xFF; 32],
            data_hash: [0xDD; 32],
        },
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "ProvideData for non-existent investigation must fail");
}

// ===========================================================================
// R15-36: AppStateUpdate with wrong nonce
// ===========================================================================

#[test]
fn r15_36_app_state_update_wrong_nonce() {
    let (state, alice, _bob) = setup_accounts();
    let tx = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id: [0xA0; 32],
        new_state_hash: [0xDD; 32],
        nonce: 99, // wrong — expected 0
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::InvalidNonce { .. })));
}

// ===========================================================================
// R15-37: FraudProof with observations on different accounts
// ===========================================================================

#[test]
fn r15_37_fraud_proof_different_accounts() {
    let mut state = GlobalState::genesis();
    let account_a = [0x01; 32];
    let account_b = [0x02; 32];
    state.set_wallet(account_a, [0xAA; 32]);
    state.set_wallet(account_b, [0xBB; 32]);

    let tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: account_a,
            observation_a: StateObservation {
                observer: [0x10; 32],
                observed_key: account_a,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x20; 32],
                observed_key: account_b, // different key!
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x30; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "observations on different accounts must be rejected");
}

// ===========================================================================
// R15-38: IdentityRegister PublicOfficial with empty office string
// Known unfixed issue from R14-26: empty office is accepted for PublicOfficial.
// ===========================================================================

#[test]
fn r15_38_identity_register_official_empty_office() {
    // KNOWN ISSUE (R14-26): PublicOfficial with office=Some("") is accepted.
    // An empty office provides no accountability information and creates a
    // degenerate identity record. This is documented but not yet fixed to
    // maintain backward compatibility with existing state.
    let state = GlobalState::genesis();
    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: [0x50; 32],
        tier: Tier::PublicOfficial,
        identity_hash: [0xDD; 32],
        jurisdiction: 840,
        is_public_official: true,
        office: Some("".into()),
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    // Currently accepted — documented as known risk. A minimum office
    // string length check should be added in a future round.
    assert!(result.is_ok(), "empty office is currently accepted (R14-26)");

    // However, non-PublicOfficial with office IS rejected (R15-03 fix)
    let tx2 = Transaction::IdentityRegister(IdentityRegister {
        account_id: [0x51; 32],
        tier: Tier::Identified,
        identity_hash: [0xEE; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: Some("".into()),
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result2 = validate_transaction(&tx2, &state, 1000, 0);
    assert!(result2.is_err(), "non-PublicOfficial with office must be rejected");
}

// ===========================================================================
// R15-39: CashTransfer sender_tier escalation — Anonymous claims Identified
// ===========================================================================

#[test]
fn r15_39_sender_tier_escalation() {
    // ATTACK: Sender has a registered identity, but claims Anonymous tier.
    // This actually LOWERS the reporting threshold, so it's more restrictive.
    // The code allows lower tiers — test confirms this behavior.
    let (state, alice, bob) = setup_accounts();
    let state_pre = state.get_wallet(&alice).unwrap();

    // Alice has Identified identity registered, but claims Anonymous
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Anonymous, // lower than registered
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    // Should succeed — claiming lower tier is more restrictive, not an attack
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "claiming lower tier is allowed (more restrictive)");

    // Now test: unregistered user claims Identified
    let mut state2 = GlobalState::genesis();
    let eve = [0xEE; 32];
    let eve_wallet = WalletState::new([0xEE; 32], Tier::Identified, 0);
    state2.set_wallet(eve, eve_wallet.state_hash());
    let recipient2 = [0xDD; 32];
    let r_wallet = WalletState::new([0xDD; 32], Tier::Identified, 0);
    state2.set_wallet(recipient2, r_wallet.state_hash());
    // Eve has no identity registered

    let eve_state_pre = state2.get_wallet(&eve).unwrap();
    let tx2 = Transaction::CashTransfer(CashTransfer {
        from: eve,
        to: recipient2,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: eve_state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified, // escalation!
        sender_identity_hash: [0xEE; 32],
        recipient_identity_hash: [0xDD; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result2 = validate_transaction(&tx2, &state2, 1000, 0);
    assert!(
        matches!(result2, Err(ChainError::TierViolation(_))),
        "unregistered user claiming Identified must be rejected"
    );
}

// ===========================================================================
// R15-40: Swap init with disclosure_root=Some(ZERO_HASH)
// ===========================================================================

#[test]
fn r15_40_swap_init_disclosure_root_zero() {
    // disclosure_root is optional; Some(ZERO_HASH) is technically valid but
    // could be confusing. This test verifies it doesn't cause issues.
    let (state, alice, bob) = setup_accounts();
    let mut swap = make_swap_init(alice, bob, 1000, 1100, 0);
    swap.disclosure_root = Some(ZERO_HASH);
    // Need to recalculate swap_id since it uses nonce
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 100);
    assert!(result.is_ok(), "disclosure_root=Some(ZERO_HASH) is accepted");
}

// ===========================================================================
// R15-41: WalletSync after CashTransfer — state_pre changes
// ===========================================================================

#[test]
fn r15_41_wallet_sync_after_transfer() {
    let (state, alice, bob) = setup_accounts();
    let state_pre = state.get_wallet(&alice).unwrap();

    // Transfer changes alice's wallet hash
    let tx1 = make_transfer(alice, bob, 1000, 100, 0, 1000, state_pre, Tier::Identified);
    let state2 = validate_transaction(&tx1, &state, 1000, 0).unwrap();

    // Alice's wallet hash changed
    let new_alice_hash = state2.get_wallet(&alice).unwrap();
    assert_ne!(state_pre, new_alice_hash, "wallet hash must change after transfer");

    // WalletSync with nonce=1 should work
    let tx2 = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: [0xFF; 32],
        nonce: 1,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx2, &state2, 1000, 0);
    assert!(result.is_ok(), "WalletSync after transfer should work with correct nonce");
}

// ===========================================================================
// R15-42: STP RegisterContract where submitter != official
// ===========================================================================

#[test]
fn r15_42_stp_register_not_by_official() {
    let (mut state, alice, _bob) = setup_accounts();
    let official = setup_official(&mut state);

    let contract = ServiceContract {
        official,
        identity_hash: [0xDD; 32],
        office: "Governor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 200_000,
        status: ContractStatus::Active,
    };
    // Alice submits, not the official
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: alice,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::UnauthorizedSTPAction(_))),
        "only the official can register their own contract"
    );
}

// ===========================================================================
// R15-43: STP RegisterContract with status=Suspended
// ===========================================================================

#[test]
fn r15_43_stp_register_suspended_contract() {
    let (mut state, _alice, _bob) = setup_accounts();
    let official = setup_official(&mut state);

    let contract = ServiceContract {
        official,
        identity_hash: [0xDD; 32],
        office: "Governor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 200_000,
        status: ContractStatus::Suspended,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "Suspended contract must be rejected");
}
