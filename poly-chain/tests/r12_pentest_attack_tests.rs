//! Round 12 Pentest Attack Tests
//!
//! Tests for vulnerabilities found in Round 12 security audit.
//! Each test verifies a specific attack vector is properly mitigated.
//!
//! Findings summary:
//! - R12-01 CRITICAL: AppStateUpdate uses raw app_id as SMT key (cross-account overwrite)
//! - R12-02 HIGH:     ProvideData overwrites investigation record, destroying deadline data
//! - R12-03 HIGH:     STPAction has no nonce — replay of RegisterContract/TriggerInvestigation
//! - R12-04 HIGH:     Fraud submitter == observer creates incentive for self-serving fraud
//! - R12-05 HIGH:     fee + amount overflow not checked for u64::MAX - 1 edge cases
//! - R12-06 MEDIUM:   CheckDeadline is a no-op (never applies freeze/slash enforcement)
//! - R12-07 MEDIUM:   Block with tx_count=0 but non-empty transactions list
//! - R12-08 MEDIUM:   Multiple compliance reports from same tx with structuring via rolling total

use poly_chain::prelude::*;
use poly_chain::block::{Block, BlockHeader};
use poly_chain::compliance::{check_compliance, ComplianceStatus, ReportType};
use poly_chain::fraud::{ConflictType, FraudEvidence, StateObservation};
use poly_chain::identity::Tier;
use poly_chain::stp::{
    ContractStatus, InvestigationAction, InvestigationRecord, InvestigationStatus,
    ServiceContract, check_investigation_deadlines,
};
use poly_chain::state::GlobalState;
use poly_chain::transaction::{
    AppStateUpdate, AtomicSwapClaim, AtomicSwapInit, AtomicSwapRefund,
    BackupStore, CashTransfer, FraudProofTx,
    IdentityRegister, STPAction, STPActionTx, Transaction,
    WalletSync,
};
use poly_chain::validation::validate_transaction;
use poly_chain::wallet::WalletState;
use poly_chain::fee::FeeSchedule;
use poly_verified::types::{PrivacyMode, VerifiedProof, ZERO_HASH};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn mock_proof() -> VerifiedProof {
    VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    }
}

/// Set up two wallets (alice + bob) with identities registered.
fn setup_with_identities() -> (GlobalState, AccountId, AccountId) {
    let mut state = GlobalState::genesis();
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];

    let alice_wallet = WalletState::new([0xAA; 32], Tier::Identified, 1_000_000);
    let bob_wallet = WalletState::new([0xBB; 32], Tier::Identified, 500_000);
    state.set_wallet(alice, alice_wallet.state_hash());
    state.set_wallet(bob, bob_wallet.state_hash());

    // Register Alice identity
    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx, &state, 1000, 0).unwrap();

    // Register Bob identity
    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: bob,
        tier: Tier::Identified,
        identity_hash: [0xBB; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx, &state, 1000, 0).unwrap();

    (state, alice, bob)
}

/// Register an STP contract for an official.
fn register_official(state: &GlobalState, official: AccountId) -> GlobalState {
    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    validate_transaction(&tx, &state, 1000, 0).unwrap()
}


// ===========================================================================
// R12-01 CRITICAL: AppStateUpdate cross-account overwrite via shared app_id
// ===========================================================================

/// FIXED: Two accounts using the same app_id should NOT see each other's state.
/// Previously, the raw app_id was the SMT key, so Bob could overwrite Alice's state.
#[test]
fn r12_01_app_state_cross_account_isolation() {
    let (state, alice, bob) = setup_with_identities();
    let app_id = [0xA0; 32];

    // Alice sets app state
    let tx_alice = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: [0x11; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state_after_alice = validate_transaction(&tx_alice, &state, 1000, 0).unwrap();

    // Bob sets the SAME app_id with different state
    let tx_bob = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: bob,
        app_id,
        new_state_hash: [0x22; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state_after_both = validate_transaction(&tx_bob, &state_after_alice, 1000, 0).unwrap();

    // Alice's state should still be [0x11; 32], not overwritten by Bob
    let alice_key = hash_with_domain(
        DOMAIN_WALLET_STATE,
        &[alice.as_slice(), &app_id].concat(),
    );
    let bob_key = hash_with_domain(
        DOMAIN_WALLET_STATE,
        &[bob.as_slice(), &app_id].concat(),
    );
    assert_eq!(state_after_both.get_app_state(&alice_key), Some([0x11; 32]));
    assert_eq!(state_after_both.get_app_state(&bob_key), Some([0x22; 32]));
    assert_ne!(alice_key, bob_key, "keys must differ for account isolation");
}

/// Verify that after the fix, looking up raw app_id returns None (no longer used as key).
#[test]
fn r12_01_raw_app_id_no_longer_used_as_key() {
    let (state, alice, _bob) = setup_with_identities();
    let app_id = [0xA0; 32];

    let tx = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: [0x11; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let new_state = validate_transaction(&tx, &state, 1000, 0).unwrap();

    // The raw app_id should NOT be a key anymore
    assert!(new_state.get_app_state(&app_id).is_none(),
        "raw app_id should not be used as SMT key (must be account-scoped)");
}

/// Multiple app state updates by same account should work with nonce increments.
#[test]
fn r12_01_sequential_app_state_updates_same_account() {
    let (state, alice, _bob) = setup_with_identities();
    let app_id = [0xA0; 32];

    // First update: nonce 0
    let tx1 = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: [0x11; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx1, &state, 1000, 0).unwrap();

    // Second update: nonce 1
    let tx2 = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: [0x22; 32],
        nonce: 1,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx2, &state, 1000, 0).unwrap();

    let app_key = hash_with_domain(
        DOMAIN_WALLET_STATE,
        &[alice.as_slice(), &app_id].concat(),
    );
    assert_eq!(state.get_app_state(&app_key), Some([0x22; 32]));
}

/// Different app_ids for same account should be independent.
#[test]
fn r12_01_different_app_ids_independent_per_account() {
    let (state, alice, _bob) = setup_with_identities();
    let app_id_1 = [0xA0; 32];
    let app_id_2 = [0xA1; 32];

    let tx1 = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id: app_id_1,
        new_state_hash: [0x11; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx1, &state, 1000, 0).unwrap();

    let tx2 = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id: app_id_2,
        new_state_hash: [0x22; 32],
        nonce: 1,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx2, &state, 1000, 0).unwrap();

    let key1 = hash_with_domain(DOMAIN_WALLET_STATE, &[alice.as_slice(), &app_id_1].concat());
    let key2 = hash_with_domain(DOMAIN_WALLET_STATE, &[alice.as_slice(), &app_id_2].concat());
    assert_eq!(state.get_app_state(&key1), Some([0x11; 32]));
    assert_eq!(state.get_app_state(&key2), Some([0x22; 32]));
}

// ===========================================================================
// R12-02 HIGH: ProvideData overwrites investigation record
// ===========================================================================

/// FIXED: After ProvideData, the investigation record should still exist under
/// the original investigation_id. Previously it was overwritten with data_hash.
#[test]
fn r12_02_provide_data_preserves_investigation_record() {
    let (state, _alice, _bob) = setup_with_identities();
    let official = [0xC0; 32];

    // Create wallet + identity for official
    let mut state = state;
    let official_wallet = WalletState::new([0xCC; 32], Tier::PublicOfficial, 1000);
    state.set_wallet(official, official_wallet.state_hash());
    let state = register_official(&state, official);

    // Trigger investigation
    let pool_id = [0xD0; 32];
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: [0xE0; 32],
        timestamp: 2000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 2000, 0).unwrap();

    // Record the investigation hash before ProvideData
    let inv_hash_before = state.get_stp_record(&pool_id).unwrap();

    // Official provides data
    let data_hash = [0xDA; 32];
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash,
        },
        submitter: official,
        timestamp: 3000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&provide_tx, &state, 3000, 0).unwrap();

    // Investigation record should still exist at pool_id (not overwritten)
    let inv_hash_after = state.get_stp_record(&pool_id).unwrap();
    assert_eq!(inv_hash_before, inv_hash_after,
        "investigation record must be preserved after ProvideData");
}

/// The provided data should be stored under a separate data key.
#[test]
fn r12_02_provide_data_stored_under_separate_key() {
    let (state, _alice, _bob) = setup_with_identities();
    let official = [0xC0; 32];

    let mut state = state;
    let official_wallet = WalletState::new([0xCC; 32], Tier::PublicOfficial, 1000);
    state.set_wallet(official, official_wallet.state_hash());
    let state = register_official(&state, official);

    let pool_id = [0xD0; 32];
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: [0xE0; 32],
        timestamp: 2000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 2000, 0).unwrap();

    let data_hash = [0xDA; 32];
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash,
        },
        submitter: official,
        timestamp: 3000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&provide_tx, &state, 3000, 0).unwrap();

    // Data should be stored under the data-specific key
    let data_key = hash_with_domain(
        DOMAIN_STP,
        &[b"stp_data_v1".as_slice(), pool_id.as_slice()].concat(),
    );
    assert_eq!(state.get_stp_record(&data_key), Some(data_hash));
}

/// After ProvideData, CheckDeadline should still find the investigation.
#[test]
fn r12_02_check_deadline_still_works_after_provide_data() {
    let (state, _alice, _bob) = setup_with_identities();
    let official = [0xC0; 32];

    let mut state = state;
    let official_wallet = WalletState::new([0xCC; 32], Tier::PublicOfficial, 1000);
    state.set_wallet(official, official_wallet.state_hash());
    let state = register_official(&state, official);

    let pool_id = [0xD0; 32];
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: [0xE0; 32],
        timestamp: 2000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 2000, 0).unwrap();

    // Provide data
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: [0xDA; 32],
        },
        submitter: official,
        timestamp: 3000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&provide_tx, &state, 3000, 0).unwrap();

    // CheckDeadline should still succeed (investigation record still exists)
    let check_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::CheckDeadline {
            investigation_id: pool_id,
        },
        submitter: [0xF0; 32],
        timestamp: 4000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&check_tx, &state, 4000, 0);
    assert!(result.is_ok(), "CheckDeadline should work after ProvideData: {:?}", result.err());
}

// ===========================================================================
// R12-03 HIGH: STPAction replay — no nonce means same-timestamp replays possible
// ===========================================================================

/// Trigger two different investigations in sequence (same submitter). Both should succeed.
#[test]
fn r12_03_stp_multiple_investigations_different_pools() {
    let (state, _alice, _bob) = setup_with_identities();
    let official = [0xC0; 32];

    let mut state = state;
    let official_wallet = WalletState::new([0xCC; 32], Tier::PublicOfficial, 1000);
    state.set_wallet(official, official_wallet.state_hash());
    let state = register_official(&state, official);

    // First investigation
    let pool1 = [0xD1; 32];
    let trigger1 = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: pool1,
        },
        submitter: [0xE0; 32],
        timestamp: 2000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger1, &state, 2000, 0).unwrap();
    assert!(state.get_stp_record(&pool1).is_some());

    // Second investigation with different pool_id
    let pool2 = [0xD2; 32];
    let trigger2 = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: pool2,
        },
        submitter: [0xE0; 32],
        timestamp: 2001,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger2, &state, 2001, 0).unwrap();
    assert!(state.get_stp_record(&pool2).is_some());
}

/// Duplicate TriggerInvestigation for the same pool_id should be rejected.
#[test]
fn r12_03_stp_duplicate_investigation_rejected() {
    let (state, _alice, _bob) = setup_with_identities();
    let official = [0xC0; 32];

    let mut state = state;
    let official_wallet = WalletState::new([0xCC; 32], Tier::PublicOfficial, 1000);
    state.set_wallet(official, official_wallet.state_hash());
    let state = register_official(&state, official);

    let pool_id = [0xD0; 32];
    let trigger = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: [0xE0; 32],
        timestamp: 2000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger, &state, 2000, 0).unwrap();

    // Replay same trigger
    let trigger_replay = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: [0xE0; 32],
        timestamp: 2001,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&trigger_replay, &state, 2001, 0);
    assert!(result.is_err(), "duplicate investigation for same pool_id must be rejected");
}

// ===========================================================================
// R12-04 HIGH: Fraud submitter can be an observer (incentive alignment issue)
// ===========================================================================

/// The fraud submitter is the one who receives the reward. If the submitter is
/// also one of the observers, they have a financial incentive to fabricate
/// observations. This test documents the current behavior.
#[test]
fn r12_04_fraud_submitter_equals_observer_accepted() {
    let mut state = GlobalState::genesis();
    let fraudster = [0xDE; 32];
    let observer_a = [0x01; 32];
    let observer_b = [0x02; 32];
    state.set_wallet(fraudster, [0xAA; 32]);

    // Submitter = observer_a — currently allowed
    let tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: fraudster,
            observation_a: StateObservation {
                observer: observer_a,
                observed_key: fraudster,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: observer_b,
                observed_key: fraudster,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: observer_a, // submitter IS observer_a
        proof: mock_proof(),
    });
    // This currently passes (documenting the behavior)
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(),
        "submitter being an observer is currently allowed — should be documented/mitigated");
}

/// Observer-as-fraudster is correctly rejected (R11 fix).
#[test]
fn r12_04_observer_equals_fraudster_rejected() {
    let mut state = GlobalState::genesis();
    let fraudster = [0xDE; 32];
    state.set_wallet(fraudster, [0xAA; 32]);

    let tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: fraudster,
            observation_a: StateObservation {
                observer: fraudster, // observer IS the fraudster
                observed_key: fraudster,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: fraudster,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x03; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "observer == fraudster should be rejected");
}

// ===========================================================================
// R12-05 HIGH: fee + amount near u64::MAX edge cases
// ===========================================================================

/// fee + amount that overflows u64 should be caught by checked_add.
#[test]
fn r12_05_fee_plus_amount_overflow() {
    let (state, alice, bob) = setup_with_identities();
    let state_pre = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: u64::MAX - 50,
        fee: 100, // amount + fee > u64::MAX
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: u64::MAX - 50,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "fee + amount overflow must be rejected");
}

/// fee = u64::MAX and amount = 1 overflows.
#[test]
fn r12_05_max_fee_plus_min_amount() {
    let (state, alice, bob) = setup_with_identities();
    let state_pre = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1,
        fee: u64::MAX,
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "u64::MAX fee + 1 amount must overflow and be rejected");
}

/// Both fee and amount at u64::MAX/2 + 1 should overflow.
#[test]
fn r12_05_half_max_both_overflow() {
    let (state, alice, bob) = setup_with_identities();
    let state_pre = state.get_wallet(&alice).unwrap();
    let half = u64::MAX / 2 + 1;

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: half,
        fee: half,
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: half,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "half + half overflow must be rejected");
}

// ===========================================================================
// R12-06 MEDIUM: CheckDeadline is a no-op
// ===========================================================================

/// CheckDeadline on a non-existent investigation should fail.
#[test]
fn r12_06_check_deadline_nonexistent_investigation() {
    let state = GlobalState::genesis();
    let check = Transaction::STPAction(STPActionTx {
        action: STPAction::CheckDeadline {
            investigation_id: [0xFF; 32],
        },
        submitter: [0xE0; 32],
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&check, &state, 1000, 0);
    assert!(result.is_err(), "CheckDeadline on non-existent investigation must fail");
}

/// CheckDeadline should succeed on existing investigation.
#[test]
fn r12_06_check_deadline_existing_investigation() {
    let (state, _alice, _bob) = setup_with_identities();
    let official = [0xC0; 32];
    let mut state = state;
    let official_wallet = WalletState::new([0xCC; 32], Tier::PublicOfficial, 1000);
    state.set_wallet(official, official_wallet.state_hash());
    let state = register_official(&state, official);

    let pool_id = [0xD0; 32];
    let trigger = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: [0xE0; 32],
        timestamp: 2000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger, &state, 2000, 0).unwrap();

    let check = Transaction::STPAction(STPActionTx {
        action: STPAction::CheckDeadline {
            investigation_id: pool_id,
        },
        submitter: [0xF0; 32],
        timestamp: 3000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&check, &state, 3000, 0);
    assert!(result.is_ok(), "CheckDeadline should succeed on existing investigation");
}

/// CheckDeadline state doesn't change (it's read-only — documents current limitation).
#[test]
fn r12_06_check_deadline_does_not_modify_state() {
    let (state, _alice, _bob) = setup_with_identities();
    let official = [0xC0; 32];
    let mut state = state;
    let official_wallet = WalletState::new([0xCC; 32], Tier::PublicOfficial, 1000);
    state.set_wallet(official, official_wallet.state_hash());
    let state = register_official(&state, official);

    let pool_id = [0xD0; 32];
    let trigger = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: [0xE0; 32],
        timestamp: 2000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger, &state, 2000, 0).unwrap();
    let root_before = state.state_root();

    // CheckDeadline past the 72h compliance deadline
    let check = Transaction::STPAction(STPActionTx {
        action: STPAction::CheckDeadline {
            investigation_id: pool_id,
        },
        submitter: [0xF0; 32],
        timestamp: 2000 + SECONDS_72H + 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state_after = validate_transaction(&check, &state, 2000 + SECONDS_72H + 1, 0).unwrap();

    // State root should be unchanged — CheckDeadline is a no-op currently.
    // This documents the limitation; future implementation should freeze the account.
    assert_eq!(state_after.state_root(), root_before,
        "CheckDeadline currently does not modify state (documenting limitation)");
}

// ===========================================================================
// R12-07 MEDIUM: Block validation edge cases
// ===========================================================================

/// Block with tx_count=0 but non-empty transactions is invalid.
#[test]
fn r12_07_block_tx_count_mismatch_zero_vs_nonempty() {
    let genesis = Block::genesis([0xAA; 32], 1000);

    // Create a block manually with mismatched tx_count
    let block = Block {
        header: BlockHeader {
            height: 1,
            timestamp: 2000,
            prev_block_hash: genesis.header.block_hash(),
            state_root: [0xBB; 32],
            transactions_root: ZERO_HASH,
            tx_count: 0, // claims 0 transactions
        },
        // But actually has a transaction
        transactions: vec![Transaction::IdentityRegister(IdentityRegister {
            account_id: [1u8; 32],
            tier: Tier::Anonymous,
            identity_hash: [0xAA; 32],
            jurisdiction: 840,
            is_public_official: false,
            office: None,
            proof: mock_proof(),
            signature: [0u8; 64],
        })],
    };

    let result = block.validate_against_parent(&genesis.header);
    assert!(result.is_err(), "tx_count=0 with non-empty txs must be rejected");
}

/// Block with height gap (parent=0, child=2) must be rejected.
#[test]
fn r12_07_block_height_gap() {
    let genesis = Block::genesis([0xAA; 32], 1000);

    let block = Block {
        header: BlockHeader {
            height: 2, // should be 1
            timestamp: 2000,
            prev_block_hash: genesis.header.block_hash(),
            state_root: [0xBB; 32],
            transactions_root: ZERO_HASH,
            tx_count: 0,
        },
        transactions: vec![],
    };

    let result = block.validate_against_parent(&genesis.header);
    assert!(result.is_err(), "height gap must be rejected");
}

/// Block with timestamp before parent must be rejected.
#[test]
fn r12_07_block_timestamp_regression() {
    let genesis = Block::genesis([0xAA; 32], 5000);

    let block = Block {
        header: BlockHeader {
            height: 1,
            timestamp: 4999, // before parent
            prev_block_hash: genesis.header.block_hash(),
            state_root: [0xBB; 32],
            transactions_root: ZERO_HASH,
            tx_count: 0,
        },
        transactions: vec![],
    };

    let result = block.validate_against_parent(&genesis.header);
    assert!(result.is_err(), "timestamp regression must be rejected");
}

/// Block with wrong parent hash must be rejected.
#[test]
fn r12_07_block_wrong_parent_hash() {
    let genesis = Block::genesis([0xAA; 32], 1000);

    let block = Block {
        header: BlockHeader {
            height: 1,
            timestamp: 2000,
            prev_block_hash: [0xFF; 32], // wrong hash
            state_root: [0xBB; 32],
            transactions_root: ZERO_HASH,
            tx_count: 0,
        },
        transactions: vec![],
    };

    let result = block.validate_against_parent(&genesis.header);
    assert!(result.is_err(), "wrong parent hash must be rejected");
}

/// Block header with trailing bytes must be rejected.
#[test]
fn r12_07_block_header_trailing_bytes() {
    let genesis = Block::genesis([0xAA; 32], 1000);
    let mut bytes = genesis.header.to_bytes();
    bytes.push(0xFF); // trailing garbage

    let result = BlockHeader::from_bytes(&bytes);
    assert!(result.is_err(), "trailing bytes in block header must be rejected");
}

// ===========================================================================
// R12-08 MEDIUM: Compliance report edge cases
// ===========================================================================

/// Both single-transfer and rolling-total can be near the threshold.
/// Single transfer exactly at threshold generates a Single report (not Rolling).
#[test]
fn r12_08_compliance_single_at_threshold_takes_priority() {
    let threshold = Tier::Identified.reporting_threshold();
    let status = check_compliance(
        threshold, // exactly at threshold
        threshold + 500, // rolling also above
        Tier::Identified,
        840,
        1000,
        [1u8; 32],
        [2u8; 32],
        [0xAA; 32],
        0,
    );
    match status {
        ComplianceStatus::ReportGenerated(report) => {
            assert_eq!(report.report_type, ReportType::Single,
                "single transfer at threshold should generate Single report");
        }
        _ => panic!("expected report at threshold"),
    }
}

/// Just below threshold: no report generated.
#[test]
fn r12_08_compliance_just_below_threshold_no_report() {
    let threshold = Tier::Identified.reporting_threshold();
    let status = check_compliance(
        threshold - 1,
        threshold - 1,
        Tier::Identified,
        840,
        1000,
        [1u8; 32],
        [2u8; 32],
        [0xAA; 32],
        0,
    );
    assert!(matches!(status, ComplianceStatus::BelowThreshold));
}

/// Rolling total at threshold but single below — generates RollingTotal report.
#[test]
fn r12_08_compliance_rolling_at_threshold_single_below() {
    let threshold = Tier::Identified.reporting_threshold();
    let status = check_compliance(
        100, // well below threshold
        threshold, // rolling exactly at threshold
        Tier::Identified,
        840,
        1000,
        [1u8; 32],
        [2u8; 32],
        [0xAA; 32],
        0,
    );
    match status {
        ComplianceStatus::ReportGenerated(report) => {
            assert_eq!(report.report_type, ReportType::RollingTotal);
        }
        _ => panic!("expected rolling total report"),
    }
}

/// PublicOfficial has lower threshold — same amount triggers report for official but not identified.
#[test]
fn r12_08_compliance_official_lower_threshold() {
    let official_threshold = Tier::PublicOfficial.reporting_threshold();
    let identified_threshold = Tier::Identified.reporting_threshold();

    // Amount between official and identified thresholds
    let amount = official_threshold + 1;
    assert!(amount < identified_threshold, "amount must be between thresholds");

    let official_result = check_compliance(
        amount, amount, Tier::PublicOfficial, 840, 1000,
        [1u8; 32], [2u8; 32], [0xAA; 32], 0,
    );
    let identified_result = check_compliance(
        amount, amount, Tier::Identified, 840, 1000,
        [1u8; 32], [2u8; 32], [0xAA; 32], 0,
    );

    assert!(matches!(official_result, ComplianceStatus::ReportGenerated(_)),
        "official should trigger report");
    assert!(matches!(identified_result, ComplianceStatus::BelowThreshold),
        "identified should NOT trigger report");
}

// ===========================================================================
// Cross-transaction atomicity and state consistency
// ===========================================================================

/// Transfer then backup store should work with correctly incremented nonces.
#[test]
fn r12_cross_tx_transfer_then_backup_nonce_sequence() {
    let (state, alice, bob) = setup_with_identities();
    let state_pre = state.get_wallet(&alice).unwrap();

    // Transfer (nonce=0)
    let tx1 = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let state = validate_transaction(&tx1, &state, 1000, 0).unwrap();

    // Backup store (nonce=1, since transfer consumed nonce 0)
    let tx2 = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3],
        state_hash: [0xCC; 32],
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx2, &state, 1000, 0).unwrap();

    assert_eq!(state.get_backup(&alice), Some([0xCC; 32]));
}

/// Replay of the same nonce after a successful transaction should fail.
#[test]
fn r12_cross_tx_nonce_replay_rejected() {
    let (state, alice, bob) = setup_with_identities();
    let state_pre = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let state = validate_transaction(&tx, &state, 1000, 0).unwrap();

    // Replay with nonce=0 (now expects 1)
    let new_pre = state.get_wallet(&alice).unwrap();
    let tx_replay = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 500,
        fee: 100,
        nonce: 0, // replayed nonce
        timestamp: 1001,
        state_pre: new_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1500,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx_replay, &state, 1001, 0);
    assert!(result.is_err(), "nonce replay must be rejected");
}

// ===========================================================================
// Timestamp edge cases
// ===========================================================================

/// Timestamp exactly at MAX_DRIFT boundary (300 seconds) should be accepted.
#[test]
fn r12_timestamp_at_exact_drift_boundary() {
    let (state, alice, bob) = setup_with_identities();
    let now = 10000u64;
    let state_pre = state.get_wallet(&alice).unwrap();

    // tx_timestamp = now + 300 (exactly at MAX_TIMESTAMP_DRIFT)
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: now + 300,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, now, 0);
    assert!(result.is_ok(), "timestamp exactly at drift boundary should be accepted");
}

/// Timestamp one second beyond MAX_DRIFT should be rejected.
#[test]
fn r12_timestamp_beyond_drift_boundary() {
    let (state, alice, bob) = setup_with_identities();
    let now = 10000u64;
    let state_pre = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: now + 301, // one second beyond drift
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, now, 0);
    assert!(result.is_err(), "timestamp beyond drift boundary must be rejected");
}

/// Timestamp 0 with now=0 should be accepted (genesis scenario).
#[test]
fn r12_timestamp_zero_epoch() {
    let (state, alice, bob) = setup_with_identities();
    let state_pre = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 0,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 0, 0);
    assert!(result.is_ok(), "timestamp 0 with now=0 should be valid");
}

// ===========================================================================
// Atomic swap edge cases
// ===========================================================================

/// Swap with timeout at exactly block_height should fail (must be strictly greater).
#[test]
fn r12_swap_timeout_at_current_height() {
    let (state, _alice, bob) = setup_with_identities();
    let initiator = [3u8; 32];
    let block_height = 100u64;

    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[initiator.as_slice(), bob.as_slice(), &0u64.to_le_bytes()].concat(),
    );
    let secret = [0x5E; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, &secret);

    let swap = AtomicSwapInit {
        swap_id,
        initiator,
        responder: bob,
        amount: 5000,
        hash_lock,
        timeout: block_height, // exactly at current height
        disclosure_root: None,
        execution_proof: None,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    };

    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, block_height);
    assert!(result.is_err(), "timeout at current block_height must be rejected");
}

/// Swap claim at exactly the timeout block should fail (must be before timeout).
#[test]
fn r12_swap_claim_at_timeout() {
    let (state, _alice, bob) = setup_with_identities();
    let initiator = [3u8; 32];
    let timeout = 200u64;

    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[initiator.as_slice(), bob.as_slice(), &0u64.to_le_bytes()].concat(),
    );
    let secret = [0x5E; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, &secret);

    let swap = AtomicSwapInit {
        swap_id,
        initiator,
        responder: bob,
        amount: 5000,
        hash_lock,
        timeout,
        disclosure_root: None,
        execution_proof: None,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    };

    let tx = Transaction::AtomicSwapInit(swap.clone());
    let state = validate_transaction(&tx, &state, 1000, 50).unwrap();

    // Claim at exactly timeout (should fail — claim must be before timeout)
    let claim = AtomicSwapClaim {
        swap_id: swap.swap_id,
        secret,
        claimer: initiator,
        original_initiator: initiator,
        original_responder: bob,
        original_amount: 5000,
        original_hash_lock: hash_lock,
        original_timeout: timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    };

    let result = validate_transaction(&Transaction::AtomicSwapClaim(claim), &state, 1000, timeout);
    assert!(result.is_err(), "claim at timeout block must be rejected");
}

/// Swap refund before timeout should fail.
#[test]
fn r12_swap_refund_before_timeout() {
    let (state, _alice, bob) = setup_with_identities();
    let initiator = [3u8; 32];
    let timeout = 200u64;

    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[initiator.as_slice(), bob.as_slice(), &0u64.to_le_bytes()].concat(),
    );
    let secret = [0x5E; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, &secret);

    let swap = AtomicSwapInit {
        swap_id,
        initiator,
        responder: bob,
        amount: 5000,
        hash_lock,
        timeout,
        disclosure_root: None,
        execution_proof: None,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    };

    let tx = Transaction::AtomicSwapInit(swap.clone());
    let state = validate_transaction(&tx, &state, 1000, 50).unwrap();

    let refund = AtomicSwapRefund {
        swap_id: swap.swap_id,
        refundee: bob,
        original_initiator: initiator,
        original_responder: bob,
        original_amount: 5000,
        original_hash_lock: hash_lock,
        original_timeout: timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    };

    let result = validate_transaction(&Transaction::AtomicSwapRefund(refund), &state, 1000, 199);
    assert!(result.is_err(), "refund before timeout must be rejected");
}

// ===========================================================================
// Identity and tier edge cases
// ===========================================================================

/// Anonymous sender (no identity) cannot claim higher tier.
#[test]
fn r12_tier_escalation_without_identity() {
    let mut state = GlobalState::genesis();
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];

    let alice_wallet = WalletState::new([0xAA; 32], Tier::Anonymous, 1000);
    let bob_wallet = WalletState::new([0xBB; 32], Tier::Anonymous, 1000);
    state.set_wallet(alice, alice_wallet.state_hash());
    state.set_wallet(bob, bob_wallet.state_hash());

    let state_pre = state.get_wallet(&alice).unwrap();

    // Try claiming Identified tier without registration
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified, // escalation attempt!
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "tier escalation without identity must be rejected");
}

/// Anonymous sender with Anonymous tier should succeed (no identity required).
#[test]
fn r12_anonymous_transfer_with_correct_tier() {
    let mut state = GlobalState::genesis();
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];

    let alice_wallet = WalletState::new([0xAA; 32], Tier::Anonymous, 1000);
    let bob_wallet = WalletState::new([0xBB; 32], Tier::Anonymous, 1000);
    state.set_wallet(alice, alice_wallet.state_hash());
    state.set_wallet(bob, bob_wallet.state_hash());

    let state_pre = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Anonymous, // correct tier
        sender_identity_hash: ZERO_HASH,
        recipient_identity_hash: ZERO_HASH,
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "anonymous transfer with correct tier should succeed");
}

// ===========================================================================
// SMT zero-hash sentinel attacks
// ===========================================================================

/// WalletSync with ZERO_HASH should be rejected (would delete wallet).
#[test]
fn r12_wallet_sync_zero_hash_rejected() {
    let (state, alice, _bob) = setup_with_identities();

    let tx = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: ZERO_HASH,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "ZERO_HASH wallet sync must be rejected");
}

/// AppStateUpdate with ZERO_HASH should be rejected (would delete app state).
#[test]
fn r12_app_state_zero_hash_rejected() {
    let (state, alice, _bob) = setup_with_identities();

    let tx = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id: [0xA0; 32],
        new_state_hash: ZERO_HASH,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "ZERO_HASH app state update must be rejected");
}

/// Backup store with ZERO_HASH should be rejected.
#[test]
fn r12_backup_store_zero_hash_rejected() {
    let (state, alice, _bob) = setup_with_identities();

    let tx = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3],
        state_hash: ZERO_HASH,
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "ZERO_HASH backup store must be rejected");
}

// ===========================================================================
// Fee schedule validation
// ===========================================================================

/// Fee below base_fee should be rejected for CashTransfer.
#[test]
fn r12_fee_below_base_fee_rejected() {
    let (state, alice, bob) = setup_with_identities();
    let state_pre = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: FeeSchedule::base_fee() - 1, // below minimum
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "fee below base_fee must be rejected");
}

/// Fee exactly at base_fee should be accepted.
#[test]
fn r12_fee_at_base_fee_accepted() {
    let (state, alice, bob) = setup_with_identities();
    let state_pre = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: FeeSchedule::base_fee(),
        nonce: 0,
        timestamp: 1000,
        state_pre,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "fee at base_fee should be accepted");
}

// ===========================================================================
// Investigation deadline logic tests
// ===========================================================================

/// Investigation at u64::MAX timestamp should not overflow in deadlines.
#[test]
fn r12_investigation_max_timestamp_no_overflow() {
    let inv = InvestigationRecord::new([0xAA; 32], [0xBB; 32], u64::MAX);
    // Saturating arithmetic means both deadlines clamp to u64::MAX
    assert_eq!(inv.compliance_deadline, u64::MAX);
    assert_eq!(inv.final_deadline, u64::MAX);
}

/// Investigation with now=0 should set reasonable deadlines.
#[test]
fn r12_investigation_zero_timestamp() {
    let inv = InvestigationRecord::new([0xAA; 32], [0xBB; 32], 0);
    assert_eq!(inv.compliance_deadline, SECONDS_72H);
    assert_eq!(inv.final_deadline, SECONDS_72H + SECONDS_30D);
}

/// FreezeAccount action at exactly compliance_deadline.
#[test]
fn r12_investigation_freeze_at_exact_deadline() {
    let inv = InvestigationRecord::new([0xAA; 32], [0xBB; 32], 1000);
    let action = check_investigation_deadlines(&inv, inv.compliance_deadline);
    assert_eq!(action, InvestigationAction::FreezeAccount);
}

/// DataProvided status means no further action regardless of time.
#[test]
fn r12_investigation_data_provided_no_action() {
    let mut inv = InvestigationRecord::new([0xAA; 32], [0xBB; 32], 1000);
    inv.status = InvestigationStatus::DataProvided;
    let action = check_investigation_deadlines(&inv, u64::MAX);
    assert_eq!(action, InvestigationAction::NoAction);
}

// ===========================================================================
// State root consistency tests
// ===========================================================================

/// Two states with same wallets but different nonces should have different roots.
#[test]
fn r12_state_root_includes_nonces() {
    let mut state1 = GlobalState::genesis();
    let mut state2 = GlobalState::genesis();

    state1.set_wallet([1u8; 32], [0xAA; 32]);
    state2.set_wallet([1u8; 32], [0xAA; 32]);

    // Same wallets but different nonces
    state1.set_nonce([1u8; 32], 0);
    state2.set_nonce([1u8; 32], 1);

    assert_ne!(state1.state_root(), state2.state_root(),
        "states with different nonces must have different roots");
}

/// Empty nonces should produce the same root as genesis.
#[test]
fn r12_state_root_empty_nonces_equals_genesis() {
    let state = GlobalState::genesis();
    let genesis_root = state.state_root();

    // Create another genesis and verify root matches
    let state2 = GlobalState::genesis();
    assert_eq!(state2.state_root(), genesis_root);
}

/// State root changes when any subtree changes.
#[test]
fn r12_state_root_changes_per_subtree() {
    let genesis_root = GlobalState::genesis().state_root();

    // Each subtree mutation should produce a unique root
    let mut roots = vec![];

    let mut s = GlobalState::genesis();
    s.set_wallet([1u8; 32], [0xAA; 32]);
    roots.push(s.state_root());

    let mut s = GlobalState::genesis();
    s.set_identity([1u8; 32], [0xAA; 32]);
    roots.push(s.state_root());

    let mut s = GlobalState::genesis();
    s.add_compliance_report([1u8; 32], [0xAA; 32]);
    roots.push(s.state_root());

    let mut s = GlobalState::genesis();
    s.add_fraud_evidence([1u8; 32], [0xAA; 32]);
    roots.push(s.state_root());

    let mut s = GlobalState::genesis();
    s.set_backup([1u8; 32], [0xAA; 32]);
    roots.push(s.state_root());

    let mut s = GlobalState::genesis();
    s.set_stp_record([1u8; 32], [0xAA; 32]);
    roots.push(s.state_root());

    let mut s = GlobalState::genesis();
    s.set_app_state([1u8; 32], [0xAA; 32]);
    roots.push(s.state_root());

    let mut s = GlobalState::genesis();
    s.set_swap([1u8; 32], [0xAA; 32]);
    roots.push(s.state_root());

    // All roots should be unique and different from genesis
    for root in &roots {
        assert_ne!(*root, genesis_root, "mutated root must differ from genesis");
    }
    // Check all are unique
    for i in 0..roots.len() {
        for j in (i + 1)..roots.len() {
            assert_ne!(roots[i], roots[j], "subtree roots must be independent");
        }
    }
}
