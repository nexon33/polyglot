//! Round 10 Pentest Attack Tests
//!
//! Tests for vulnerabilities found in Round 10 security audit.
//! Each test verifies a specific attack vector is properly mitigated.
//!
//! Findings summary:
//! - R10-01 HIGH:   STP TriggerInvestigation can be replayed to reset compliance deadlines
//! - R10-02 HIGH:   WalletState/WalletStateCommitment from_bytes accept trailing garbage
//! - R10-03 HIGH:   IdentityRecord from_bytes accepts trailing garbage (non-canonical)
//! - R10-04 HIGH:   Fraud proof against nonexistent wallet pollutes evidence tree
//! - R10-05 HIGH:   Swap timeout u64::MAX permanently locks funds (no max timeout)
//! - R10-06 MEDIUM: STP contract with zero reporting_threshold spams investigations
//! - R10-07 MEDIUM: Investigation deadline arithmetic overflow (near u64::MAX timestamps)
//! - R10-08 MEDIUM: WalletState rolling window arithmetic overflow (near u64::MAX)
//! - R10-09 MEDIUM: Rolling 24h total can be manipulated to evade compliance
//! - R10-10 LOW:    AppStateUpdate app_id has no ownership binding (cross-user overwrite)

use poly_chain::prelude::*;
use poly_chain::block::{Block, BlockHeader};
use poly_chain::fraud::{ConflictType, FraudEvidence, StateObservation};
use poly_chain::identity::{IdentityRecord, Tier};
use poly_chain::stp::{
    check_investigation_deadlines, ContractStatus, InvestigationAction, InvestigationRecord,
    ServiceContract,
};
use poly_chain::state::GlobalState;
use poly_chain::transaction::{
    AppStateUpdate, AtomicSwapClaim, AtomicSwapInit, AtomicSwapRefund,
    CashTransfer, FraudProofTx, IdentityRegister, STPAction, STPActionTx, WalletSync,
};
use poly_chain::validation::validate_transaction;
use poly_chain::wallet::{WalletState, WalletStateCommitment};
use poly_verified::types::{PrivacyMode, VerifiedProof, ZERO_HASH};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn mock_proof() -> VerifiedProof {
    VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    }
}

fn setup_wallets() -> (GlobalState, AccountId, AccountId) {
    let mut state = GlobalState::genesis();
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];

    let alice_wallet = WalletState::new([0xAA; 32], Tier::Identified, 1_000_000);
    let bob_wallet = WalletState::new([0xBB; 32], Tier::Identified, 500_000);

    state.set_wallet(alice, alice_wallet.state_hash());
    state.set_wallet(bob, bob_wallet.state_hash());

    (state, alice, bob)
}

fn setup_wallets_with_identities() -> (GlobalState, AccountId, AccountId) {
    let (state, alice, bob) = setup_wallets();

    let tx_alice_id = Transaction::IdentityRegister(IdentityRegister {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_alice_id, &state, 1000, 0).unwrap();

    let tx_bob_id = Transaction::IdentityRegister(IdentityRegister {
        account_id: bob,
        tier: Tier::Identified,
        identity_hash: [0xBB; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_bob_id, &state, 1000, 0).unwrap();

    (state, alice, bob)
}

fn register_official(state: &GlobalState, official: AccountId) -> GlobalState {
    // R13: Official must have identity and wallet before registering.
    // Ensure they exist, or create them.
    let mut state = state.clone();
    if state.get_wallet(&official).is_none() {
        let wallet = WalletState::new([0xAA; 32], Tier::PublicOfficial, 0);
        state.set_wallet(official, wallet.state_hash());
    }
    if state.get_identity(&official).is_none() {
        let record = IdentityRecord {
            account_id: official,
            tier: Tier::PublicOfficial,
            identity_hash: [0xAA; 32],
            jurisdiction: 840,
            registered_at: 0,
            is_public_official: true,
            office: Some("Mayor".into()),
        };
        state.set_identity(official, record.record_hash());
    }

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    validate_transaction(&tx, &state, 1000, 0).unwrap()
}

fn make_swap(
    initiator: AccountId,
    responder: AccountId,
    amount: Amount,
    timeout: BlockHeight,
    nonce: Nonce,
) -> AtomicSwapInit {
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[
            initiator.as_slice(),
            responder.as_slice(),
            &nonce.to_le_bytes(),
        ]
        .concat(),
    );
    let secret = [0x5E; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, &secret);

    AtomicSwapInit {
        swap_id,
        initiator,
        responder,
        amount,
        hash_lock,
        timeout,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn make_claim(swap: &AtomicSwapInit) -> AtomicSwapClaim {
    AtomicSwapClaim {
        swap_id: swap.swap_id,
        secret: [0x5E; 32],
        claimer: swap.initiator,
        original_initiator: swap.initiator,
        original_responder: swap.responder,
        original_amount: swap.amount,
        original_hash_lock: swap.hash_lock,
        original_timeout: swap.timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn make_refund(swap: &AtomicSwapInit) -> AtomicSwapRefund {
    AtomicSwapRefund {
        swap_id: swap.swap_id,
        refundee: swap.responder,
        original_initiator: swap.initiator,
        original_responder: swap.responder,
        original_amount: swap.amount,
        original_hash_lock: swap.hash_lock,
        original_timeout: swap.timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

// ===========================================================================
// R10-01 HIGH: STP TriggerInvestigation Deadline Reset Attack
// ===========================================================================

/// ATTACK: An attacker re-triggers an investigation with the same pool_id after
/// the compliance deadline is about to expire. This resets the investigation record
/// (and thus the deadlines) to now + 72h, effectively giving the official unlimited
/// deadline extensions. Repeat every 71h59m and the official is never frozen.
///
/// FIX: validate_stp_action now checks for existing inv_target_key binding and
/// rejects duplicate TriggerInvestigation for the same pool_id.
#[test]
fn r10_01_stp_investigation_deadline_reset_blocked() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x30; 32];

    let state = register_official(&state, official);

    // First trigger — legitimate
    let pool_id = [0x99; 32];
    let trigger1 = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state1 = validate_transaction(&trigger1, &state, 1000, 0).unwrap();
    assert!(state1.get_stp_record(&pool_id).is_some());

    // Second trigger with same pool_id at later time — BLOCKED
    let trigger2 = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: anyone,
        timestamp: 2000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&trigger2, &state1, 2000, 0);
    assert!(
        matches!(result, Err(ChainError::STPError(_))),
        "R10-01 FAILED: duplicate investigation trigger accepted (deadline reset attack), got {:?}",
        result
    );
}

/// Different pool_ids for the same target should still work (independent investigations).
#[test]
fn r10_01_stp_different_pool_ids_allowed() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x30; 32];

    let state = register_official(&state, official);

    let pool_a = [0x99; 32];
    let trigger_a = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: pool_a,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_a, &state, 1000, 0).unwrap();

    let pool_b = [0x88; 32]; // different pool_id
    let trigger_b = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: pool_b,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&trigger_b, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R10-01: different pool_ids should create independent investigations, got {:?}",
        result
    );
}

// ===========================================================================
// R10-02 HIGH: WalletState from_bytes Trailing Garbage
// ===========================================================================

/// ATTACK: Send a WalletState serialization with extra bytes appended.
/// The from_bytes method previously only checked minimum length, silently
/// ignoring trailing data. This creates non-canonical serializations where
/// the same logical state can have multiple byte representations.
///
/// FIX: from_bytes now rejects trailing garbage for all freeze reason variants.
#[test]
fn r10_02_wallet_state_trailing_garbage_rejected_no_freeze() {
    let w = WalletState::new([1u8; 32], Tier::Anonymous, 0);
    let mut bytes = w.to_bytes();
    assert_eq!(bytes.len(), 67); // base size for no freeze reason

    // Append garbage
    bytes.push(0xFF);
    let result = WalletState::from_bytes(&bytes);
    assert!(
        result.is_err(),
        "R10-02 FAILED: wallet state with trailing garbage accepted, got {:?}",
        result.unwrap()
    );
}

/// Trailing garbage after FraudDetected freeze reason.
#[test]
fn r10_02_wallet_state_trailing_garbage_rejected_fraud_freeze() {
    let mut w = WalletState::new([1u8; 32], Tier::Anonymous, 0);
    w.frozen = true;
    w.freeze_reason = Some(poly_chain::fraud::FreezeReason::FraudDetected);
    let mut bytes = w.to_bytes();
    assert_eq!(bytes.len(), 67); // FraudDetected is just a tag byte, same size

    bytes.push(0xFF);
    let result = WalletState::from_bytes(&bytes);
    assert!(
        result.is_err(),
        "R10-02 FAILED: wallet state (FraudDetected) with trailing garbage accepted"
    );
}

/// Trailing garbage after STPNonCompliance freeze reason.
#[test]
fn r10_02_wallet_state_trailing_garbage_rejected_stp_freeze() {
    let mut w = WalletState::new([1u8; 32], Tier::Anonymous, 0);
    w.frozen = true;
    w.freeze_reason = Some(poly_chain::fraud::FreezeReason::STPNonCompliance {
        deadline: 999999,
    });
    let mut bytes = w.to_bytes();
    assert_eq!(bytes.len(), 75); // STP freeze includes 8-byte deadline

    bytes.push(0xFF);
    let result = WalletState::from_bytes(&bytes);
    assert!(
        result.is_err(),
        "R10-02 FAILED: wallet state (STP freeze) with trailing garbage accepted"
    );
}

/// Valid wallet state bytes (exact length) still accepted.
#[test]
fn r10_02_wallet_state_exact_length_accepted() {
    let w = WalletState::new([1u8; 32], Tier::Anonymous, 0);
    let bytes = w.to_bytes();
    let result = WalletState::from_bytes(&bytes);
    assert!(
        result.is_ok(),
        "R10-02 regression: exact-length wallet state should work, got {:?}",
        result
    );
}

/// WalletStateCommitment trailing garbage rejected.
#[test]
fn r10_02_wallet_commitment_trailing_garbage_rejected() {
    let c = WalletStateCommitment {
        account_id: [5u8; 32],
        state_hash: [6u8; 32],
        nonce: 42,
        tier: Tier::Identified,
        last_updated: 1700000000,
    };
    let mut bytes = c.to_bytes();
    assert_eq!(bytes.len(), 81);

    bytes.push(0xFF);
    let result = WalletStateCommitment::from_bytes(&bytes);
    assert!(
        result.is_err(),
        "R10-02 FAILED: wallet commitment with trailing garbage accepted"
    );
}

/// Valid WalletStateCommitment (exact length) still accepted.
#[test]
fn r10_02_wallet_commitment_exact_length_accepted() {
    let c = WalletStateCommitment {
        account_id: [5u8; 32],
        state_hash: [6u8; 32],
        nonce: 42,
        tier: Tier::Identified,
        last_updated: 1700000000,
    };
    let bytes = c.to_bytes();
    let result = WalletStateCommitment::from_bytes(&bytes);
    assert!(
        result.is_ok(),
        "R10-02 regression: exact-length commitment should work"
    );
}

// ===========================================================================
// R10-03 HIGH: IdentityRecord from_bytes Trailing Garbage
// ===========================================================================

/// ATTACK: Send an IdentityRecord serialization with extra bytes after the
/// office field. The from_bytes method previously only checked minimum length,
/// allowing non-canonical serializations.
///
/// FIX: from_bytes now rejects trailing garbage for both None and Some(office).
#[test]
fn r10_03_identity_record_trailing_garbage_rejected_no_office() {
    let record = IdentityRecord {
        account_id: [1u8; 32],
        tier: Tier::Identified,
        identity_hash: [2u8; 32],
        jurisdiction: 840,
        registered_at: 1700000000,
        is_public_official: false,
        office: None,
    };
    let mut bytes = record.to_bytes();
    assert_eq!(bytes.len(), 80); // base size with no office

    bytes.push(0xFF);
    let result = IdentityRecord::from_bytes(&bytes);
    assert!(
        result.is_err(),
        "R10-03 FAILED: identity record (no office) with trailing garbage accepted"
    );
}

/// Trailing garbage after office field.
#[test]
fn r10_03_identity_record_trailing_garbage_rejected_with_office() {
    let record = IdentityRecord {
        account_id: [1u8; 32],
        tier: Tier::PublicOfficial,
        identity_hash: [2u8; 32],
        jurisdiction: 840,
        registered_at: 1700000000,
        is_public_official: true,
        office: Some("Mayor".to_string()),
    };
    let mut bytes = record.to_bytes();
    let expected_len = 80 + 5; // 80 base + 5 bytes for "Mayor"

    assert_eq!(bytes.len(), expected_len);
    bytes.push(0xFF);
    let result = IdentityRecord::from_bytes(&bytes);
    assert!(
        result.is_err(),
        "R10-03 FAILED: identity record (with office) with trailing garbage accepted"
    );
}

/// Valid identity records (exact length) still accepted.
#[test]
fn r10_03_identity_record_exact_length_accepted() {
    let record = IdentityRecord {
        account_id: [1u8; 32],
        tier: Tier::Identified,
        identity_hash: [2u8; 32],
        jurisdiction: 840,
        registered_at: 1700000000,
        is_public_official: false,
        office: None,
    };
    let bytes = record.to_bytes();
    let result = IdentityRecord::from_bytes(&bytes);
    assert!(
        result.is_ok(),
        "R10-03 regression: exact-length identity record should work"
    );

    let record2 = IdentityRecord {
        account_id: [3u8; 32],
        tier: Tier::PublicOfficial,
        identity_hash: [4u8; 32],
        jurisdiction: 528,
        registered_at: 1700000000,
        is_public_official: true,
        office: Some("Minister of Finance".to_string()),
    };
    let bytes2 = record2.to_bytes();
    let result2 = IdentityRecord::from_bytes(&bytes2);
    assert!(
        result2.is_ok(),
        "R10-03 regression: identity record with office should work"
    );
}

// ===========================================================================
// R10-04 HIGH: Fraud Proof Against Nonexistent Wallet
// ===========================================================================

/// ATTACK: Submit a fraud proof targeting an account that has no wallet.
/// Previously, this succeeded and recorded evidence against a phantom account,
/// polluting the evidence tree. With unbounded submissions, an attacker could
/// fill the fraud evidence tree with entries for accounts that never existed.
///
/// FIX: validate_fraud_proof now requires the fraudulent_key to have a wallet.
#[test]
fn r10_04_fraud_proof_nonexistent_wallet_rejected() {
    let state = GlobalState::genesis();
    let phantom = [0xDE; 32]; // no wallet exists

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: phantom,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: phantom,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: phantom,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x03; 32],
        proof: mock_proof(),
    });

    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::AccountNotFound(_))),
        "R10-04 FAILED: fraud proof against nonexistent wallet accepted, got {:?}",
        result
    );
}

/// Fraud proof against an existing wallet still works.
#[test]
fn r10_04_fraud_proof_existing_wallet_accepted() {
    let mut state = GlobalState::genesis();
    let victim = [0xDE; 32];
    state.set_wallet(victim, [0xAA; 32]); // wallet exists

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: victim,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: victim,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x03; 32],
        proof: mock_proof(),
    });

    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R10-04 regression: fraud proof with existing wallet should work, got {:?}",
        result
    );
    let new_state = result.unwrap();
    assert!(
        new_state.get_wallet(&victim).is_none(),
        "wallet should be burned"
    );
}

/// After burning a wallet, subsequent fraud proofs for the same account are rejected.
#[test]
fn r10_04_fraud_proof_after_burn_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xDE; 32];
    state.set_wallet(victim, [0xAA; 32]);

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: victim,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: victim,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x03; 32],
        proof: mock_proof(),
    });
    let state = validate_transaction(&fraud_tx, &state, 1000, 0).unwrap();

    // Second fraud proof with different evidence, but wallet is already burned
    let fraud_tx2 = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: victim,
                observed_state_hash: [0xCC; 32],
                observed_nonce: 10,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: victim,
                observed_state_hash: [0xDD; 32],
                observed_nonce: 10,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x03; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx2, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::AccountNotFound(_))),
        "R10-04: fraud proof after wallet burn should be rejected (no wallet), got {:?}",
        result
    );
}

// ===========================================================================
// R10-05 HIGH: Swap Timeout Permanent Fund Lock
// ===========================================================================

/// ATTACK: Create a swap with timeout = u64::MAX. The responder locks funds,
/// but refund requires block_height >= u64::MAX which is effectively unreachable.
/// If the initiator loses the secret, funds are permanently locked.
///
/// FIX: validate_atomic_swap_init now enforces a maximum timeout delta of
/// 1,000,000 blocks above the current block height.
#[test]
fn r10_05_swap_timeout_max_rejected() {
    let (state, alice, bob) = setup_wallets();
    let swap = make_swap(alice, bob, 5000, u64::MAX, 0);

    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(
        result.is_err(),
        "R10-05 FAILED: u64::MAX timeout accepted (permanent fund lock), got {:?}",
        result
    );
}

/// Timeout just over the maximum delta is also rejected.
#[test]
fn r10_05_swap_timeout_one_over_max_delta_rejected() {
    let (state, alice, bob) = setup_wallets();
    let current_height = 50u64;
    let max_delta = 1_000_000u64;
    let swap = make_swap(alice, bob, 5000, current_height + max_delta + 1, 0);

    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, current_height);
    assert!(
        result.is_err(),
        "R10-05: timeout one over max delta should be rejected, got {:?}",
        result
    );
}

/// Timeout exactly at the maximum delta is accepted.
#[test]
fn r10_05_swap_timeout_at_max_delta_accepted() {
    let (state, alice, bob) = setup_wallets();
    let current_height = 50u64;
    let max_delta = 1_000_000u64;
    let swap = make_swap(alice, bob, 5000, current_height + max_delta, 0);

    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, current_height);
    assert!(
        result.is_ok(),
        "R10-05 regression: timeout at max delta should work, got {:?}",
        result
    );
}

/// Reasonable timeouts still work.
#[test]
fn r10_05_swap_reasonable_timeout_accepted() {
    let (state, alice, bob) = setup_wallets();
    let swap = make_swap(alice, bob, 5000, 1000, 0);

    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(
        result.is_ok(),
        "R10-05 regression: reasonable timeout should work, got {:?}",
        result
    );
}

// ===========================================================================
// R10-06 MEDIUM: STP Contract Zero Reporting Threshold
// ===========================================================================

/// ATTACK: Register an STP contract with reporting_threshold = 0. This means
/// EVERY single transaction by this official triggers an investigation, flooding
/// the STP system with spurious alerts. Volume overload makes enforcement
/// meaningless and wastes validator resources.
///
/// FIX: validate_stp_action RegisterContract now requires non-zero threshold.
#[test]
fn r10_06_stp_contract_zero_threshold_rejected() {
    // R13: Official must have identity and wallet before registering.
    let mut state = GlobalState::genesis();
    let official = [0x10; 32];
    let wallet = WalletState::new([0xAA; 32], Tier::PublicOfficial, 0);
    state.set_wallet(official, wallet.state_hash());
    let record = IdentityRecord {
        account_id: official,
        tier: Tier::PublicOfficial,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        registered_at: 0,
        is_public_official: true,
        office: Some("Mayor".into()),
    };
    state.set_identity(official, record.record_hash());

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 0, // zero threshold!
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::STPError(_))),
        "R10-06 FAILED: zero reporting threshold accepted, got {:?}",
        result
    );
}

/// Non-zero threshold (even very small) is accepted.
#[test]
fn r10_06_stp_contract_one_threshold_accepted() {
    // R13: Official must have identity and wallet before registering.
    let mut state = GlobalState::genesis();
    let official = [0x10; 32];
    let wallet = WalletState::new([0xAA; 32], Tier::PublicOfficial, 0);
    state.set_wallet(official, wallet.state_hash());
    let record = IdentityRecord {
        account_id: official,
        tier: Tier::PublicOfficial,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        registered_at: 0,
        is_public_official: true,
        office: Some("Mayor".into()),
    };
    state.set_identity(official, record.record_hash());

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 1, // minimal but non-zero
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R10-06 regression: non-zero threshold should work, got {:?}",
        result
    );
}

// ===========================================================================
// R10-07 MEDIUM: Investigation Deadline Arithmetic Overflow
// ===========================================================================

/// ATTACK: Trigger an investigation at timestamp near u64::MAX. Without
/// saturating arithmetic, `now + SECONDS_72H + SECONDS_30D` would overflow
/// to a small value, making the final_deadline in the past. This could
/// allow immediate slashing.
///
/// FIX: InvestigationRecord::new uses saturating_add for all deadline arithmetic.
#[test]
fn r10_07_investigation_deadline_overflow_safe() {
    let near_max = u64::MAX - 100;
    let inv = InvestigationRecord::new([0xAA; 32], [0xBB; 32], near_max);

    // Deadlines should saturate at u64::MAX, not wrap around
    assert!(
        inv.compliance_deadline >= near_max,
        "R10-07 FAILED: compliance deadline wrapped around: {}",
        inv.compliance_deadline
    );
    assert!(
        inv.final_deadline >= near_max,
        "R10-07 FAILED: final deadline wrapped around: {}",
        inv.final_deadline
    );

    // Both should be u64::MAX (saturated)
    assert_eq!(
        inv.compliance_deadline,
        u64::MAX,
        "compliance deadline should saturate at u64::MAX"
    );
    assert_eq!(
        inv.final_deadline,
        u64::MAX,
        "final deadline should saturate at u64::MAX"
    );
}

/// At max timestamp, investigation should still be in AwaitingData with no action.
#[test]
fn r10_07_investigation_at_max_timestamp_no_premature_action() {
    let near_max = u64::MAX - 100;
    let inv = InvestigationRecord::new([0xAA; 32], [0xBB; 32], near_max);

    // At the trigger time + 1, no deadline should have passed
    let action = check_investigation_deadlines(&inv, near_max + 1);
    assert_eq!(
        action,
        InvestigationAction::NoAction,
        "R10-07: no premature action near u64::MAX timestamp"
    );
}

/// Normal timestamps still work correctly.
#[test]
fn r10_07_investigation_normal_timestamps_work() {
    let now = 1_000_000u64;
    let inv = InvestigationRecord::new([0xAA; 32], [0xBB; 32], now);

    assert_eq!(inv.compliance_deadline, now + 259_200); // 72h
    assert_eq!(inv.final_deadline, now + 259_200 + 2_592_000); // 72h + 30d

    let action = check_investigation_deadlines(&inv, now + 259_200);
    assert_eq!(action, InvestigationAction::FreezeAccount);
}

// ===========================================================================
// R10-08 MEDIUM: WalletState Rolling Window Arithmetic Overflow
// ===========================================================================

/// ATTACK: Create a wallet or reset the rolling window at timestamp near u64::MAX.
/// Without saturating arithmetic, `now + SECONDS_24H` would overflow to a small
/// value, making the rolling window reset_at in the past. This means the rolling
/// window is effectively disabled — every transfer appears to be in a fresh window.
///
/// FIX: WalletState::new and maybe_reset_rolling use saturating_add.
#[test]
fn r10_08_wallet_rolling_window_overflow_safe() {
    let near_max = u64::MAX - 100;
    let w = WalletState::new([1u8; 32], Tier::Anonymous, near_max);

    // rolling_reset_at should saturate, not wrap around
    assert!(
        w.rolling_reset_at >= near_max,
        "R10-08 FAILED: rolling_reset_at wrapped around: {}",
        w.rolling_reset_at
    );
    assert_eq!(
        w.rolling_reset_at,
        u64::MAX,
        "rolling_reset_at should saturate at u64::MAX"
    );
}

/// maybe_reset_rolling with near-max timestamp.
#[test]
fn r10_08_wallet_rolling_reset_overflow_safe() {
    let mut w = WalletState::new([1u8; 32], Tier::Anonymous, 1000);
    w.rolling_24h_total = 50_000;

    // Reset at a near-max timestamp
    let near_max = u64::MAX - 100;
    w.maybe_reset_rolling(near_max);

    assert_eq!(w.rolling_24h_total, 0, "total should be reset");
    assert!(
        w.rolling_reset_at >= near_max,
        "R10-08: rolling_reset_at should not wrap around"
    );
    assert_eq!(
        w.rolling_reset_at,
        u64::MAX,
        "rolling_reset_at should saturate at u64::MAX"
    );
}

/// Normal timestamps still work correctly.
#[test]
fn r10_08_wallet_rolling_normal_timestamps_work() {
    let w = WalletState::new([1u8; 32], Tier::Anonymous, 1000);
    assert_eq!(w.rolling_reset_at, 1000 + 86_400); // 24h
}

// ===========================================================================
// R10-09 MEDIUM: Rolling 24h Total Manipulation
// ===========================================================================

/// DOCUMENTED: The rolling_24h_total_after in CashTransfer is self-attested.
/// The only validation is `rolling_24h_total_after >= amount`. An attacker
/// can set it to exactly `amount` (instead of the true cumulative total),
/// effectively resetting their rolling window each transaction and evading
/// rolling-total compliance reports.
///
/// This is a fundamental limitation of the verify-only architecture: the
/// validator cannot compute the true rolling total without full wallet state.
/// The ZK proof is supposed to attest the correct rolling total, but the
/// validator can only verify the proof, not the input data.
#[test]
fn r10_09_rolling_total_manipulation_documented() {
    let (state, alice, bob) = setup_wallets_with_identities();
    let alice_hash = state.get_wallet(&alice).unwrap();
    let threshold = Tier::Identified.reporting_threshold(); // 100_000_000

    // Send 60% of the threshold in each of two transfers.
    // With honest reporting, the second transfer would bring the rolling total
    // to 120% of threshold, triggering a report.
    let amount = threshold * 6 / 10;

    // First transfer: rolling_24h_total_after = amount (honest)
    let tx1 = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: amount, // honest
        jurisdiction: 840,
    });
    let state1 = validate_transaction(&tx1, &state, 1000, 0).unwrap();
    let alice_hash1 = state1.get_wallet(&alice).unwrap();

    // Second transfer: attacker sets rolling_24h_total_after = amount (dishonest)
    // instead of amount * 2 (honest). This is below the threshold.
    let tx2 = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount,
        fee: 100,
        nonce: 1,
        timestamp: 1000,
        state_pre: alice_hash1,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: amount, // DISHONEST: should be amount * 2
        jurisdiction: 840,
    });
    // This succeeds because the validator only checks rolling_24h_total_after >= amount
    let result = validate_transaction(&tx2, &state1, 1000, 0);
    assert!(
        result.is_ok(),
        "R10-09 DOCUMENTED: manipulated rolling total is accepted (verify-only limitation)"
    );
}

// ===========================================================================
// R10-10 LOW: AppStateUpdate No Ownership Binding (Documented)
// ===========================================================================

/// FIXED in R12: App state is now scoped to account_id. Previously any user
/// could overwrite any app_id's state because the raw app_id was used as
/// the SMT key. Now the key is H(account_id || app_id), isolating each
/// user's app state.
#[test]
fn r10_10_app_state_cross_user_overwrite_documented() {
    use poly_chain::primitives::*;

    let (state, alice, bob) = setup_wallets_with_identities();
    let app_id = [0xA0; 32];

    // Alice creates app state
    let tx1 = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: [0x11; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx1, &state, 1000, 0).unwrap();
    let alice_key = hash_with_domain(
        DOMAIN_WALLET_STATE,
        &[alice.as_slice(), &app_id].concat(),
    );
    assert_eq!(state.get_app_state(&alice_key), Some([0x11; 32]));

    // Bob uses the same app_id — should NOT overwrite Alice's state
    let tx2 = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: bob,
        app_id, // same app_id!
        new_state_hash: [0x22; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx2, &state, 1000, 0).unwrap();

    // Alice's state should still be [0x11; 32]
    assert_eq!(
        state.get_app_state(&alice_key),
        Some([0x11; 32]),
        "R12 FIX: Alice's app state must NOT be overwritten by Bob"
    );
    let bob_key = hash_with_domain(
        DOMAIN_WALLET_STATE,
        &[bob.as_slice(), &app_id].concat(),
    );
    assert_eq!(
        state.get_app_state(&bob_key),
        Some([0x22; 32]),
        "Bob's app state should be stored under his own scoped key"
    );
}

// ===========================================================================
// R10 Compound Attack: Investigation Kill + Deadline Reset
// ===========================================================================

/// Compound attack: After R10-01 fix, an attacker cannot reset deadlines
/// by re-triggering the same pool_id. But they can still try with a
/// different pool_id. This test verifies that separate investigations
/// for different pool_ids are independent.
#[test]
fn r10_compound_separate_investigations_independent() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x30; 32];

    let state = register_official(&state, official);

    // First investigation
    let pool_a = [0x99; 32];
    let trigger_a = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: pool_a,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_a, &state, 1000, 0).unwrap();
    let inv_hash_a = state.get_stp_record(&pool_a).unwrap();

    // Second investigation with different pool_id
    let pool_b = [0x88; 32];
    let trigger_b = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: pool_b,
        },
        submitter: anyone,
        timestamp: 5000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_b, &state, 5000, 0).unwrap();
    let inv_hash_b = state.get_stp_record(&pool_b).unwrap();

    // Both investigations exist independently
    assert_ne!(inv_hash_a, inv_hash_b);
    assert!(state.get_stp_record(&pool_a).is_some());
    assert!(state.get_stp_record(&pool_b).is_some());
}

// ===========================================================================
// R10 Compound Attack: Fraud Proof Spam Against Phantom Accounts
// ===========================================================================

/// Compound attack: After R10-04 fix, an attacker cannot spam fraud proofs
/// against phantom accounts. This test verifies that only accounts with
/// wallets can have fraud proofs recorded.
#[test]
fn r10_compound_fraud_spam_prevention() {
    let state = GlobalState::genesis();

    // Try to submit 3 fraud proofs against different phantom accounts
    for i in 0..3u8 {
        let phantom = [i + 0xF0; 32];
        let fraud_tx = Transaction::FraudProof(FraudProofTx {
            evidence: FraudEvidence {
                fraudulent_key: phantom,
                observation_a: StateObservation {
                    observer: [0x01; 32],
                    observed_key: phantom,
                    observed_state_hash: [0xAA; 32],
                    observed_nonce: 5,
                    observer_signature: [0u8; 64],
                },
                observation_b: StateObservation {
                    observer: [0x02; 32],
                    observed_key: phantom,
                    observed_state_hash: [0xBB; 32],
                    observed_nonce: 5,
                    observer_signature: [0u8; 64],
                },
                conflict_type: ConflictType::DoubleSpend,
            },
            submitter: [0x03; 32],
            proof: mock_proof(),
        });
        let result = validate_transaction(&fraud_tx, &state, 1000, 0);
        assert!(
            matches!(result, Err(ChainError::AccountNotFound(_))),
            "R10 compound: phantom fraud proof #{i} should be rejected"
        );
    }

    // Evidence tree should still be empty
    assert!(
        state.fraud.is_empty(),
        "R10 compound: fraud evidence tree should be empty after rejected phantom proofs"
    );
}

// ===========================================================================
// R10 Compound Attack: Swap Timeout + Claim Race
// ===========================================================================

/// Compound attack: Create a swap with the maximum allowed timeout, then
/// verify claim and refund work correctly at the boundary.
#[test]
fn r10_compound_swap_max_timeout_lifecycle() {
    let (state, alice, bob) = setup_wallets();
    let current_height = 100u64;
    let max_timeout = current_height + 1_000_000; // at limit

    let swap = make_swap(alice, bob, 5000, max_timeout, 0);

    // Init succeeds
    let tx_init = Transaction::AtomicSwapInit(swap.clone());
    let state1 = validate_transaction(&tx_init, &state, 1000, current_height).unwrap();
    assert!(state1.get_swap(&swap.swap_id).is_some());

    // Claim works before timeout
    let claim = make_claim(&swap);
    let tx_claim = Transaction::AtomicSwapClaim(claim);
    let state2 = validate_transaction(&tx_claim, &state1, 1000, max_timeout - 1).unwrap();
    assert!(state2.get_swap(&swap.swap_id).is_none());
}

/// Verify that after the max allowed timeout, refund works.
#[test]
fn r10_compound_swap_max_timeout_refund() {
    let (state, alice, bob) = setup_wallets();
    let current_height = 100u64;
    let max_timeout = current_height + 1_000_000;

    let swap = make_swap(alice, bob, 5000, max_timeout, 0);

    // Init
    let tx_init = Transaction::AtomicSwapInit(swap.clone());
    let state1 = validate_transaction(&tx_init, &state, 1000, current_height).unwrap();

    // Refund at timeout
    let refund = make_refund(&swap);
    let tx_refund = Transaction::AtomicSwapRefund(refund);
    let state2 = validate_transaction(&tx_refund, &state1, 1000, max_timeout).unwrap();
    assert!(state2.get_swap(&swap.swap_id).is_none());
}

// ===========================================================================
// R10 Edge Cases
// ===========================================================================

/// Edge case: Block height near u64::MAX with swap timeout check.
#[test]
fn r10_edge_swap_timeout_near_max_block_height() {
    let (state, alice, bob) = setup_wallets();
    let near_max_height = u64::MAX - 500_000;

    // Timeout within MAX_SWAP_TIMEOUT_DELTA should still work.
    // Use saturating_add to avoid compile-time overflow.
    let timeout = near_max_height.saturating_add(999_999);
    let swap = make_swap(alice, bob, 5000, timeout, 0);
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, near_max_height);
    assert!(
        result.is_ok(),
        "R10 edge: near-max block height with valid timeout should work, got {:?}",
        result
    );
}

/// Edge case: Block height at u64::MAX - 1 with timeout u64::MAX
/// should be accepted (delta = 1, well within limit).
#[test]
fn r10_edge_swap_timeout_max_block_height_small_delta() {
    let (state, alice, bob) = setup_wallets();
    let height = u64::MAX - 1;
    let timeout = u64::MAX; // delta = 1, within 1_000_000

    let swap = make_swap(alice, bob, 5000, timeout, 0);
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, height);
    assert!(
        result.is_ok(),
        "R10 edge: u64::MAX timeout with delta=1 should work, got {:?}",
        result
    );
}

/// Edge case: Serialization roundtrip for wallet state with all freeze variants.
#[test]
fn r10_edge_wallet_state_roundtrip_all_variants() {
    // No freeze
    let w1 = WalletState::new([1u8; 32], Tier::Anonymous, 1000);
    let bytes1 = w1.to_bytes();
    let decoded1 = WalletState::from_bytes(&bytes1).unwrap();
    assert_eq!(decoded1.balance, w1.balance);
    assert_eq!(decoded1.frozen, false);

    // Fraud freeze
    let mut w2 = WalletState::new([2u8; 32], Tier::Pseudonymous, 2000);
    w2.frozen = true;
    w2.freeze_reason = Some(poly_chain::fraud::FreezeReason::FraudDetected);
    let bytes2 = w2.to_bytes();
    let decoded2 = WalletState::from_bytes(&bytes2).unwrap();
    assert_eq!(
        decoded2.freeze_reason,
        Some(poly_chain::fraud::FreezeReason::FraudDetected)
    );

    // STP freeze
    let mut w3 = WalletState::new([3u8; 32], Tier::Identified, 3000);
    w3.frozen = true;
    w3.freeze_reason = Some(poly_chain::fraud::FreezeReason::STPNonCompliance {
        deadline: 999999,
    });
    let bytes3 = w3.to_bytes();
    let decoded3 = WalletState::from_bytes(&bytes3).unwrap();
    assert_eq!(
        decoded3.freeze_reason,
        Some(poly_chain::fraud::FreezeReason::STPNonCompliance {
            deadline: 999999
        })
    );
}

// ===========================================================================
// R10 Regression: All previous fixes still work
// ===========================================================================

/// R9: ZERO_HASH app state update still rejected.
#[test]
fn r10_regression_zero_hash_app_state_still_rejected() {
    let (state, alice, _bob) = setup_wallets_with_identities();
    let tx = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id: [0xA0; 32],
        new_state_hash: ZERO_HASH,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::InvalidEncoding(_))));
}

/// R8: WalletSync ZERO_HASH still rejected.
#[test]
fn r10_regression_wallet_sync_zero_hash_still_rejected() {
    let (state, alice, _bob) = setup_wallets_with_identities();
    let tx = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: ZERO_HASH,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::InvalidEncoding(_))));
}

/// R7: Tier violation without identity still rejected.
#[test]
fn r10_regression_tier_violation_still_rejected() {
    let (state, sender, recipient) = setup_wallets();
    let sender_hash = state.get_wallet(&sender).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::TierViolation(_))));
}

/// R5: Nonce overflow still caught.
#[test]
fn r10_regression_nonce_overflow_still_caught() {
    let (mut state, alice, bob) = setup_wallets_with_identities();
    state.set_nonce(alice, u64::MAX);
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 100,
        fee: 100,
        nonce: u64::MAX,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::NonceOverflow)));
}

/// R6: Swap zero hash_lock still rejected.
#[test]
fn r10_regression_swap_zero_hash_lock_still_rejected() {
    let (state, alice, bob) = setup_wallets();
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), bob.as_slice(), &0u64.to_le_bytes()].concat(),
    );
    let swap = AtomicSwapInit {
        swap_id,
        initiator: alice,
        responder: bob,
        amount: 5000,
        hash_lock: ZERO_HASH,
        timeout: 100,
        disclosure_root: None,
        execution_proof: None,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    };
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(matches!(result, Err(ChainError::InvalidPreimage)));
}

/// R7: Duplicate STP contract still rejected.
#[test]
fn r10_regression_duplicate_stp_contract_still_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let state = register_official(&state, official);

    let contract = ServiceContract {
        official,
        identity_hash: [0xBB; 32],
        office: "Senator".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 1_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::DuplicateSTPContract)));
}

/// R9: Block header trailing garbage still rejected.
#[test]
fn r10_regression_block_header_trailing_garbage_still_rejected() {
    let genesis = Block::genesis([0xAA; 32], 1000);
    let mut bytes = genesis.header.to_bytes();
    bytes.push(0xFF);
    let result = BlockHeader::from_bytes(&bytes);
    assert!(result.is_err());
}

/// R8: Block validation against parent still works.
#[test]
fn r10_regression_block_validation_still_works() {
    let genesis = Block::genesis([0xAA; 32], 1000);
    let child = Block::try_new(&genesis.header, vec![], [0xBB; 32], 2000).unwrap();
    let result = child.validate_against_parent(&genesis.header);
    assert!(result.is_ok());
}
