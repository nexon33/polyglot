//! Round 13 Pentest Attack Tests
//!
//! Tests for vulnerabilities found in Round 13 security audit.
//! Each test verifies a specific attack vector is properly mitigated.
//!
//! Findings summary:
//! - R13-01 CRITICAL: AtomicSwapClaim creates wallet for non-existent claimer via unwrap_or(ZERO_HASH)
//! - R13-02 CRITICAL: AtomicSwapRefund creates wallet for non-existent refundee via unwrap_or(ZERO_HASH)
//! - R13-03 HIGH:     AtomicSwapInit does not validate initiator wallet exists
//! - R13-04 HIGH:     IdentityRegister has no nonce — replay possible after chain reorg
//! - R13-05 HIGH:     STP RegisterContract does not validate official's identity exists
//! - R13-06 HIGH:     STP RegisterContract does not validate official's wallet exists
//! - R13-07 HIGH:     CashTransfer amount+fee total_debit is computed but never enforced
//! - R13-08 HIGH:     BackupRestore does not check if wallet exists before restoring
//! - R13-09 HIGH:     FraudProof submitter can be same as observer (profit from own evidence)
//! - R13-10 MEDIUM:   Swap claim has no nonce validation — double-claim race in same block
//! - R13-11 MEDIUM:   Swap refund has no nonce validation
//! - R13-12 MEDIUM:   Block allows duplicate transactions (same tx included twice)
//! - R13-13 MEDIUM:   AppStateUpdate with app_id=ZERO_HASH key collision risk
//! - R13-14 MEDIUM:   CashTransfer rolling_24h_total_after can be set to u64::MAX (overflow)
//! - R13-15 MEDIUM:   AtomicSwapInit hash_lock can be any value (no domain separation check)
//! - R13-16 LOW:      State root domain collision — nonces_hash uses same DOMAIN_BLOCK as state_root
//! - R13-17 LOW:      FraudProof submitter's wallet never validated to exist
//! - R13-18 LOW:      BackupStore does not validate state_hash matches encrypted_state
//! - R13-19 LOW:      STP TriggerInvestigation submitter not validated to have identity
//! - R13-20 MEDIUM:   WalletSync allows syncing to identical state (no-op spam)
//! - R13-21 MEDIUM:   CashTransfer with fee=u64::MAX - amount causes overflow in total_debit
//! - R13-22 MEDIUM:   Multiple sequential WalletSync can set wallet to any hash
//! - R13-23 LOW:      Block validate_against_parent allows same timestamp as parent
//! - R13-24 MEDIUM:   AtomicSwapInit timeout=block_height+1 (minimum timeout, race condition)
//! - R13-25 MEDIUM:   Observation signing message doesn't include observer identity
//! - R13-26 HIGH:     Backup overwrite — repeated BackupStore replaces backup without versioning
//! - R13-27 MEDIUM:   STP contract with identity_hash=ZERO_HASH
//! - R13-28 MEDIUM:   CashTransfer jurisdiction=0 (invalid country code)
//! - R13-29 MEDIUM:   IdentityRegister jurisdiction=0 (invalid country code)
//! - R13-30 MEDIUM:   AtomicSwapInit disclosure_root collision with None
//! - R13-31 LOW:      Empty backup payload allowed (0 bytes encrypted_state)
//! - R13-32 MEDIUM:   Transaction batch ordering dependency — tx2 depends on tx1's nonce
//! - R13-33 LOW:      State snapshot clone cost — deep state trees expensive to clone
//! - R13-34 MEDIUM:   FraudProof with observations at nonce=0 (initial state)
//! - R13-35 MEDIUM:   STP contract staked_amount=1 (dust stake, no real deterrent)
//! - R13-36 MEDIUM:   STP investigation can target the same official via different pool_ids
//! - R13-37 LOW:      CashTransfer fee exactly at base_fee (boundary check)
//! - R13-38 MEDIUM:   AppStateUpdate app_id not domain-separated from wallet keys
//! - R13-39 LOW:      Swap state_hash collision between different swap parameters
//! - R13-40 MEDIUM:   IdentityRegister allows non-PublicOfficial with is_public_official=true
//! - R13-41 MEDIUM:   CashTransfer with amount=1 and fee=base_fee (dust transfer spam)

use poly_chain::prelude::*;
use poly_chain::block::Block;
use poly_chain::compliance::{check_compliance, ComplianceStatus, ReportType};
use poly_chain::fraud::{ConflictType, FraudEvidence, StateObservation};
use poly_chain::identity::Tier;
use poly_chain::stp::{
    ContractStatus, InvestigationAction, InvestigationRecord,
    ServiceContract, check_investigation_deadlines,
};
use poly_chain::state::GlobalState;
use poly_chain::transaction::{
    AppStateUpdate, AtomicSwapClaim, AtomicSwapInit, AtomicSwapRefund,
    BackupRestore, BackupStore, CashTransfer, FraudProofTx,
    IdentityRegister, STPAction, STPActionTx, SwapStatus, Transaction,
    WalletSync,
};
use poly_chain::validation::validate_transaction;
use poly_chain::wallet::WalletState;
use poly_chain::fee::FeeSchedule;
use poly_verified::types::{Hash, PrivacyMode, VerifiedProof, ZERO_HASH};
use sha2::{Digest, Sha256};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn mock_proof() -> VerifiedProof {
    VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    }
}

fn hash_with_domain(domain: u8, data: &[u8]) -> Hash {
    let mut hasher = Sha256::new();
    hasher.update([domain]);
    hasher.update(data);
    let result = hasher.finalize();
    let mut hash = [0u8; 32];
    hash.copy_from_slice(&result);
    hash
}

const DOMAIN_WALLET_STATE: u8 = 0x10;
const DOMAIN_SWAP: u8 = 0x17;

/// Set up two wallets (alice + bob) with identities registered.
fn setup_with_identities() -> (GlobalState, [u8; 32], [u8; 32]) {
    let mut state = GlobalState::genesis();
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];

    let alice_wallet = WalletState::new([0xAA; 32], Tier::Identified, 1_000_000);
    let bob_wallet = WalletState::new([0xBB; 32], Tier::Identified, 500_000);
    state.set_wallet(alice, alice_wallet.state_hash());
    state.set_wallet(bob, bob_wallet.state_hash());

    // Register Alice identity
    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx, &state, 1000, 0).unwrap();

    // Register Bob identity
    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: bob,
        tier: Tier::Identified,
        identity_hash: [0xBB; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx, &state, 1000, 0).unwrap();

    (state, alice, bob)
}

/// Create a valid atomic swap between two parties and return the updated state.
fn setup_swap(
    state: &GlobalState,
    initiator: [u8; 32],
    responder: [u8; 32],
    amount: u64,
    secret: [u8; 32],
    timeout: u64,
    now: u64,
    block_height: u64,
) -> (GlobalState, [u8; 32], [u8; 32]) {
    let hash_lock = hash_with_domain(DOMAIN_SWAP, secret.as_slice());
    let nonce = state.get_nonce(&responder);
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[initiator.as_slice(), responder.as_slice(), &nonce.to_le_bytes()].concat(),
    );

    let tx = Transaction::AtomicSwapInit(AtomicSwapInit {
        swap_id,
        initiator,
        responder,
        amount,
        hash_lock,
        timeout,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: now,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let new_state = validate_transaction(&tx, state, now, block_height).unwrap();
    (new_state, swap_id, hash_lock)
}

/// Register an STP contract for an official.
/// R13: The official must already have an identity and wallet registered.
fn register_official(state: &GlobalState, official: [u8; 32]) -> GlobalState {
    // Ensure the official has identity and wallet (required by R13 fix)
    assert!(state.get_identity(&official).is_some(), "official must have identity");
    assert!(state.get_wallet(&official).is_some(), "official must have wallet");

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    validate_transaction(&tx, state, 1000, 0).unwrap()
}

// ===========================================================================
// R13-01 CRITICAL: AtomicSwapClaim requires claimer wallet to exist
// ===========================================================================
// Previously, the claim path used `state.get_wallet(&tx.claimer).unwrap_or(ZERO_HASH)`
// which silently created a wallet for non-existent accounts.
// FIXED: Now requires claimer wallet to exist.

#[test]
fn r13_01_swap_claim_requires_claimer_wallet() {
    let (state, alice, bob) = setup_with_identities();

    // Create a valid swap between alice and bob
    let secret = [0x42; 32];
    let (state_after_swap, swap_id, hash_lock) =
        setup_swap(&state, alice, bob, 1000, secret, 1000, 1000, 100);

    // Now simulate alice's wallet being burned (e.g., fraud proof)
    let mut state_burned = state_after_swap.clone();
    state_burned.remove_wallet(&alice);
    assert!(state_burned.get_wallet(&alice).is_none());

    // Alice tries to claim — should fail because her wallet was burned
    let claim_tx = Transaction::AtomicSwapClaim(AtomicSwapClaim {
        swap_id,
        secret,
        claimer: alice,
        original_initiator: alice,
        original_responder: bob,
        original_amount: 1000,
        original_hash_lock: hash_lock,
        original_timeout: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // FIXED (R13): Claim now requires claimer wallet to exist.
    // Previously this would succeed via unwrap_or(ZERO_HASH), recreating the wallet.
    let result = validate_transaction(&claim_tx, &state_burned, 1000, 99);
    assert!(
        result.is_err(),
        "Swap claim must fail when claimer wallet does not exist (R13 fix)"
    );
}

// ===========================================================================
// R13-02 CRITICAL: AtomicSwapRefund creates wallet for non-existent refundee
// ===========================================================================

#[test]
fn r13_02_swap_refund_creates_wallet_for_deleted_refundee() {
    let (state, alice, bob) = setup_with_identities();

    // Create a swap
    let secret = [0x42; 32];
    let (state_after_swap, swap_id, hash_lock) =
        setup_swap(&state, alice, bob, 1000, secret, 200, 1000, 100);

    // Simulate bob's wallet being removed (e.g., via fraud proof)
    let mut state_burned = state_after_swap.clone();
    state_burned.remove_wallet(&bob);
    assert!(state_burned.get_wallet(&bob).is_none());

    // Bob tries to refund after timeout
    let refund_tx = Transaction::AtomicSwapRefund(AtomicSwapRefund {
        swap_id,
        refundee: bob,
        original_initiator: alice,
        original_responder: bob,
        original_amount: 1000,
        original_hash_lock: hash_lock,
        original_timeout: 200,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // FIXED (R13): Previously used unwrap_or(ZERO_HASH) which silently
    // recreated the wallet for burned bob, allowing fraud-burned accounts
    // to regain wallets through the refund path. Now requires wallet to exist.
    let result = validate_transaction(&refund_tx, &state_burned, 2000, 200);
    assert!(
        result.is_err(),
        "Swap refund must fail when refundee wallet does not exist (R13 fix)"
    );
}

// ===========================================================================
// R13-03 HIGH: AtomicSwapInit does not validate initiator wallet exists
// ===========================================================================

#[test]
fn r13_03_swap_init_allows_nonexistent_initiator() {
    let (state, _alice, bob) = setup_with_identities();

    // Ghost has no wallet at all
    let ghost = [0xDE; 32];
    assert!(state.get_wallet(&ghost).is_none());

    let secret = [0x42; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, secret.as_slice());
    let nonce = state.get_nonce(&bob);
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[ghost.as_slice(), bob.as_slice(), &nonce.to_le_bytes()].concat(),
    );

    let tx = Transaction::AtomicSwapInit(AtomicSwapInit {
        swap_id,
        initiator: ghost,
        responder: bob,
        amount: 1000,
        hash_lock,
        timeout: 1000,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // FIXED (R13): Now validates that the initiator wallet exists too.
    // Previously only the responder wallet was checked, allowing swaps where
    // the initiator (who will receive funds on claim) doesn't exist.
    let result = validate_transaction(&tx, &state, 1000, 100);
    assert!(
        result.is_err(),
        "Swap init must fail when initiator wallet does not exist (R13 fix)"
    );
}

// ===========================================================================
// R13-04 HIGH: IdentityRegister has no nonce — replay after reorg
// ===========================================================================

#[test]
fn r13_04_identity_register_has_no_nonce_field() {
    let state = GlobalState::genesis();
    let account = [0xC0; 32];

    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: account,
        tier: Tier::Identified,
        identity_hash: [0xCC; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    let new_state = validate_transaction(&tx, &state, 1000, 0).unwrap();

    // The nonce for this account was never incremented
    assert_eq!(new_state.get_nonce(&account), 0,
        "Identity register does not use nonce — replays possible after chain reorg");
}

// ===========================================================================
// R13-05 HIGH: STP RegisterContract does not validate official's identity
// ===========================================================================

#[test]
fn r13_05_stp_register_without_identity() {
    let mut state = GlobalState::genesis();
    let official = [0xD0; 32];

    // Give the official a wallet but NO identity
    let wallet = WalletState::new([0xDD; 32], Tier::PublicOfficial, 0);
    state.set_wallet(official, wallet.state_hash());

    // Official has no identity registered
    assert!(state.get_identity(&official).is_none());

    let contract = ServiceContract {
        official,
        identity_hash: [0xDD; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };

    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // FIXED (R13): Now validates that the official has a registered identity.
    // Previously, an unidentified account could register an STP contract.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "STP contract registration must fail without identity (R13 fix)"
    );
}

// ===========================================================================
// R13-06 HIGH: STP RegisterContract does not validate official's wallet
// ===========================================================================

#[test]
fn r13_06_stp_register_without_wallet() {
    let state = GlobalState::genesis();
    let official = [0xD1; 32];

    // Official has NO wallet, NO identity
    assert!(state.get_wallet(&official).is_none());

    let contract = ServiceContract {
        official,
        identity_hash: [0xDD; 32],
        office: "Governor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };

    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // FIXED (R13): Now validates that the official has both a wallet and identity.
    // Previously, an account with no wallet could register a contract claiming
    // staked_amount with nothing to back it.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "STP contract registration must fail without wallet (R13 fix)"
    );
}

// ===========================================================================
// R13-07 HIGH: CashTransfer total_debit computed but unused
// ===========================================================================

#[test]
fn r13_07_total_debit_not_enforced() {
    let (state, alice, bob) = setup_with_identities();
    let alice_state_hash = state.get_wallet(&alice).unwrap();

    // Transfer amount=u64::MAX-200 with fee=100
    // total_debit = (u64::MAX-200) + 100 = u64::MAX-100 (no overflow)
    // But the total_debit is never checked against the actual balance
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: u64::MAX - 200,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_state_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: u64::MAX - 200,
        jurisdiction: 840,
    });

    // In verify-only mode, the proof is trusted, so this succeeds.
    // The total_debit variable is computed but only checked for overflow, not against balance.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "Verify-only model trusts proof for balance validation"
    );
}

// ===========================================================================
// R13-08 HIGH: BackupRestore does not check if wallet exists
// ===========================================================================

#[test]
fn r13_08_backup_restore_without_wallet() {
    let mut state = GlobalState::genesis();
    let account = [0xE0; 32];

    // Set a backup but NO wallet
    let backup_hash = [0xEE; 32];
    state.set_backup(account, backup_hash);
    assert!(state.get_wallet(&account).is_none());
    assert!(state.get_backup(&account).is_some());

    let tx = Transaction::BackupRestore(BackupRestore {
        account_id: account,
        backup_hash,
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // FIXED (R13): Now validates that the wallet exists before restoring.
    // Previously, restore would create a wallet without going through
    // IdentityRegister, bypassing KYC requirements.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "Backup restore must fail when wallet does not exist (R13 fix)"
    );
}

// ===========================================================================
// R13-09 HIGH: FraudProof submitter can be same as observer
// ===========================================================================

#[test]
fn r13_09_fraud_submitter_is_observer() {
    let mut state = GlobalState::genesis();
    let fraudster = [0xDE; 32];
    let observer_a = [0x01; 32]; // This will also be the submitter
    let observer_b = [0x02; 32];
    state.set_wallet(fraudster, [0xAA; 32]);

    let tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: fraudster,
            observation_a: StateObservation {
                observer: observer_a,
                observed_key: fraudster,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: observer_b,
                observed_key: fraudster,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: observer_a, // submitter IS observer_a
        proof: mock_proof(),
    });

    // Currently, submitter == observer is allowed.
    // The only restriction is that the two observers must be different
    // and neither observer can be the fraudster.
    // Submitter being an observer creates a financial incentive:
    // the submitter gets the fraud_proof_reward, so they profit from
    // observations they themselves provided.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "Fraud submitter being an observer is currently allowed (minor incentive issue)"
    );
}

// ===========================================================================
// R13-10 MEDIUM: Swap claim has no nonce — no protection against double-claim in same block
// ===========================================================================

#[test]
fn r13_10_swap_claim_no_nonce_validation() {
    let (state, alice, bob) = setup_with_identities();

    let secret = [0x42; 32];
    let (state_after_swap, swap_id, hash_lock) =
        setup_swap(&state, alice, bob, 1000, secret, 500, 1000, 100);

    let claim_tx = Transaction::AtomicSwapClaim(AtomicSwapClaim {
        swap_id,
        secret,
        claimer: alice,
        original_initiator: alice,
        original_responder: bob,
        original_amount: 1000,
        original_hash_lock: hash_lock,
        original_timeout: 500,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // First claim succeeds
    let state_after_claim = validate_transaction(&claim_tx, &state_after_swap, 1000, 99).unwrap();

    // Second claim fails because swap was removed, NOT because of nonce
    let result = validate_transaction(&claim_tx, &state_after_claim, 1000, 99);
    assert!(
        result.is_err(),
        "Second claim should fail"
    );
    // The nonce for alice was NOT incremented by the claim
    // This means the claim doesn't count toward alice's nonce sequence
    assert_eq!(
        state_after_claim.get_nonce(&alice),
        state_after_swap.get_nonce(&alice),
        "Swap claim does not increment claimer nonce"
    );
}

// ===========================================================================
// R13-11 MEDIUM: Swap refund has no nonce validation
// ===========================================================================

#[test]
fn r13_11_swap_refund_no_nonce_validation() {
    let (state, alice, bob) = setup_with_identities();

    let secret = [0x42; 32];
    let (state_after_swap, swap_id, hash_lock) =
        setup_swap(&state, alice, bob, 1000, secret, 200, 1000, 100);

    let refund_tx = Transaction::AtomicSwapRefund(AtomicSwapRefund {
        swap_id,
        refundee: bob,
        original_initiator: alice,
        original_responder: bob,
        original_amount: 1000,
        original_hash_lock: hash_lock,
        original_timeout: 200,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    let state_after_refund = validate_transaction(&refund_tx, &state_after_swap, 2000, 200).unwrap();

    // Bob's nonce was NOT incremented by the refund
    assert_eq!(
        state_after_refund.get_nonce(&bob),
        state_after_swap.get_nonce(&bob) ,
        "Swap refund does not increment refundee nonce (only swap init does)"
    );
}

// ===========================================================================
// R13-12 MEDIUM: Block allows duplicate transactions
// ===========================================================================

#[test]
fn r13_12_block_allows_duplicate_transactions() {
    let (state, alice, bob) = setup_with_identities();
    let alice_state = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_state,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });

    // Create a block with the same transaction twice
    let genesis = Block::genesis(state.state_root(), 0);
    let block = Block::try_new(
        &genesis.header,
        vec![tx.clone(), tx.clone()],
        [0xFF; 32],
        1000,
    ).unwrap();

    // The block itself doesn't reject duplicate transactions
    assert_eq!(block.transactions.len(), 2);
    assert!(block.verify_transactions_root());

    // However, sequential validation will catch the nonce replay on the 2nd tx
    let state1 = validate_transaction(&block.transactions[0], &state, 1000, 1).unwrap();
    let result2 = validate_transaction(&block.transactions[1], &state1, 1000, 1);
    assert!(
        result2.is_err(),
        "Second copy of same transaction fails due to nonce mismatch"
    );
}

// ===========================================================================
// R13-13 MEDIUM: AppStateUpdate with app_id=ZERO_HASH
// ===========================================================================

#[test]
fn r13_13_app_state_update_zero_app_id() {
    let (state, alice, _bob) = setup_with_identities();

    let tx = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id: ZERO_HASH, // Zero app ID
        new_state_hash: [0xEE; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // ZERO_HASH as app_id is allowed — computes key = H(account_id || ZERO_HASH)
    // This is technically valid but could lead to confusion
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "ZERO_HASH app_id is currently allowed"
    );
}

// ===========================================================================
// R13-14 MEDIUM: CashTransfer rolling_24h_total_after overflow
// ===========================================================================

#[test]
fn r13_14_rolling_total_at_max_u64() {
    let (state, alice, bob) = setup_with_identities();
    let alice_state = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_state,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: u64::MAX, // Absurdly large rolling total
        jurisdiction: 840,
    });

    // The rolling total is self-attested by the client. The validator only checks:
    // rolling_24h_total_after >= amount (which u64::MAX >= 1000 is true)
    // No upper bound is enforced.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "u64::MAX rolling total passes validation (self-attested)"
    );
}

// ===========================================================================
// R13-15 MEDIUM: Swap hash_lock domain separation
// ===========================================================================

#[test]
fn r13_15_swap_hash_lock_domain_separation() {
    // The hash_lock is set by the initiator, and claim verifies H(DOMAIN_SWAP || secret) == hash_lock
    // But the init tx doesn't verify that hash_lock was created with domain separation.
    // An initiator could use a raw SHA-256 hash (no domain) as hash_lock,
    // making it impossible to claim with the domain-separated verification.
    let (state, alice, bob) = setup_with_identities();

    // Create hash_lock WITHOUT domain separation (raw SHA-256)
    let secret = [0x42; 32];
    let mut hasher = Sha256::new();
    hasher.update(secret);
    let raw_hash = hasher.finalize();
    let mut hash_lock_raw = [0u8; 32];
    hash_lock_raw.copy_from_slice(&raw_hash);

    // This hash_lock is NOT H(DOMAIN_SWAP || secret)
    // It's just H(secret) without domain separation
    let hash_lock_domain = hash_with_domain(DOMAIN_SWAP, secret.as_slice());
    assert_ne!(hash_lock_raw, hash_lock_domain,
        "Raw hash differs from domain-separated hash");

    // The swap init succeeds with raw hash_lock (no validation of how it was created)
    let nonce = state.get_nonce(&bob);
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), bob.as_slice(), &nonce.to_le_bytes()].concat(),
    );
    let tx = Transaction::AtomicSwapInit(AtomicSwapInit {
        swap_id,
        initiator: alice,
        responder: bob,
        amount: 1000,
        hash_lock: hash_lock_raw, // Using raw hash without domain
        timeout: 1000,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    let result = validate_transaction(&tx, &state, 1000, 100);
    assert!(result.is_ok(), "Raw hash_lock is accepted");

    // Now try to claim with the secret — claim uses domain-separated hash
    let state_after = result.unwrap();
    let claim = Transaction::AtomicSwapClaim(AtomicSwapClaim {
        swap_id,
        secret,
        claimer: alice,
        original_initiator: alice,
        original_responder: bob,
        original_amount: 1000,
        original_hash_lock: hash_lock_raw,
        original_timeout: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // Claim will fail: H(DOMAIN_SWAP || secret) != hash_lock_raw
    let claim_result = validate_transaction(&claim, &state_after, 1000, 99);
    assert!(
        claim_result.is_err(),
        "Claim fails because hash verification uses domain separation but hash_lock was raw"
    );
}

// ===========================================================================
// R13-16 LOW: State root domain collision — nonces_hash uses same DOMAIN_BLOCK
// ===========================================================================

#[test]
fn r13_16_nonces_hash_domain_collision() {
    // Both state_root() and nonces_hash() use DOMAIN_BLOCK
    // This creates a theoretical collision risk between:
    // H(DOMAIN_BLOCK || subtree_roots || nonces_data) and H(DOMAIN_BLOCK || nonces_data)
    // In practice they have different lengths so collision is unlikely,
    // but proper domain separation would use different domains.

    let mut state1 = GlobalState::genesis();
    let mut state2 = GlobalState::genesis();

    // Two states that differ only in nonces
    state1.set_nonce([1u8; 32], 42);
    state2.set_nonce([1u8; 32], 43);

    // State roots must differ
    assert_ne!(
        state1.state_root(), state2.state_root(),
        "Different nonces produce different state roots (nonces included in root)"
    );
}

// ===========================================================================
// R13-17 LOW: FraudProof submitter wallet not validated
// ===========================================================================

#[test]
fn r13_17_fraud_submitter_no_wallet() {
    let mut state = GlobalState::genesis();
    let fraudster = [0xDE; 32];
    let ghost_submitter = [0xF0; 32];
    state.set_wallet(fraudster, [0xAA; 32]);

    // Ghost submitter has no wallet
    assert!(state.get_wallet(&ghost_submitter).is_none());

    let tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: fraudster,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: fraudster,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: fraudster,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: ghost_submitter, // No wallet
        proof: mock_proof(),
    });

    // Submitter has no wallet — but fraud proofs are free and the submitter
    // field is not validated against wallets. The reward would go to a ghost.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "Fraud submitter with no wallet is currently allowed");
}

// ===========================================================================
// R13-18 LOW: BackupStore state_hash doesn't bind to encrypted_state
// ===========================================================================

#[test]
fn r13_18_backup_store_hash_mismatch() {
    let (state, alice, _bob) = setup_with_identities();

    let tx = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3, 4], // Some data
        state_hash: [0xFF; 32], // Completely unrelated hash
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // BUG: state_hash is never validated against encrypted_state.
    // The validator trusts the proof, but in mock mode there's no binding
    // between the hash and the actual data. An attacker could store
    // arbitrary data with a hash pointing to a different state.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "Backup state_hash not validated against encrypted_state");
}

// ===========================================================================
// R13-19 LOW: STP TriggerInvestigation submitter not validated
// ===========================================================================

#[test]
fn r13_19_stp_trigger_by_anyone() {
    let (state, alice, _bob) = setup_with_identities();

    // Register alice as official
    let state = register_official(&state, alice);

    // Random unregistered account triggers investigation
    let random_submitter = [0xF0; 32];
    let pool_id = [0x99; 32];

    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: alice,
            pool_id,
        },
        submitter: random_submitter,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // Anyone can trigger an investigation — no identity/wallet required for submitter
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "Anyone can trigger STP investigation (by design, but no submitter validation)"
    );
}

// ===========================================================================
// R13-20 MEDIUM: WalletSync to identical state (no-op spam)
// ===========================================================================

#[test]
fn r13_20_wallet_sync_same_state() {
    let (state, alice, _bob) = setup_with_identities();
    let current_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: current_hash, // Same as current!
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // Syncing to the exact same state wastes a nonce and consumes block space.
    // There's no check preventing no-op syncs.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "No-op wallet sync is allowed (state spam)");
}

// ===========================================================================
// R13-21 MEDIUM: CashTransfer fee + amount near overflow boundary
// ===========================================================================

#[test]
fn r13_21_cash_transfer_fee_amount_overflow() {
    let (state, alice, bob) = setup_with_identities();
    let alice_state = state.get_wallet(&alice).unwrap();

    // amount + fee would overflow u64
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: u64::MAX - 50,
        fee: 100, // (u64::MAX - 50) + 100 overflows
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_state,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: u64::MAX - 50,
        jurisdiction: 840,
    });

    // The checked_add should catch this
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "amount + fee overflow should be rejected"
    );
}

// ===========================================================================
// R13-22 MEDIUM: Sequential WalletSync can set wallet to arbitrary hash
// ===========================================================================

#[test]
fn r13_22_sequential_wallet_sync_arbitrary_state() {
    let (state, alice, _bob) = setup_with_identities();

    // First sync: set to arbitrary state A
    let tx1 = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: [0xAA; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state1 = validate_transaction(&tx1, &state, 1000, 0).unwrap();

    // Second sync: set to arbitrary state B
    let tx2 = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: [0xBB; 32],
        nonce: 1,
        timestamp: 1001,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state2 = validate_transaction(&tx2, &state1, 1001, 0).unwrap();

    // Wallet was set to whatever we wanted, twice in a row
    assert_eq!(
        state2.get_wallet(&alice),
        Some([0xBB; 32]),
        "WalletSync allows setting wallet to any hash (by design, proof-trusted)"
    );
}

// ===========================================================================
// R13-23 LOW: Block allows same timestamp as parent
// ===========================================================================

#[test]
fn r13_23_block_same_timestamp_as_parent() {
    let genesis = Block::genesis([0xAA; 32], 1000);
    // Child with exact same timestamp
    let child = Block::try_new(&genesis.header, vec![], [0xBB; 32], 1000).unwrap();

    // validate_against_parent checks timestamp >= parent.timestamp
    // So equal timestamps are allowed (non-decreasing, not strictly increasing)
    let result = child.validate_against_parent(&genesis.header);
    assert!(result.is_ok(), "Same timestamp as parent is allowed (non-decreasing)");
}

// ===========================================================================
// R13-24 MEDIUM: Swap with minimum timeout (block_height + 1)
// ===========================================================================

#[test]
fn r13_24_swap_minimum_timeout() {
    let (state, alice, bob) = setup_with_identities();

    let secret = [0x42; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, secret.as_slice());
    let nonce = state.get_nonce(&bob);
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), bob.as_slice(), &nonce.to_le_bytes()].concat(),
    );

    let block_height = 100;
    let tx = Transaction::AtomicSwapInit(AtomicSwapInit {
        swap_id,
        initiator: alice,
        responder: bob,
        amount: 1000,
        hash_lock,
        timeout: block_height + 1, // Minimum possible timeout
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // timeout=101, block_height=100 → timeout > block_height, so it's valid
    let result = validate_transaction(&tx, &state, 1000, block_height);
    assert!(result.is_ok(), "Minimum timeout of block_height+1 is valid");

    // But the claim window is exactly 1 block — very tight race condition
    let state_after = result.unwrap();

    // At block 100 we can still claim (100 < 101)
    let claim = Transaction::AtomicSwapClaim(AtomicSwapClaim {
        swap_id,
        secret,
        claimer: alice,
        original_initiator: alice,
        original_responder: bob,
        original_amount: 1000,
        original_hash_lock: hash_lock,
        original_timeout: block_height + 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let claim_result = validate_transaction(&claim, &state_after, 1000, block_height);
    assert!(claim_result.is_ok(), "Claim at exactly block_height succeeds");

    // At block 101 the claim would expire
    let claim_expired = validate_transaction(&claim, &state_after, 1000, block_height + 1);
    assert!(claim_expired.is_err(), "Claim at timeout block fails (expired)");
}

// ===========================================================================
// R13-25 MEDIUM: Observation signing message doesn't include observer
// ===========================================================================

#[test]
fn r13_25_observation_sign_message_no_observer() {
    let obs = StateObservation {
        observer: [0x01; 32],
        observed_key: [0xDE; 32],
        observed_state_hash: [0xAA; 32],
        observed_nonce: 5,
        observer_signature: [0u8; 64],
    };

    let msg = obs.sign_message();
    // The sign_message is: observed_key || state_hash || nonce_LE
    // It does NOT include the observer's identity!
    // This means observer A's signature could be replayed as observer B's
    // (if they have the same key, which they won't in practice with Ed25519)
    assert_eq!(msg.len(), 32 + 32 + 8, "Sign message is 72 bytes (no observer field)");

    // Two different observers would produce the same signing message for the same observation
    let obs2 = StateObservation {
        observer: [0x02; 32], // Different observer
        observed_key: [0xDE; 32],
        observed_state_hash: [0xAA; 32],
        observed_nonce: 5,
        observer_signature: [0u8; 64],
    };
    assert_eq!(obs.sign_message(), obs2.sign_message(),
        "Different observers produce same signing message (observer not in signed data)");
}

// ===========================================================================
// R13-26 HIGH: Backup overwrite without versioning
// ===========================================================================

#[test]
fn r13_26_backup_overwrite() {
    let (state, alice, _bob) = setup_with_identities();

    // Store first backup
    let tx1 = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3],
        state_hash: [0xAA; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state1 = validate_transaction(&tx1, &state, 1000, 0).unwrap();
    assert_eq!(state1.get_backup(&alice), Some([0xAA; 32]));

    // Store second backup — overwrites without any record of first
    let tx2 = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![4, 5, 6],
        state_hash: [0xBB; 32],
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state2 = validate_transaction(&tx2, &state1, 1000, 0).unwrap();
    assert_eq!(
        state2.get_backup(&alice), Some([0xBB; 32]),
        "First backup was silently overwritten"
    );
}

// ===========================================================================
// R13-27 MEDIUM: STP contract with identity_hash=ZERO_HASH
// ===========================================================================

#[test]
fn r13_27_stp_contract_zero_identity_hash() {
    let state = GlobalState::genesis();
    let official = [0xD0; 32];

    let contract = ServiceContract {
        official,
        identity_hash: ZERO_HASH, // Zero identity hash!
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };

    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // FIXED (R13): STP contract now rejects ZERO_HASH identity_hash,
    // and also requires the official to have an identity and wallet.
    // This test will fail on the identity check first.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "STP contract with ZERO_HASH identity_hash must be rejected (R13 fix)"
    );
}

// ===========================================================================
// R13-28 MEDIUM: CashTransfer with jurisdiction=0
// ===========================================================================

#[test]
fn r13_28_cash_transfer_zero_jurisdiction() {
    let (state, alice, bob) = setup_with_identities();
    let alice_state = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_state,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 0, // Invalid country code
    });

    // jurisdiction=0 is not a valid ISO 3166-1 numeric code
    // but the validator doesn't check jurisdiction validity
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "jurisdiction=0 is accepted (no validation)");
}

// ===========================================================================
// R13-29 MEDIUM: IdentityRegister with jurisdiction=0
// ===========================================================================

#[test]
fn r13_29_identity_register_zero_jurisdiction() {
    let state = GlobalState::genesis();
    let account = [0xF1; 32];

    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: account,
        tier: Tier::Identified,
        identity_hash: [0xFF; 32],
        jurisdiction: 0, // Invalid
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "jurisdiction=0 accepted in identity register");
}

// ===========================================================================
// R13-30 MEDIUM: AtomicSwapInit disclosure_root None vs Some(ZERO_HASH)
// ===========================================================================

#[test]
fn r13_30_swap_disclosure_root_ambiguity() {
    let (state, alice, bob) = setup_with_identities();

    let secret = [0x42; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, secret.as_slice());

    // Swap with disclosure_root = None
    let nonce = state.get_nonce(&bob);
    let swap_id_1 = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), bob.as_slice(), &nonce.to_le_bytes()].concat(),
    );
    let tx1 = Transaction::AtomicSwapInit(AtomicSwapInit {
        swap_id: swap_id_1,
        initiator: alice,
        responder: bob,
        amount: 1000,
        hash_lock,
        timeout: 1000,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    let state1 = validate_transaction(&tx1, &state, 1000, 100).unwrap();

    // Swap with disclosure_root = Some(ZERO_HASH)
    let nonce2 = state1.get_nonce(&bob);
    let swap_id_2 = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), bob.as_slice(), &nonce2.to_le_bytes()].concat(),
    );
    let tx2 = Transaction::AtomicSwapInit(AtomicSwapInit {
        swap_id: swap_id_2,
        initiator: alice,
        responder: bob,
        amount: 1000,
        hash_lock,
        timeout: 1000,
        disclosure_root: Some(ZERO_HASH), // Zero instead of None
        execution_proof: None,
        nonce: nonce2,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    let result = validate_transaction(&tx2, &state1, 1000, 100);
    assert!(result.is_ok(), "disclosure_root=Some(ZERO_HASH) is accepted");

    // The signing messages differ (None uses 0x00, Some uses 0x01 + hash)
    // so at least there's no signing collision
}

// ===========================================================================
// R13-31 LOW: Empty backup payload
// ===========================================================================

#[test]
fn r13_31_empty_backup_payload() {
    let (state, alice, _bob) = setup_with_identities();

    let tx = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![], // Empty!
        state_hash: [0xAA; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // FIXED (R13): Empty encrypted_state is now rejected.
    // Previously, 0-byte backups passed the size check but stored nothing useful.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_err(), "Empty backup payload must be rejected (R13 fix)");
}

// ===========================================================================
// R13-32 MEDIUM: Transaction batch ordering dependency
// ===========================================================================

#[test]
fn r13_32_transaction_ordering_dependency() {
    let (state, alice, bob) = setup_with_identities();
    let alice_state = state.get_wallet(&alice).unwrap();

    // tx1: CashTransfer with nonce=0
    let tx1 = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_state,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });

    // tx2: WalletSync with nonce=1 (depends on tx1 executing first)
    let tx2 = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: [0xCC; 32],
        nonce: 1, // Must come after tx1
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // Correct order: tx1 then tx2
    let state_after_tx1 = validate_transaction(&tx1, &state, 1000, 0).unwrap();
    let state_after_tx2 = validate_transaction(&tx2, &state_after_tx1, 1000, 0).unwrap();
    assert!(state_after_tx2.get_wallet(&alice).is_some());

    // Wrong order: tx2 then tx1 — tx2 fails because nonce=1 but expected=0
    let result = validate_transaction(&tx2, &state, 1000, 0);
    assert!(
        result.is_err(),
        "tx2 with nonce=1 fails when applied before tx1"
    );
}

// ===========================================================================
// R13-33 LOW: State snapshot clone cost
// ===========================================================================

#[test]
fn r13_33_state_clone_cost() {
    let mut state = GlobalState::genesis();

    // Add many entries to make cloning expensive
    for i in 0u32..100 {
        let mut key = [0u8; 32];
        key[0..4].copy_from_slice(&i.to_le_bytes());
        let wallet = WalletState::new(key, Tier::Anonymous, 0);
        state.set_wallet(key, wallet.state_hash());
    }

    // Every validate_transaction clones the entire state
    // With 100 wallets, this is 100 SMT entries cloned per tx
    let state_root = state.state_root();
    assert_ne!(state_root, ZERO_HASH, "Large state has non-zero root");

    // Verify clone produces identical state
    let cloned = state.clone();
    assert_eq!(cloned.state_root(), state_root, "Clone preserves state root");
}

// ===========================================================================
// R13-34 MEDIUM: FraudProof with observations at nonce=0
// ===========================================================================

#[test]
fn r13_34_fraud_at_nonce_zero() {
    let mut state = GlobalState::genesis();
    let fraudster = [0xDE; 32];
    state.set_wallet(fraudster, [0xAA; 32]);

    // Two observations at nonce=0 with different state hashes
    // This means the fraud was detected at the very first transaction
    let tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: fraudster,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: fraudster,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 0, // Initial nonce
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: fraudster,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 0, // Same initial nonce, different state
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x03; 32],
        proof: mock_proof(),
    });

    // Fraud at nonce=0 is valid — it means they presented different
    // initial states to different observers
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "Fraud proof at nonce=0 is valid");
}

// ===========================================================================
// R13-35 MEDIUM: STP contract with dust stake
// ===========================================================================

#[test]
fn r13_35_stp_dust_stake() {
    // R13: Now requires identity and wallet. Set up a proper official.
    let (state, alice, _bob) = setup_with_identities();

    let contract = ServiceContract {
        official: alice,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 1, // Minimum: 1 unit (0.0001 MANA)
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };

    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: alice,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // staked_amount=1 is non-zero, so it passes validation
    // But 0.0001 MANA is not a meaningful deterrent
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "Dust stake (1 unit) is accepted");
}

// ===========================================================================
// R13-36 MEDIUM: Multiple investigations on same official
// ===========================================================================

#[test]
fn r13_36_multiple_investigations_different_pool_ids() {
    let (state, alice, _bob) = setup_with_identities();
    let state = register_official(&state, alice);

    // Trigger first investigation
    let pool_1 = [0x01; 32];
    let tx1 = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: alice,
            pool_id: pool_1,
        },
        submitter: [0xF0; 32],
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state1 = validate_transaction(&tx1, &state, 1000, 0).unwrap();

    // Trigger second investigation with different pool_id
    let pool_2 = [0x02; 32];
    let tx2 = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: alice,
            pool_id: pool_2,
        },
        submitter: [0xF1; 32],
        timestamp: 1001,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx2, &state1, 1001, 0);

    // Multiple investigations on the same official are allowed if different pool_ids
    // This could be used to overwhelm an official with investigations
    assert!(result.is_ok(), "Multiple investigations with different pool_ids are allowed");
}

// ===========================================================================
// R13-37 LOW: CashTransfer fee exactly at base_fee boundary
// ===========================================================================

#[test]
fn r13_37_fee_at_exact_minimum() {
    let (state, alice, bob) = setup_with_identities();
    let alice_state = state.get_wallet(&alice).unwrap();

    // Fee exactly at base_fee
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: FeeSchedule::base_fee(), // Exactly minimum
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_state,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });

    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(result.is_ok(), "Fee at exact minimum is accepted");

    // Fee one below minimum
    let tx_low = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: FeeSchedule::base_fee() - 1,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_state,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });

    let result_low = validate_transaction(&tx_low, &state, 1000, 0);
    assert!(result_low.is_err(), "Fee below minimum is rejected");
}

// ===========================================================================
// R13-38 MEDIUM: AppStateUpdate app_id domain separation
// ===========================================================================

#[test]
fn r13_38_app_state_key_domain_separation() {
    let (state, alice, bob) = setup_with_identities();

    // Alice updates app with app_id X
    let app_id = [0x42; 32];
    let tx1 = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: [0xAA; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state1 = validate_transaction(&tx1, &state, 1000, 0).unwrap();

    // Bob updates same app_id X
    let tx2 = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: bob,
        app_id,
        new_state_hash: [0xBB; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state2 = validate_transaction(&tx2, &state1, 1000, 0).unwrap();

    // After R12 fix, keys are scoped: H(alice || app_id) != H(bob || app_id)
    // Alice's state should NOT be overwritten by Bob's
    let alice_key = hash_with_domain(
        DOMAIN_WALLET_STATE,
        &[alice.as_slice(), &app_id].concat(),
    );
    let bob_key = hash_with_domain(
        DOMAIN_WALLET_STATE,
        &[bob.as_slice(), &app_id].concat(),
    );

    assert_ne!(alice_key, bob_key, "Account-scoped keys are different");
    assert_eq!(
        state2.get_app_state(&alice_key), Some([0xAA; 32]),
        "Alice's app state preserved after Bob's update (R12 fix verified)"
    );
    assert_eq!(
        state2.get_app_state(&bob_key), Some([0xBB; 32]),
        "Bob's app state is independent"
    );
}

// ===========================================================================
// R13-39 LOW: Swap state_hash collision potential
// ===========================================================================

#[test]
fn r13_39_swap_state_hash_uniqueness() {
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];
    let hash_lock = [0x42; 32];

    // Two swaps with different amounts but otherwise same params
    let hash1 = poly_chain::transaction::swap_state_hash_from_parts(
        &alice, &bob, 1000, &hash_lock, 500, SwapStatus::Active,
    );
    let hash2 = poly_chain::transaction::swap_state_hash_from_parts(
        &alice, &bob, 1001, &hash_lock, 500, SwapStatus::Active,
    );
    assert_ne!(hash1, hash2, "Different amounts produce different hashes");

    // Same swap, different status
    let hash_active = poly_chain::transaction::swap_state_hash_from_parts(
        &alice, &bob, 1000, &hash_lock, 500, SwapStatus::Active,
    );
    let hash_claimed = poly_chain::transaction::swap_state_hash_from_parts(
        &alice, &bob, 1000, &hash_lock, 500, SwapStatus::Claimed,
    );
    assert_ne!(hash_active, hash_claimed, "Different statuses produce different hashes");
}

// ===========================================================================
// R13-40 MEDIUM: IdentityRegister non-PublicOfficial with is_public_official=true
// ===========================================================================

#[test]
fn r13_40_non_official_with_official_flag() {
    let state = GlobalState::genesis();
    let account = [0xF2; 32];

    // Register as Identified but with is_public_official=true
    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: account,
        tier: Tier::Identified, // NOT PublicOfficial
        identity_hash: [0xFF; 32],
        jurisdiction: 840,
        is_public_official: true, // But flag is set!
        office: Some("Ghost Office".into()),
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // FIXED (R13): Now checks both directions — PublicOfficial requires the flag,
    // AND the flag requires PublicOfficial tier. Without this, an Identified account
    // could claim official status without the corresponding tier restrictions.
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "Non-PublicOfficial with is_public_official=true must be rejected (R13 fix)"
    );
}

// ===========================================================================
// R13-41 MEDIUM: CashTransfer dust transfer spam
// ===========================================================================

#[test]
fn r13_41_dust_transfer_spam() {
    let (state, alice, bob) = setup_with_identities();
    let mut current_state = state.clone();

    // Send many 1-unit transfers to spam the chain
    for i in 0u64..5 {
        let alice_state = current_state.get_wallet(&alice).unwrap();
        let tx = Transaction::CashTransfer(CashTransfer {
            from: alice,
            to: bob,
            amount: 1, // Minimum dust
            fee: FeeSchedule::base_fee(),
            nonce: i,
            timestamp: 1000 + i,
            state_pre: alice_state,
            proof: mock_proof(),
            signature: [0u8; 64],
            sender_tier: Tier::Identified,
            sender_identity_hash: [0xAA; 32],
            recipient_identity_hash: [0xBB; 32],
            sender_frozen: false,
            recipient_frozen: false,
            rolling_24h_total_after: 1 + i,
            jurisdiction: 840,
        });

        let result = validate_transaction(&tx, &current_state, 1000 + i, 0);
        assert!(result.is_ok(), "Dust transfer #{i} succeeds");
        current_state = result.unwrap();
    }
    // All 5 dust transfers succeed — no minimum transfer amount
}

// ===========================================================================
// Additional edge case tests
// ===========================================================================

#[test]
fn r13_42_swap_claim_after_refund_impossible() {
    let (state, alice, bob) = setup_with_identities();

    let secret = [0x42; 32];
    let (state_after_swap, swap_id, hash_lock) =
        setup_swap(&state, alice, bob, 1000, secret, 200, 1000, 100);

    // Refund first (after timeout)
    let refund_tx = Transaction::AtomicSwapRefund(AtomicSwapRefund {
        swap_id,
        refundee: bob,
        original_initiator: alice,
        original_responder: bob,
        original_amount: 1000,
        original_hash_lock: hash_lock,
        original_timeout: 200,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state_refunded = validate_transaction(&refund_tx, &state_after_swap, 2000, 200).unwrap();

    // Try to claim after refund — should fail
    let claim_tx = Transaction::AtomicSwapClaim(AtomicSwapClaim {
        swap_id,
        secret,
        claimer: alice,
        original_initiator: alice,
        original_responder: bob,
        original_amount: 1000,
        original_hash_lock: hash_lock,
        original_timeout: 200,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&claim_tx, &state_refunded, 1000, 150);
    assert!(result.is_err(), "Cannot claim after refund (swap removed)");
}

#[test]
fn r13_43_timestamp_boundary_exactly_at_drift() {
    let (state, alice, bob) = setup_with_identities();
    let alice_state = state.get_wallet(&alice).unwrap();
    let now = 10_000u64;
    let max_drift = 300u64; // MAX_TIMESTAMP_DRIFT

    // Timestamp exactly at now + max_drift — should pass
    let tx_future = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: now + max_drift,
        state_pre: alice_state,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result_future = validate_transaction(&tx_future, &state, now, 0);
    assert!(result_future.is_ok(), "Timestamp at exactly now+drift is valid");

    // Timestamp at now + max_drift + 1 — should fail
    let tx_too_future = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: now + max_drift + 1,
        state_pre: alice_state,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result_too_future = validate_transaction(&tx_too_future, &state, now, 0);
    assert!(result_too_future.is_err(), "Timestamp beyond drift is rejected");
}

#[test]
fn r13_44_nonce_overflow_at_max() {
    let mut state = GlobalState::genesis();
    let account = [0xA1; 32];
    let wallet = WalletState::new([0xAA; 32], Tier::Identified, 0);
    state.set_wallet(account, wallet.state_hash());

    // Set nonce to u64::MAX
    state.set_nonce(account, u64::MAX);

    // Try to do a wallet sync — should fail because nonce+1 would overflow
    let tx = Transaction::WalletSync(WalletSync {
        account_id: account,
        new_state_hash: [0xBB; 32],
        nonce: u64::MAX,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::NonceOverflow)),
        "Nonce overflow at u64::MAX is properly rejected"
    );
}

#[test]
fn r13_45_stp_provide_data_for_wrong_investigation() {
    let (state, alice, _bob) = setup_with_identities();
    let state = register_official(&state, alice);

    // Trigger investigation
    let pool_id = [0x99; 32];
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: alice,
            pool_id,
        },
        submitter: [0xF0; 32],
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state1 = validate_transaction(&tx, &state, 1000, 0).unwrap();

    // Try to provide data for a DIFFERENT investigation_id
    let wrong_id = [0x88; 32];
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: wrong_id,
            data_hash: [0xDD; 32],
        },
        submitter: alice,
        timestamp: 1001,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    let result = validate_transaction(&provide_tx, &state1, 1001, 0);
    assert!(result.is_err(), "ProvideData for wrong investigation_id is rejected");
}

#[test]
fn r13_46_state_root_deterministic_after_operations() {
    let (state, alice, bob) = setup_with_identities();
    let alice_state = state.get_wallet(&alice).unwrap();

    // Apply same transaction to same state — should get identical result
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_state,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });

    let state_a = validate_transaction(&tx, &state, 1000, 0).unwrap();
    let state_b = validate_transaction(&tx, &state, 1000, 0).unwrap();

    assert_eq!(
        state_a.state_root(), state_b.state_root(),
        "Same transaction on same state produces deterministic result"
    );
}

#[test]
fn r13_47_investigation_record_deadlines_saturating() {
    // Test that investigation deadlines don't overflow at u64::MAX
    let inv = InvestigationRecord::new([0xAA; 32], [0xBB; 32], u64::MAX);

    assert_eq!(inv.compliance_deadline, u64::MAX, "Saturating add at MAX");
    assert_eq!(inv.final_deadline, u64::MAX, "Final deadline saturates too");

    // Check that deadline checks work at MAX
    let action = check_investigation_deadlines(&inv, u64::MAX);
    assert_eq!(action, InvestigationAction::FreezeAccount,
        "At MAX timestamp, compliance deadline is reached");
}

#[test]
fn r13_48_cash_transfer_self_transfer_rejected() {
    let (state, alice, _bob) = setup_with_identities();
    let alice_state = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: alice, // Self!
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_state,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xAA; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });

    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::SelfTransfer)),
        "Self-transfer is properly rejected");
}

#[test]
fn r13_49_swap_self_swap_rejected() {
    let (state, alice, _bob) = setup_with_identities();

    let secret = [0x42; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, secret.as_slice());
    let nonce = state.get_nonce(&alice);
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), alice.as_slice(), &nonce.to_le_bytes()].concat(),
    );

    let tx = Transaction::AtomicSwapInit(AtomicSwapInit {
        swap_id,
        initiator: alice,
        responder: alice, // Self!
        amount: 1000,
        hash_lock,
        timeout: 1000,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    let result = validate_transaction(&tx, &state, 1000, 100);
    assert!(matches!(result, Err(ChainError::SelfTransfer)),
        "Self-swap is properly rejected");
}

#[test]
fn r13_50_compliance_report_single_vs_rolling() {
    // Verify that single-transfer threshold and rolling-total threshold
    // generate different report types
    let threshold = Tier::Identified.reporting_threshold();

    // Single transfer at threshold — triggers Single report
    let status1 = check_compliance(
        threshold, threshold, Tier::Identified, 840, 1000,
        [1u8; 32], [2u8; 32], [0xAA; 32], 0,
    );
    match status1 {
        ComplianceStatus::ReportGenerated(report) => {
            assert_eq!(report.report_type, ReportType::Single);
        }
        _ => panic!("Expected Single report"),
    }

    // Small transfer but rolling total at threshold — triggers RollingTotal report
    let status2 = check_compliance(
        100, threshold, Tier::Identified, 840, 1000,
        [1u8; 32], [2u8; 32], [0xAA; 32], 1,
    );
    match status2 {
        ComplianceStatus::ReportGenerated(report) => {
            assert_eq!(report.report_type, ReportType::RollingTotal);
        }
        _ => panic!("Expected RollingTotal report"),
    }
}
