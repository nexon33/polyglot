//! Round 7 Pentest Attack Tests
//!
//! Tests for vulnerabilities found in Round 7 security audit.
//! Each test verifies a specific attack vector is properly mitigated.
//!
//! Findings summary:
//! - R7-01 CRITICAL: Compliance tier downgrade — sender self-attests higher tier to evade reporting
//! - R7-02 CRITICAL: STP cross-official data injection — Official B provides data for Official A
//! - R7-03 HIGH:     Fraud proof against non-existent account pollutes evidence tree
//! - R7-04 HIGH:     Duplicate fraud evidence can be submitted repeatedly
//! - R7-05 HIGH:     STP contract overwrite — official replaces restrictive contract with permissive one
//! - R7-06 MEDIUM:   Rolling 24h total is self-attested (compliance evasion by under-reporting)
//! - R7-07 MEDIUM:   STP actions don't consume nonces (replay risk)
//! - R7-08 MEDIUM:   Swap claim/refund don't consume nonces
//! - R7-09 LOW:      STP CheckDeadline is a no-op (enforcement not implemented)

use poly_chain::prelude::*;
use poly_chain::fraud::{ConflictType, FraudEvidence, StateObservation};
use poly_chain::identity::Tier;
use poly_chain::stp::{ContractStatus, ServiceContract};
use poly_chain::state::GlobalState;
use poly_chain::transaction::{
    AtomicSwapInit, AtomicSwapClaim, AtomicSwapRefund,
    CashTransfer, FraudProofTx, IdentityRegister,
    STPAction, STPActionTx, WalletSync,
};
use poly_chain::validation::validate_transaction;
use poly_chain::wallet::WalletState;
use poly_verified::types::{PrivacyMode, VerifiedProof, ZERO_HASH};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn mock_proof() -> VerifiedProof {
    VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    }
}

fn setup_wallets() -> (GlobalState, AccountId, AccountId) {
    let mut state = GlobalState::genesis();
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];

    let alice_wallet = WalletState::new([0xAA; 32], Tier::Identified, 1_000_000);
    let bob_wallet = WalletState::new([0xBB; 32], Tier::Identified, 500_000);

    state.set_wallet(alice, alice_wallet.state_hash());
    state.set_wallet(bob, bob_wallet.state_hash());

    (state, alice, bob)
}

/// Setup wallets and register identities for both accounts.
fn setup_wallets_with_identities() -> (GlobalState, AccountId, AccountId) {
    let (state, alice, bob) = setup_wallets();

    // Register alice's identity as Identified
    let tx_alice_id = Transaction::IdentityRegister(IdentityRegister {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_alice_id, &state, 1000, 0).unwrap();

    // Register bob's identity as Identified
    let tx_bob_id = Transaction::IdentityRegister(IdentityRegister {
        account_id: bob,
        tier: Tier::Identified,
        identity_hash: [0xBB; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_bob_id, &state, 1000, 0).unwrap();

    (state, alice, bob)
}

fn make_swap(
    initiator: AccountId,
    responder: AccountId,
    amount: Amount,
    timeout: BlockHeight,
    nonce: Nonce,
) -> AtomicSwapInit {
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[
            initiator.as_slice(),
            responder.as_slice(),
            &nonce.to_le_bytes(),
        ]
        .concat(),
    );
    let secret = [0x5E; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, &secret);

    AtomicSwapInit {
        swap_id,
        initiator,
        responder,
        amount,
        hash_lock,
        timeout,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn make_claim(swap: &AtomicSwapInit) -> AtomicSwapClaim {
    AtomicSwapClaim {
        swap_id: swap.swap_id,
        secret: [0x5E; 32],
        claimer: swap.initiator,
        original_initiator: swap.initiator,
        original_responder: swap.responder,
        original_amount: swap.amount,
        original_hash_lock: swap.hash_lock,
        original_timeout: swap.timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn make_refund(swap: &AtomicSwapInit) -> AtomicSwapRefund {
    AtomicSwapRefund {
        swap_id: swap.swap_id,
        refundee: swap.responder,
        original_initiator: swap.initiator,
        original_responder: swap.responder,
        original_amount: swap.amount,
        original_hash_lock: swap.hash_lock,
        original_timeout: swap.timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn register_official(state: &GlobalState, official: AccountId) -> GlobalState {
    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    validate_transaction(&tx, state, 1000, 0).unwrap()
}

// ===========================================================================
// R7-01 CRITICAL: Compliance Tier Downgrade Attack
// ===========================================================================

/// ATTACK: Sender has no registered identity but claims Tier::Identified in the
/// CashTransfer. This gives them a much higher reporting threshold (10,000 MANA
/// vs 100 MANA for Anonymous), allowing large transfers to evade compliance.
///
/// FIX: Validator now cross-references sender_tier with on-chain identity registry.
/// If no identity is registered, the sender MUST be Tier::Anonymous.
#[test]
fn r7_01_compliance_tier_downgrade_no_identity_rejects_non_anonymous() {
    let (state, sender, recipient) = setup_wallets();
    // Note: NO identity registered for sender.
    let sender_hash = state.get_wallet(&sender).unwrap();

    // Attacker claims Tier::Identified (threshold 10,000 MANA) despite having no identity
    let tx = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 5_000_000, // 500 MANA — above Anonymous threshold (100 MANA) but below Identified
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified, // LIE: not registered!
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 5_000_000,
        jurisdiction: 840,
    });

    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::TierViolation(_))),
        "R7-01 FAILED: unregistered sender accepted Tier::Identified, got {:?}",
        result
    );
}

/// ATTACK: Same attack but claiming Pseudonymous tier.
#[test]
fn r7_01_compliance_tier_downgrade_no_identity_rejects_pseudonymous() {
    let (state, sender, recipient) = setup_wallets();
    let sender_hash = state.get_wallet(&sender).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 100_000, // small
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Pseudonymous, // LIE: not registered!
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100_000,
        jurisdiction: 840,
    });

    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::TierViolation(_))),
        "R7-01 FAILED: unregistered sender accepted Pseudonymous, got {:?}",
        result
    );
}

/// ATTACK: Claiming PublicOfficial tier without identity.
#[test]
fn r7_01_compliance_tier_downgrade_no_identity_rejects_public_official() {
    let (state, sender, recipient) = setup_wallets();
    let sender_hash = state.get_wallet(&sender).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 100_000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::PublicOfficial, // LIE!
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100_000,
        jurisdiction: 840,
    });

    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::TierViolation(_))),
        "R7-01 FAILED: unregistered sender accepted PublicOfficial, got {:?}",
        result
    );
}

/// VALID: Sender with no identity claiming Anonymous tier (correct) should work.
#[test]
fn r7_01_compliance_tier_anonymous_with_no_identity_accepted() {
    let (state, sender, recipient) = setup_wallets();
    let sender_hash = state.get_wallet(&sender).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Anonymous, // correct — no identity registered
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });

    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R7-01: Anonymous tier with no identity should be accepted, got {:?}",
        result
    );
}

/// VALID: Sender with registered identity claiming their registered tier should work.
#[test]
fn r7_01_compliance_tier_with_registered_identity_accepted() {
    let (state, alice, bob) = setup_wallets_with_identities();
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified, // correct — matches registration
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });

    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R7-01: registered Identified tier should be accepted, got {:?}",
        result
    );
}

// ===========================================================================
// R7-02 CRITICAL: STP Cross-Official Data Injection
// ===========================================================================

/// ATTACK: Official B provides data for Official A's investigation.
/// This allows Official A to escape accountability — they never cooperate,
/// but Official B's data makes it look like someone cooperated.
///
/// FIX: TriggerInvestigation now stores a target binding. ProvideData verifies
/// the submitter matches the stored target, not just that they have any contract.
#[test]
fn r7_02_stp_cross_official_data_injection_rejected() {
    let state = GlobalState::genesis();
    let official_a = [0x10; 32];
    let official_b = [0x20; 32];
    let anyone = [0x30; 32];

    // Register both officials
    let state = register_official(&state, official_a);
    let state = register_official(&state, official_b);

    // Trigger investigation against Official A
    let pool_id = [0x99; 32];
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official_a,
            pool_id,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 1000, 0).unwrap();

    // Official B tries to provide data for Official A's investigation
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: [0xDD; 32],
        },
        submitter: official_b, // B is NOT the target!
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide_tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::UnauthorizedSTPAction(_))),
        "R7-02 FAILED: Official B accepted as provider for Official A's investigation, got {:?}",
        result
    );
}

/// VALID: The actual target (Official A) can still provide their own data.
#[test]
fn r7_02_stp_target_official_can_provide_own_data() {
    let state = GlobalState::genesis();
    let official_a = [0x10; 32];
    let anyone = [0x30; 32];

    // Register official_a
    let state = register_official(&state, official_a);

    // Trigger investigation against official_a
    let pool_id = [0x99; 32];
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official_a,
            pool_id,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 1000, 0).unwrap();

    // Official A provides their own data — should succeed
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: [0xDD; 32],
        },
        submitter: official_a, // A IS the target
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide_tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R7-02: target official should be able to provide their own data, got {:?}",
        result
    );
}

/// ATTACK: Non-official tries to provide data (still rejected by R6 + R7).
#[test]
fn r7_02_stp_non_official_provide_data_still_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let eve = [0xEE; 32];

    let state = register_official(&state, official);

    let pool_id = [0x99; 32];
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: eve,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 1000, 0).unwrap();

    // Eve (no contract) tries to provide data
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: [0xDD; 32],
        },
        submitter: eve,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide_tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R7-02: non-official should still be rejected from providing data"
    );
}

// ===========================================================================
// R7-03 HIGH: Fraud Proof Against Non-Existent Account
// ===========================================================================

/// ATTACK: Submit fraud evidence against an account that has no wallet.
/// The wallet removal is a no-op, but the evidence tree gets polluted.
/// This is a griefing attack — anyone can submit fabricated evidence against
/// non-existent accounts to fill the fraud evidence tree.
#[test]
fn r7_03_fraud_proof_against_nonexistent_wallet_still_records_evidence() {
    let state = GlobalState::genesis();
    let nonexistent = [0xDE; 32];
    // nonexistent has NO wallet

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: nonexistent,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: nonexistent,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: nonexistent,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x03; 32],
        proof: mock_proof(),
    });

    // R10 FIX: Fraud proof against nonexistent wallet is now rejected.
    // Previously this was documented as accepted behavior, but R10 requires
    // the fraudulent account to have an existing wallet to prevent evidence
    // tree pollution with phantom account entries.
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::AccountNotFound(_))),
        "R10 FIX: fraud proof against nonexistent account now rejected, got {:?}",
        result
    );
}

// ===========================================================================
// R7-04 HIGH: Duplicate Fraud Evidence
// ===========================================================================

/// ATTACK: Submit the exact same fraud evidence twice. Previously this would
/// succeed both times, polluting the evidence tree with duplicate entries.
///
/// FIX: Validator now checks for existing evidence hash before recording.
#[test]
fn r7_04_duplicate_fraud_evidence_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xDE; 32];
    state.set_wallet(victim, [0xAA; 32]);

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: victim,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: victim,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x03; 32],
        proof: mock_proof(),
    });

    // First submission succeeds
    let new_state = validate_transaction(&fraud_tx, &state, 1000, 0).unwrap();
    assert!(new_state.get_wallet(&victim).is_none(), "wallet should be burned");

    // Second submission of same evidence should fail.
    // R10: Now fails with AccountNotFound first (wallet already burned),
    // but DuplicateFraudEvidence would also fire if wallet existed.
    let result = validate_transaction(&fraud_tx, &new_state, 1000, 0);
    assert!(
        result.is_err(),
        "R7-04 FAILED: duplicate fraud evidence accepted, got {:?}",
        result
    );
}

/// Different evidence against the same account is still valid (not duplicate).
#[test]
fn r7_04_different_evidence_same_account_accepted() {
    let mut state = GlobalState::genesis();
    let victim = [0xDE; 32];
    state.set_wallet(victim, [0xAA; 32]);

    // First fraud proof
    let fraud_tx1 = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: victim,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: victim,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x03; 32],
        proof: mock_proof(),
    });
    let state = validate_transaction(&fraud_tx1, &state, 1000, 0).unwrap();

    // Second fraud proof with DIFFERENT observations (different nonce)
    let fraud_tx2 = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: victim,
                observed_state_hash: [0xCC; 32],
                observed_nonce: 10, // different nonce
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: victim,
                observed_state_hash: [0xDD; 32],
                observed_nonce: 10,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x03; 32],
        proof: mock_proof(),
    });
    // R10: After the first fraud proof burns the wallet, additional fraud proofs
    // against the same account are rejected with AccountNotFound.
    // This is correct behavior — the wallet is already burned, there's nothing
    // left to slash. The evidence is still recorded from the first proof.
    let result = validate_transaction(&fraud_tx2, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::AccountNotFound(_))),
        "R10: different evidence against burned wallet should be rejected, got {:?}",
        result
    );
}

// ===========================================================================
// R7-05 HIGH: STP Contract Overwrite
// ===========================================================================

/// ATTACK: An official already under investigation re-registers with a more
/// permissive contract (higher threshold, lower stake) to reduce accountability.
///
/// FIX: Validator now rejects RegisterContract if the official already has a contract.
#[test]
fn r7_05_stp_contract_overwrite_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    // Register initial restrictive contract
    let state = register_official(&state, official);
    assert!(state.get_stp_record(&official).is_some());

    // Attacker tries to overwrite with a more permissive contract
    let permissive_contract = ServiceContract {
        official,
        identity_hash: [0xBB; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: u64::MAX, // effectively no reporting
        staked_amount: 1,              // minimal stake
        term_start: 1000,
        term_end: u64::MAX,            // never expires
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(permissive_contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::DuplicateSTPContract)),
        "R7-05 FAILED: contract overwrite accepted, got {:?}",
        result
    );
}

/// Two DIFFERENT officials can each register one contract.
#[test]
fn r7_05_stp_different_officials_can_register() {
    let state = GlobalState::genesis();
    let official_a = [0x10; 32];
    let official_b = [0x20; 32];

    let state = register_official(&state, official_a);
    let state = register_official(&state, official_b);

    assert!(state.get_stp_record(&official_a).is_some());
    assert!(state.get_stp_record(&official_b).is_some());
}

// ===========================================================================
// R7-06 MEDIUM: Rolling 24h Total Manipulation (Documented)
// ===========================================================================

/// DOCUMENTED: The rolling_24h_total_after is self-attested. The only validation
/// is that it must be >= amount. An attacker can set it to exactly `amount` for
/// every transfer, making each transfer look like the first in a 24h window.
///
/// This defeats anti-structuring protections. The proof attests the value, but
/// if the client constructs the proof dishonestly, the chain cannot verify it
/// without maintaining per-account rolling totals on-chain.
#[test]
fn r7_06_rolling_total_manipulation_documented() {
    let (state, alice, bob) = setup_wallets_with_identities();
    let alice_hash = state.get_wallet(&alice).unwrap();

    let threshold = Tier::Identified.reporting_threshold(); // 100,000,000 (10,000 MANA)

    // Attacker makes a large transfer but reports rolling_24h_total_after = amount
    // This avoids the rolling total threshold even if there were prior transfers.
    let amount = threshold - 1; // just below single-transfer threshold
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: amount, // exactly amount — pretends no prior transfers
        jurisdiction: 840,
    });

    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R7-06 DOCUMENTED: rolling total manipulation bypasses compliance (accepted)"
    );
    // Verify no compliance report was generated (because amount < threshold
    // and rolling_total = amount < threshold)
    let new_state = result.unwrap();
    assert!(
        new_state.compliance.is_empty(),
        "R7-06 DOCUMENTED: no compliance report despite large transfer (rolling total under-reported)"
    );
}

// ===========================================================================
// R7-07 MEDIUM: STP Actions Don't Consume Nonces (Documented)
// ===========================================================================

/// DOCUMENTED: STP actions can be replayed because they don't consume nonces.
/// This means the same TriggerInvestigation can be submitted multiple times,
/// overwriting the investigation record with a fresh deadline.
#[test]
fn r7_07_stp_action_replay_documented() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x01; 32];

    let state = register_official(&state, official);

    // First trigger
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: [0x99; 32],
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state1 = validate_transaction(&trigger_tx, &state, 1000, 0).unwrap();

    // Same trigger again with valid timestamp — currently succeeds (no nonce check).
    // This overwrites the investigation with a new timestamp, resetting deadlines.
    // Note: exact replay of same tx won't work due to timestamp drift, but creating
    // an identical-effect trigger at a new time works because STP has no nonce.
    let trigger_tx2 = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: [0x99; 32],
        },
        submitter: anyone,
        timestamp: 2000, // updated timestamp for second submission
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    // R10 FIX: Re-triggering the same investigation is now rejected.
    // Previously this was a documented weakness that allowed deadline resets.
    // R10 checks for existing inv_target_key binding before creating a new investigation.
    let state2 = validate_transaction(&trigger_tx2, &state1, 2000, 0);
    assert!(
        matches!(state2, Err(ChainError::STPError(_))),
        "R10 FIX: duplicate investigation trigger now rejected, got {:?}",
        state2
    );
}

// ===========================================================================
// R7-08 MEDIUM: Swap Claim/Refund Missing Nonce (Documented)
// ===========================================================================

/// DOCUMENTED: AtomicSwapClaim doesn't consume a nonce. The swap deletion
/// prevents double-claim on the same swap, but the claimer's nonce counter
/// is not advanced. This means a claim tx cannot be used to establish
/// transaction ordering for the claimer's account.
#[test]
fn r7_08_swap_claim_no_nonce_documented() {
    let (state, alice, bob) = setup_wallets();
    let swap = make_swap(alice, bob, 5000, 100, 0);

    // Init swap (bob's nonce advances to 1)
    let tx_init = Transaction::AtomicSwapInit(swap.clone());
    let s1 = validate_transaction(&tx_init, &state, 1000, 50).unwrap();
    assert_eq!(s1.get_nonce(&bob), 1);

    // Claim (alice's nonce should be 0 still)
    let tx_claim = Transaction::AtomicSwapClaim(make_claim(&swap));
    let s2 = validate_transaction(&tx_claim, &s1, 1000, 75).unwrap();

    assert_eq!(
        s2.get_nonce(&alice),
        0,
        "R7-08 DOCUMENTED: claim does not consume claimer's nonce"
    );
}

/// DOCUMENTED: AtomicSwapRefund doesn't consume a nonce either.
#[test]
fn r7_08_swap_refund_no_nonce_documented() {
    let (state, alice, bob) = setup_wallets();
    let swap = make_swap(alice, bob, 5000, 100, 0);

    let tx_init = Transaction::AtomicSwapInit(swap.clone());
    let s1 = validate_transaction(&tx_init, &state, 1000, 50).unwrap();

    let tx_refund = Transaction::AtomicSwapRefund(make_refund(&swap));
    let s2 = validate_transaction(&tx_refund, &s1, 1000, 200).unwrap();

    // Bob's nonce is 1 from init, but refund didn't advance it further
    assert_eq!(
        s2.get_nonce(&bob),
        1,
        "R7-08 DOCUMENTED: refund does not consume refundee's nonce"
    );
}

// ===========================================================================
// R7-09 LOW: STP CheckDeadline Is a No-Op (Documented)
// ===========================================================================

/// DOCUMENTED: CheckDeadline loads the investigation record but doesn't
/// actually apply freeze or slash enforcement. An official's account
/// can remain unfrozen indefinitely despite missed deadlines.
#[test]
fn r7_09_stp_check_deadline_is_noop_documented() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x01; 32];

    let state = register_official(&state, official);

    // Trigger investigation
    let pool_id = [0x99; 32];
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 1000, 0).unwrap();

    // Check deadline way past the 72h compliance deadline
    let deadline_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::CheckDeadline {
            investigation_id: pool_id,
        },
        submitter: anyone,
        timestamp: 1000 + 259_200 + 1, // past 72h deadline
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&deadline_tx, &state, 1000 + 259_200 + 1, 0);
    assert!(
        result.is_ok(),
        "R7-09 DOCUMENTED: CheckDeadline succeeds but performs no enforcement"
    );
    // Note: The official's wallet is NOT frozen despite missing the deadline.
    // This is a known limitation of the Phase 1 implementation.
}

// ===========================================================================
// R7 Compound Attack: Tier Downgrade + Structuring
// ===========================================================================

/// Compound attack: An attacker creates an account (no identity), then makes
/// many transfers claiming Tier::Identified to avoid compliance reporting,
/// while structuring amounts just below the Identified threshold.
///
/// FIX: The tier downgrade fix blocks this — the attacker must claim Anonymous
/// (which has a much lower reporting threshold of 100 MANA).
#[test]
fn r7_compound_tier_downgrade_structuring_prevented() {
    let (state, sender, recipient) = setup_wallets();
    let sender_hash = state.get_wallet(&sender).unwrap();

    // Attacker tries to transfer 999 MANA (below Identified threshold of 10,000)
    // claiming Tier::Identified
    let tx = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 9_990_000, // 999 MANA — above Anonymous threshold, below Identified
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified, // LIE!
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 9_990_000,
        jurisdiction: 840,
    });

    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::TierViolation(_))),
        "R7 compound: tier downgrade blocks structuring attack, got {:?}",
        result
    );
}

// ===========================================================================
// R7 Compound Attack: Contract Overwrite After Investigation
// ===========================================================================

/// Compound attack: An official is investigated, then tries to re-register
/// a contract with a higher reporting threshold to avoid future scrutiny.
///
/// FIX: DuplicateSTPContract prevents re-registration.
#[test]
fn r7_compound_contract_overwrite_after_investigation_prevented() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x01; 32];

    // Register restrictive contract
    let state = register_official(&state, official);

    // Trigger investigation
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: [0x99; 32],
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 1000, 0).unwrap();

    // Now try to overwrite contract with a permissive one
    let new_contract = ServiceContract {
        official,
        identity_hash: [0xBB; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: u64::MAX,
        staked_amount: 1,
        term_start: 2000,
        term_end: u64::MAX,
        status: ContractStatus::Active,
    };
    let overwrite_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(new_contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&overwrite_tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::DuplicateSTPContract)),
        "R7 compound: contract overwrite after investigation blocked, got {:?}",
        result
    );
}

// ===========================================================================
// R7 Compound Attack: Cross-Official Data Injection + Deadline Check
// ===========================================================================

/// Compound: Official A is under investigation. Official B provides data
/// claiming to be A. If accepted, when CheckDeadline is called, it looks
/// like A cooperated (though CheckDeadline is currently a no-op).
///
/// FIX: R7-02 prevents B from providing data for A's investigation.
#[test]
fn r7_compound_cross_official_then_deadline_check() {
    let state = GlobalState::genesis();
    let official_a = [0x10; 32];
    let official_b = [0x20; 32];
    let anyone = [0x30; 32];

    let state = register_official(&state, official_a);
    let state = register_official(&state, official_b);

    let pool_id = [0x99; 32];
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official_a,
            pool_id,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 1000, 0).unwrap();

    // B tries to provide data — BLOCKED
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: [0xDD; 32],
        },
        submitter: official_b,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide_tx, &state, 1000, 0);
    assert!(result.is_err(), "R7 compound: cross-official blocked");

    // A provides their own data — SUCCESS
    let provide_tx_a = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: [0xDD; 32],
        },
        submitter: official_a,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&provide_tx_a, &state, 1000, 0).unwrap();

    // CheckDeadline after data provided
    let deadline_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::CheckDeadline {
            investigation_id: pool_id,
        },
        submitter: anyone,
        timestamp: 1000 + 259_200 + 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&deadline_tx, &state, 1000 + 259_200 + 1, 0);
    assert!(result.is_ok(), "deadline check should succeed after data provided");
}

// ===========================================================================
// R7 Regression: All previous fixes still work
// ===========================================================================

/// R6: STP RegisterContract zero-stake still rejected.
#[test]
fn r7_regression_zero_stake_contract_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 0,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::STPError(_))));
}

/// R6: Fraud proof conflict type mismatch still rejected.
#[test]
fn r7_regression_conflict_type_mismatch_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    state.set_wallet(victim, [0xCC; 32]);

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0xBB; 32],
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xCC; 32],
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::StateInconsistency, // WRONG
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::FraudDetected(_))));
}

/// R5: Nonce overflow still caught.
#[test]
fn r7_regression_nonce_overflow_caught() {
    let (mut state, alice, bob) = setup_wallets_with_identities();
    state.set_nonce(alice, u64::MAX);
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 100,
        fee: 100,
        nonce: u64::MAX,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::NonceOverflow)));
}

/// R5: Backup size limit still enforced.
#[test]
fn r7_regression_backup_size_limit_enforced() {
    let (state, sender, _) = setup_wallets();
    let tx = Transaction::BackupStore(poly_chain::transaction::BackupStore {
        account_id: sender,
        encrypted_state: vec![0u8; 1_048_577],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::BackupTooLarge { .. })));
}

/// R6: Swap zero hash_lock still rejected.
#[test]
fn r7_regression_swap_zero_hash_lock_rejected() {
    let (state, alice, bob) = setup_wallets();
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), bob.as_slice(), &0u64.to_le_bytes()].concat(),
    );
    let swap = AtomicSwapInit {
        swap_id,
        initiator: alice,
        responder: bob,
        amount: 5000,
        hash_lock: ZERO_HASH,
        timeout: 100,
        disclosure_root: None,
        execution_proof: None,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    };
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(matches!(result, Err(ChainError::InvalidPreimage)));
}

/// R5: Same-observer fraud still rejected.
#[test]
fn r7_regression_same_observer_fraud_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    state.set_wallet(victim, [0xCC; 32]);

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0xBB; 32],
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xBB; 32], // SAME observer
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::FraudDetected(_))));
}

// ===========================================================================
// R7 Edge Cases
// ===========================================================================

/// Edge: Self-transfer still blocked (basic sanity).
#[test]
fn r7_edge_self_transfer_blocked() {
    let (state, alice, _) = setup_wallets();
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: alice, // self-transfer
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Anonymous,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xAA; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::SelfTransfer)));
}

/// Edge: Zero amount still blocked.
#[test]
fn r7_edge_zero_amount_blocked() {
    let (state, alice, bob) = setup_wallets();
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 0,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Anonymous,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 0,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::ZeroAmount)));
}

/// Edge: Verify WalletSync still requires existing wallet.
#[test]
fn r7_edge_wallet_sync_requires_wallet() {
    let state = GlobalState::genesis();
    let nonexistent = [0xFF; 32];

    let tx = Transaction::WalletSync(WalletSync {
        account_id: nonexistent,
        new_state_hash: [0xAA; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::AccountNotFound(_))));
}
