//! Round 6 Pentest Attack Tests
//!
//! Tests for vulnerabilities found in Round 6 security audit.
//! Each test verifies a specific attack vector is properly mitigated.
//!
//! Findings summary:
//! - R6-01 CRITICAL: STP ProvideData had no authorization (anyone could overwrite)
//! - R6-02 CRITICAL: STP TriggerInvestigation accepted non-official targets
//! - R6-03 HIGH:     Fraud proof conflict_type was not validated against actual conflict
//! - R6-04 HIGH:     Swap init nonce griefing (initiator nonce incremented without auth)
//! - R6-05 MEDIUM:   Zero hash_lock accepted in atomic swap init
//! - R6-06 MEDIUM:   STP RegisterContract accepted degenerate contracts (0 stake, bad terms)
//! - R6-07 MEDIUM:   Identity register has no nonce check (replay deviation)
//! - R6-08 LOW:      Backup storage fee not enforced in validation
//! - R6-09 LOW:      Fee calculation overflow in backup_storage_fee for large sizes

use poly_chain::prelude::*;
use poly_chain::fee::FeeSchedule;
use poly_chain::fraud::{ConflictType, FraudEvidence, StateObservation};
use poly_chain::identity::Tier;
use poly_chain::stp::{ContractStatus, ServiceContract};
use poly_chain::state::GlobalState;
use poly_chain::transaction::{
    AtomicSwapInit, AtomicSwapClaim, AtomicSwapRefund,
    BackupStore, CashTransfer, FraudProofTx, IdentityRegister,
    STPAction, STPActionTx,
};
use poly_chain::validation::validate_transaction;
use poly_chain::wallet::WalletState;
use poly_verified::types::{PrivacyMode, VerifiedProof, ZERO_HASH};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn mock_proof() -> VerifiedProof {
    VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    }
}

fn setup_wallets() -> (GlobalState, AccountId, AccountId) {
    let mut state = GlobalState::genesis();
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];

    let alice_wallet = WalletState::new([0xAA; 32], Tier::Identified, 1_000_000);
    let bob_wallet = WalletState::new([0xBB; 32], Tier::Identified, 500_000);

    state.set_wallet(alice, alice_wallet.state_hash());
    state.set_wallet(bob, bob_wallet.state_hash());

    // R7: Register identities so CashTransfer tier checks pass
    let alice_record = poly_chain::identity::IdentityRecord {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        registered_at: 0,
        is_public_official: false,
        office: None,
    };
    state.set_identity(alice, alice_record.record_hash());

    let bob_record = poly_chain::identity::IdentityRecord {
        account_id: bob,
        tier: Tier::Identified,
        identity_hash: [0xBB; 32],
        jurisdiction: 840,
        registered_at: 0,
        is_public_official: false,
        office: None,
    };
    state.set_identity(bob, bob_record.record_hash());

    (state, alice, bob)
}

fn make_swap(
    initiator: AccountId,
    responder: AccountId,
    amount: Amount,
    timeout: BlockHeight,
    nonce: Nonce,
) -> AtomicSwapInit {
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[
            initiator.as_slice(),
            responder.as_slice(),
            &nonce.to_le_bytes(),
        ]
        .concat(),
    );
    let secret = [0x5E; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, &secret);

    AtomicSwapInit {
        swap_id,
        initiator,
        responder,
        amount,
        hash_lock,
        timeout,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn make_claim(swap: &AtomicSwapInit) -> AtomicSwapClaim {
    AtomicSwapClaim {
        swap_id: swap.swap_id,
        secret: [0x5E; 32],
        claimer: swap.initiator,
        original_initiator: swap.initiator,
        original_responder: swap.responder,
        original_amount: swap.amount,
        original_hash_lock: swap.hash_lock,
        original_timeout: swap.timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn make_refund(swap: &AtomicSwapInit) -> AtomicSwapRefund {
    AtomicSwapRefund {
        swap_id: swap.swap_id,
        refundee: swap.responder,
        original_initiator: swap.initiator,
        original_responder: swap.responder,
        original_amount: swap.amount,
        original_hash_lock: swap.hash_lock,
        original_timeout: swap.timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn register_official(state: &GlobalState, official: AccountId) -> GlobalState {
    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    validate_transaction(&tx, state, 1000, 0).unwrap()
}

// ===========================================================================
// R6-01 CRITICAL: STP ProvideData Authorization
// ===========================================================================

/// FIXED: An unauthorized account cannot provide data for an investigation.
/// Previously, any account could overwrite investigation data.
#[test]
fn r6_01_stp_provide_data_unauthorized_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let eve = [0xEE; 32];

    // Register the official
    let state = register_official(&state, official);

    // Trigger investigation against the official
    let pool_id = [0x99; 32];
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: eve,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 1000, 0).unwrap();

    // Eve (non-official) tries to provide data — should be rejected
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: [0xDD; 32],
        },
        submitter: eve, // Eve has no STP contract!
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide_tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::UnauthorizedSTPAction(_))),
        "R6-01 FAILED: unauthorized ProvideData accepted, got {:?}",
        result
    );
}

/// FIXED: The official themselves CAN provide data (they have an STP contract).
#[test]
fn r6_01_stp_provide_data_authorized_accepted() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x20; 32];

    // Register the official
    let state = register_official(&state, official);

    // Trigger investigation
    let pool_id = [0x99; 32];
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 1000, 0).unwrap();

    // Official provides data — should succeed
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: [0xDD; 32],
        },
        submitter: official, // official has a contract
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide_tx, &state, 1000, 0);
    assert!(result.is_ok(), "R6-01: official should be able to provide data, got {:?}", result);
}

// ===========================================================================
// R6-02 CRITICAL: STP TriggerInvestigation Target Validation
// ===========================================================================

/// FIXED: Cannot trigger investigation against a non-official.
#[test]
fn r6_02_stp_trigger_investigation_non_official_rejected() {
    let state = GlobalState::genesis();
    let random_account = [0x42; 32];
    let submitter = [0x01; 32];

    // random_account has NO STP contract — investigation should fail
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: random_account,
            pool_id: [0x99; 32],
        },
        submitter,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&trigger_tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::UnauthorizedSTPAction(_))),
        "R6-02 FAILED: investigation of non-official accepted, got {:?}",
        result
    );
}

/// FIXED: CAN trigger investigation against a registered official.
#[test]
fn r6_02_stp_trigger_investigation_official_accepted() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let submitter = [0x01; 32];

    // Register the official
    let state = register_official(&state, official);

    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: [0x99; 32],
        },
        submitter,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&trigger_tx, &state, 1000, 0);
    assert!(result.is_ok(), "R6-02: investigation of official should succeed, got {:?}", result);
}

// ===========================================================================
// R6-03 HIGH: Fraud Proof Conflict Type Mismatch
// ===========================================================================

/// FIXED: Fraud proof claiming StateInconsistency when actual conflict is DoubleSpend is rejected.
#[test]
fn r6_03_fraud_proof_conflict_type_mismatch_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    let wallet = WalletState::new([0u8; 32], Tier::Identified, 0);
    state.set_wallet(victim, wallet.state_hash());

    // Create a real double-spend conflict (same nonce, different state)
    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0xBB; 32],
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xCC; 32],
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5, // same nonce => DoubleSpend
                observer_signature: [0u8; 64],
            },
            // LIE: claiming StateInconsistency but the actual conflict is DoubleSpend
            conflict_type: ConflictType::StateInconsistency,
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::FraudDetected(_))),
        "R6-03 FAILED: mismatched conflict type accepted, got {:?}",
        result
    );
    // Verify wallet is NOT burned
    assert!(
        state.get_wallet(&victim).is_some(),
        "R6-03: victim wallet should not be burned on invalid fraud proof"
    );
}

/// FIXED: Correct conflict type still works.
#[test]
fn r6_03_fraud_proof_correct_conflict_type_accepted() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    let wallet = WalletState::new([0u8; 32], Tier::Identified, 0);
    state.set_wallet(victim, wallet.state_hash());

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0xBB; 32],
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xCC; 32],
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend, // correct!
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(result.is_ok(), "R6-03: correct conflict type should be accepted, got {:?}", result);
}

// ===========================================================================
// R6-04 HIGH: Swap Init Nonce Griefing Attack
// ===========================================================================

/// FIXED: Swap init now uses the responder's nonce (since they sign).
/// Previously, an attacker could set initiator=victim and increment victim's nonce.
#[test]
fn r6_04_swap_init_nonce_griefing_prevented() {
    let (state, alice, _bob) = setup_wallets();
    let eve = [0xEE; 32];

    // Create eve's wallet
    let mut state = state;
    let eve_wallet = WalletState::new([0xCC; 32], Tier::Identified, 0);
    state.set_wallet(eve, eve_wallet.state_hash());

    // Check alice's nonce is 0
    assert_eq!(state.get_nonce(&alice), 0);

    // Eve creates a swap with alice as initiator, eve as responder
    // Eve signs (she's the responder). The nonce (0) is eve's nonce.
    let swap = make_swap(alice, eve, 1000, 100, 0);
    let tx = Transaction::AtomicSwapInit(swap);
    let new_state = validate_transaction(&tx, &state, 1000, 50).unwrap();

    // FIXED: Alice's nonce should NOT be incremented — only eve's (responder)
    assert_eq!(
        new_state.get_nonce(&alice),
        0,
        "R6-04 FAILED: alice's nonce incremented without her authorization"
    );
    // Eve's nonce SHOULD be incremented (she signed the tx)
    assert_eq!(
        new_state.get_nonce(&eve),
        1,
        "R6-04: eve's nonce should be incremented (she's the signer)"
    );
}

/// Verify sequential swaps from same responder use incrementing nonces.
#[test]
fn r6_04_swap_responder_nonce_sequential() {
    let (state, alice, bob) = setup_wallets();

    // First swap: bob is responder, nonce 0
    let swap1 = make_swap(alice, bob, 1000, 100, 0);
    let tx1 = Transaction::AtomicSwapInit(swap1);
    let s1 = validate_transaction(&tx1, &state, 1000, 50).unwrap();
    assert_eq!(s1.get_nonce(&bob), 1);

    // Second swap: bob is responder, nonce 1
    let swap2 = make_swap(alice, bob, 2000, 200, 1);
    let tx2 = Transaction::AtomicSwapInit(swap2);
    let s2 = validate_transaction(&tx2, &s1, 1000, 50).unwrap();
    assert_eq!(s2.get_nonce(&bob), 2);

    // Third swap with wrong nonce should fail
    let swap3 = make_swap(alice, bob, 3000, 300, 0); // nonce 0, but expected 2
    let tx3 = Transaction::AtomicSwapInit(swap3);
    let result = validate_transaction(&tx3, &s2, 1000, 50);
    assert!(
        matches!(result, Err(ChainError::InvalidNonce { expected: 2, actual: 0 })),
        "R6-04: stale responder nonce should fail"
    );
}

// ===========================================================================
// R6-05 MEDIUM: Zero Hash Lock in Atomic Swap
// ===========================================================================

/// FIXED: Zero hash_lock is now rejected.
#[test]
fn r6_05_swap_zero_hash_lock_rejected() {
    let (state, alice, bob) = setup_wallets();

    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), bob.as_slice(), &0u64.to_le_bytes()].concat(),
    );

    let swap = AtomicSwapInit {
        swap_id,
        initiator: alice,
        responder: bob,
        amount: 5000,
        hash_lock: ZERO_HASH, // zero hash_lock!
        timeout: 100,
        disclosure_root: None,
        execution_proof: None,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    };

    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(
        matches!(result, Err(ChainError::InvalidPreimage)),
        "R6-05 FAILED: zero hash_lock accepted, got {:?}",
        result
    );
}

/// Non-zero hash_lock still works fine.
#[test]
fn r6_05_swap_nonzero_hash_lock_accepted() {
    let (state, alice, bob) = setup_wallets();
    let swap = make_swap(alice, bob, 5000, 100, 0); // uses proper hash_lock
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(result.is_ok(), "R6-05: non-zero hash_lock should be accepted");
}

// ===========================================================================
// R6-06 MEDIUM: STP RegisterContract Degenerate Parameters
// ===========================================================================

/// FIXED: Contract with zero staked amount is rejected.
#[test]
fn r6_06_stp_register_zero_stake_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 0, // zero stake!
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::STPError(_))),
        "R6-06 FAILED: zero-stake contract accepted, got {:?}",
        result
    );
}

/// FIXED: Contract where term_start >= term_end is rejected.
#[test]
fn r6_06_stp_register_invalid_term_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    // term_start == term_end
    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Governor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 1000, // same as start!
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::STPError(_))),
        "R6-06 FAILED: term_start == term_end accepted, got {:?}",
        result
    );
}

/// FIXED: Contract where term_start > term_end is rejected.
#[test]
fn r6_06_stp_register_reversed_term_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Senator".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 200_000,
        term_end: 100_000, // before start!
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::STPError(_))),
        "R6-06 FAILED: reversed term accepted, got {:?}",
        result
    );
}

/// Valid contract still accepted.
#[test]
fn r6_06_stp_register_valid_contract_accepted() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let state = register_official(&state, official);
    assert!(
        state.get_stp_record(&official).is_some(),
        "R6-06: valid contract should be registered"
    );
}

// ===========================================================================
// R6-07 MEDIUM: Identity Register Missing Nonce (Documented Limitation)
// ===========================================================================

/// DOCUMENTED: Identity register has no nonce check, relying solely on
/// duplicate identity prevention. This deviates from other transaction types.
/// This test documents the behavior — not a fix, but awareness.
#[test]
fn r6_07_identity_register_no_nonce_check_documented() {
    let state = GlobalState::genesis();

    // Register identity for alice
    let alice = [0xA1; 32];
    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx, &state, 1000, 0).unwrap();

    // Attempting to register again is blocked by DuplicateIdentity, not nonce
    let tx2 = Transaction::IdentityRegister(IdentityRegister {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: [0xBB; 32], // different identity
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx2, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::DuplicateIdentity)),
        "R6-07: duplicate identity should be rejected (not by nonce but by identity check)"
    );

    // Note: alice's nonce was NOT incremented by IdentityRegister
    assert_eq!(
        state.get_nonce(&alice),
        0,
        "R6-07 DOCUMENTED: identity register does not consume nonce"
    );
}

// ===========================================================================
// R6-08 LOW: Backup Storage Fee Not Enforced
// ===========================================================================

/// DOCUMENTED: BackupStore has no fee field and no fee enforcement.
/// FeeSchedule::backup_storage_fee() exists but is never called during validation.
#[test]
fn r6_08_backup_store_no_fee_enforcement_documented() {
    let (state, sender, _) = setup_wallets();

    // Store a large backup (no fee required)
    let tx = Transaction::BackupStore(BackupStore {
        account_id: sender,
        encrypted_state: vec![0xAB; 100_000], // 100KB, should cost 100,000 units
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R6-08 DOCUMENTED: backup accepted without fee (fee field missing from BackupStore)"
    );

    // The fee SHOULD be at least 100,000 units for 100KB
    let expected_fee = FeeSchedule::backup_storage_fee(100_000);
    assert_eq!(expected_fee, 100_000);
    // But nothing enforces it in validation
}

// ===========================================================================
// R6-09 LOW: Backup Storage Fee Overflow
// ===========================================================================

/// The backup_storage_fee casts usize to u64. On a 64-bit platform,
/// usize::MAX == u64::MAX, so this doesn't overflow. But on a 32-bit
/// platform, this is safe because usize is 32-bit and u64 can hold it.
/// This test documents the behavior.
#[test]
fn r6_09_backup_fee_overflow_documented() {
    // Maximum backup size (1 MB limit)
    let max_fee = FeeSchedule::backup_storage_fee(1_048_576);
    assert_eq!(max_fee, 1_048_576);

    // Zero-length backup
    let zero_fee = FeeSchedule::backup_storage_fee(0);
    assert_eq!(zero_fee, 0);
}

// ===========================================================================
// R6 Compound Attack: Nonce Griefing + Double-Init
// ===========================================================================

/// Previously, an attacker could grief a victim's nonce by creating swaps
/// where victim=initiator. This would advance the victim's nonce counter,
/// making the victim unable to submit transactions at their expected nonce.
///
/// With the R6 fix, the responder's nonce is used, so the victim (initiator)
/// is unaffected.
#[test]
fn r6_compound_nonce_grief_then_transfer_fails_prevented() {
    let (state, alice, bob) = setup_wallets();
    let eve = [0xEE; 32];

    // Give Eve a wallet
    let mut state = state;
    let eve_wallet = WalletState::new([0xCC; 32], Tier::Identified, 0);
    state.set_wallet(eve, eve_wallet.state_hash());

    let alice_hash = state.get_wallet(&alice).unwrap();

    // Eve creates 5 swaps with alice as initiator
    for i in 0u64..5 {
        let swap = make_swap(alice, eve, 100, 100, i);
        let tx = Transaction::AtomicSwapInit(swap);
        state = validate_transaction(&tx, &state, 1000, 50).unwrap();
    }

    // FIXED: Alice's nonce is still 0 (Eve's nonce is 5)
    assert_eq!(state.get_nonce(&alice), 0, "alice nonce should be unaffected");
    assert_eq!(state.get_nonce(&eve), 5, "eve nonce should be 5");

    // Alice can still submit a CashTransfer at nonce 0
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R6 compound: alice should still be able to transact after nonce griefing fix"
    );
}

// ===========================================================================
// R6 Compound Attack: STP Chain — Register + Investigate + Provide as Eve
// ===========================================================================

/// Full STP chain attack: Eve tries to register, get investigated, and
/// then have someone else provide data on her behalf.
#[test]
fn r6_compound_stp_full_chain_authorization() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let eve = [0xEE; 32];

    // Register official
    let state = register_official(&state, official);

    // Eve cannot investigate a non-official (herself)
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: eve,
            pool_id: [0x99; 32],
        },
        submitter: eve,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&trigger_tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::UnauthorizedSTPAction(_))));

    // Investigate the REAL official
    let trigger_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: [0x99; 32],
        },
        submitter: eve,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger_tx, &state, 1000, 0).unwrap();

    // Eve cannot provide data (she has no STP contract)
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: [0x99; 32],
            data_hash: [0xDD; 32],
        },
        submitter: eve,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide_tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::UnauthorizedSTPAction(_))));

    // Official CAN provide data
    let provide_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: [0x99; 32],
            data_hash: [0xDD; 32],
        },
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide_tx, &state, 1000, 0);
    assert!(result.is_ok());
}

// ===========================================================================
// R6 Regression: Ensure previous fixes still hold
// ===========================================================================

/// R5 fix: nonce overflow still caught.
#[test]
fn r6_regression_nonce_overflow_still_caught() {
    let (mut state, alice, bob) = setup_wallets();
    state.set_nonce(alice, u64::MAX);

    let alice_hash = state.get_wallet(&alice).unwrap();
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 100,
        fee: 100,
        nonce: u64::MAX,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::NonceOverflow)),
        "R5 regression: nonce overflow should still be caught"
    );
}

/// R5 fix: backup size limit still enforced.
#[test]
fn r6_regression_backup_size_limit_still_enforced() {
    let (state, sender, _) = setup_wallets();

    let tx = Transaction::BackupStore(BackupStore {
        account_id: sender,
        encrypted_state: vec![0u8; 1_048_577], // 1 byte over limit
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::BackupTooLarge { .. })),
        "R5 regression: backup size limit should still be enforced"
    );
}

/// R5 fix: distinct fraud proof observers still required.
#[test]
fn r6_regression_fraud_proof_same_observer_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    let wallet = WalletState::new([0u8; 32], Tier::Identified, 0);
    state.set_wallet(victim, wallet.state_hash());

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0xBB; 32], // same observer
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xBB; 32], // same observer!
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::FraudDetected(_))),
        "R5 regression: same-observer fraud should still be rejected"
    );
}

// ===========================================================================
// R6 Edge Cases: Timestamp boundary conditions
// ===========================================================================

/// Timestamp exactly at the edge of acceptable drift.
#[test]
fn r6_edge_timestamp_at_max_drift() {
    let (state, sender, recipient) = setup_wallets();
    let sender_hash = state.get_wallet(&sender).unwrap();
    let now = 10_000u64;

    // Timestamp 300 seconds in the future (MAX_TIMESTAMP_DRIFT = 300)
    let tx = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 100,
        fee: 100,
        nonce: 0,
        timestamp: now + 300,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, now, 0);
    assert!(result.is_ok(), "timestamp at max drift should be accepted");

    // Timestamp 301 seconds in the future — rejected
    let tx_bad = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 100,
        fee: 100,
        nonce: 0,
        timestamp: now + 301,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx_bad, &state, now, 0);
    assert!(
        matches!(result, Err(ChainError::InvalidTimestamp)),
        "timestamp beyond max drift should be rejected"
    );
}

/// Timestamp at the lower drift boundary.
#[test]
fn r6_edge_timestamp_at_min_drift() {
    let (state, sender, recipient) = setup_wallets();
    let sender_hash = state.get_wallet(&sender).unwrap();
    let now = 10_000u64;

    // Timestamp 300 seconds in the past
    let tx = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 100,
        fee: 100,
        nonce: 0,
        timestamp: now - 300,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, now, 0);
    assert!(result.is_ok(), "timestamp at lower drift boundary should be accepted");

    // Timestamp 301 seconds in the past — rejected
    let tx_bad = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 100,
        fee: 100,
        nonce: 0,
        timestamp: now - 301,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx_bad, &state, now, 0);
    assert!(
        matches!(result, Err(ChainError::InvalidTimestamp)),
        "timestamp beyond lower drift should be rejected"
    );
}

// ===========================================================================
// R6 Edge Cases: Swap at exact timeout boundary
// ===========================================================================

/// At block_height == timeout: claim is rejected, refund is accepted.
/// This verifies there's no ambiguous gap where BOTH can succeed.
#[test]
fn r6_edge_swap_at_exact_timeout_boundary() {
    let (state, alice, bob) = setup_wallets();
    let swap = make_swap(alice, bob, 5000, 100, 0);

    let tx = Transaction::AtomicSwapInit(swap.clone());
    let s1 = validate_transaction(&tx, &state, 1000, 50).unwrap();

    // At block_height == timeout (100):
    // Claim should be rejected (block_height >= timeout)
    let claim_tx = Transaction::AtomicSwapClaim(make_claim(&swap));
    let claim_result = validate_transaction(&claim_tx, &s1, 1000, 100);
    assert!(
        matches!(claim_result, Err(ChainError::SwapExpired)),
        "claim at timeout should be rejected"
    );

    // Refund should be accepted (block_height >= timeout)
    let refund_tx = Transaction::AtomicSwapRefund(make_refund(&swap));
    let refund_result = validate_transaction(&refund_tx, &s1, 1000, 100);
    assert!(
        refund_result.is_ok(),
        "refund at timeout should be accepted"
    );
}

/// One block before timeout: claim accepted, refund rejected.
#[test]
fn r6_edge_swap_one_before_timeout() {
    let (state, alice, bob) = setup_wallets();
    let swap = make_swap(alice, bob, 5000, 100, 0);

    let tx = Transaction::AtomicSwapInit(swap.clone());
    let s1 = validate_transaction(&tx, &state, 1000, 50).unwrap();

    // At block_height 99 (one before timeout 100):
    let claim_tx = Transaction::AtomicSwapClaim(make_claim(&swap));
    let claim_result = validate_transaction(&claim_tx, &s1, 1000, 99);
    assert!(claim_result.is_ok(), "claim before timeout should work");

    let refund_tx = Transaction::AtomicSwapRefund(make_refund(&swap));
    let refund_result = validate_transaction(&refund_tx, &s1, 1000, 99);
    assert!(
        matches!(refund_result, Err(ChainError::SwapNotExpired)),
        "refund before timeout should be rejected"
    );
}
