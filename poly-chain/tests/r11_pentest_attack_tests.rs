//! Round 11 Pentest Attack Tests
//!
//! Tests for vulnerabilities found in Round 11 security audit.
//! Each test verifies a specific attack vector is properly mitigated.
//!
//! Findings summary:
//! - R11-01 CRITICAL: Nonces excluded from state_root commitment (allows state forgery)
//! - R11-02 HIGH:     Backup restore uses attacker-supplied hash for wallet (arbitrary wallet hijack)
//! - R11-03 HIGH:     Fraud proof observer can be the fraudulent account itself (reduced independence)
//! - R11-04 MEDIUM:   STP contract near-zero term duration (accountability evasion)
//! - R11-05 MEDIUM:   CashTransfer creates phantom wallet for non-existent recipient
//! - R11-06 MEDIUM:   STP RegisterContract accepts ZERO_HASH identity_hash (null identity reference)
//! - R11-07 LOW:      Swap claim/refund create zombie wallets for burned accounts

use poly_chain::prelude::*;
use poly_chain::block::Block;
use poly_chain::fraud::{ConflictType, FraudEvidence, StateObservation};
use poly_chain::identity::Tier;
use poly_chain::stp::{ContractStatus, ServiceContract};
use poly_chain::state::GlobalState;
use poly_chain::transaction::{
    AppStateUpdate, AtomicSwapClaim, AtomicSwapInit, AtomicSwapRefund,
    BackupRestore, BackupStore, CashTransfer, FraudProofTx,
    IdentityRegister, STPAction, STPActionTx, WalletSync,
};
use poly_chain::validation::validate_transaction;
use poly_chain::wallet::WalletState;
use poly_verified::types::{PrivacyMode, VerifiedProof, ZERO_HASH};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn mock_proof() -> VerifiedProof {
    VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    }
}

fn setup_wallets() -> (GlobalState, AccountId, AccountId) {
    let mut state = GlobalState::genesis();
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];

    let alice_wallet = WalletState::new([0xAA; 32], Tier::Identified, 1_000_000);
    let bob_wallet = WalletState::new([0xBB; 32], Tier::Identified, 500_000);

    state.set_wallet(alice, alice_wallet.state_hash());
    state.set_wallet(bob, bob_wallet.state_hash());

    (state, alice, bob)
}

fn setup_wallets_with_identities() -> (GlobalState, AccountId, AccountId) {
    let (state, alice, bob) = setup_wallets();

    let tx_alice_id = Transaction::IdentityRegister(IdentityRegister {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_alice_id, &state, 1000, 0).unwrap();

    let tx_bob_id = Transaction::IdentityRegister(IdentityRegister {
        account_id: bob,
        tier: Tier::Identified,
        identity_hash: [0xBB; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_bob_id, &state, 1000, 0).unwrap();

    (state, alice, bob)
}

fn register_official(state: &GlobalState, official: AccountId) -> GlobalState {
    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    validate_transaction(&tx, state, 1000, 0).unwrap()
}

fn make_swap(
    initiator: AccountId,
    responder: AccountId,
    amount: Amount,
    timeout: BlockHeight,
    nonce: Nonce,
) -> AtomicSwapInit {
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[
            initiator.as_slice(),
            responder.as_slice(),
            &nonce.to_le_bytes(),
        ]
        .concat(),
    );
    let secret = [0x5E; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, &secret);

    AtomicSwapInit {
        swap_id,
        initiator,
        responder,
        amount,
        hash_lock,
        timeout,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn make_claim(swap: &AtomicSwapInit) -> AtomicSwapClaim {
    AtomicSwapClaim {
        swap_id: swap.swap_id,
        secret: [0x5E; 32],
        claimer: swap.initiator,
        original_initiator: swap.initiator,
        original_responder: swap.responder,
        original_amount: swap.amount,
        original_hash_lock: swap.hash_lock,
        original_timeout: swap.timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn make_refund(swap: &AtomicSwapInit) -> AtomicSwapRefund {
    AtomicSwapRefund {
        swap_id: swap.swap_id,
        refundee: swap.responder,
        original_initiator: swap.initiator,
        original_responder: swap.responder,
        original_amount: swap.amount,
        original_hash_lock: swap.hash_lock,
        original_timeout: swap.timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

// ===========================================================================
// R11-01 CRITICAL: Nonces Excluded from state_root Commitment
// ===========================================================================

/// ATTACK: The state_root was computed from the 8 SMT subtree roots only,
/// excluding the nonces map. Two states with identical subtrees but different
/// nonces would produce the same state_root. An attacker who obtains a state
/// snapshot could forge a state with reset nonces (all accounts back to nonce 0),
/// and the forged state would have the same state_root as the real state.
/// Transaction replay is then possible because the nonce check passes against
/// the forged (reset) nonces.
///
/// FIX: state_root() now includes nonces_hash() -- H(account_id || nonce) for
/// all entries -- in the commitment. Different nonces produce different roots.
#[test]
fn r11_01_state_root_includes_nonces() {
    let mut state = GlobalState::genesis();
    let root_before = state.state_root();

    // Set a nonce
    state.set_nonce([0x01; 32], 42);
    let root_after = state.state_root();

    // State roots MUST differ -- nonces are committed
    assert_ne!(
        root_before, root_after,
        "R11-01 FAILED: state_root did not change after setting a nonce -- \
         nonces are not committed to the state root"
    );
}

/// Verify that different nonce values produce different state roots.
#[test]
fn r11_01_different_nonces_different_roots() {
    let mut state1 = GlobalState::genesis();
    state1.set_nonce([0x01; 32], 1);

    let mut state2 = GlobalState::genesis();
    state2.set_nonce([0x01; 32], 2);

    assert_ne!(
        state1.state_root(),
        state2.state_root(),
        "R11-01: different nonce values must produce different state roots"
    );
}

/// Verify that different accounts with nonces produce different state roots.
#[test]
fn r11_01_different_accounts_different_roots() {
    let mut state1 = GlobalState::genesis();
    state1.set_nonce([0x01; 32], 1);

    let mut state2 = GlobalState::genesis();
    state2.set_nonce([0x02; 32], 1);

    assert_ne!(
        state1.state_root(),
        state2.state_root(),
        "R11-01: different nonce accounts must produce different state roots"
    );
}

/// Verify that nonce order is deterministic (BTreeMap ordering).
#[test]
fn r11_01_nonce_ordering_deterministic() {
    let mut state1 = GlobalState::genesis();
    state1.set_nonce([0x01; 32], 1);
    state1.set_nonce([0x02; 32], 2);

    let mut state2 = GlobalState::genesis();
    state2.set_nonce([0x02; 32], 2);
    state2.set_nonce([0x01; 32], 1);

    assert_eq!(
        state1.state_root(),
        state2.state_root(),
        "R11-01: nonce insertion order must not affect state_root (BTreeMap ensures determinism)"
    );
}

/// Verify genesis state (empty nonces) still has a deterministic root.
#[test]
fn r11_01_empty_nonces_deterministic() {
    let s1 = GlobalState::genesis();
    let s2 = GlobalState::genesis();
    assert_eq!(s1.state_root(), s2.state_root());
}

/// ATTACK SCENARIO: Forge a state with reset nonces. Before the fix, the forged
/// state would have the same state_root as the real state (same subtrees, different
/// nonces). After the fix, the roots differ.
#[test]
fn r11_01_nonce_reset_forgery_detected() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    // Advance alice's nonce through a legitimate transaction
    let tx = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: [0xFF; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let real_state = validate_transaction(&tx, &state, 1000, 0).unwrap();
    assert_eq!(real_state.get_nonce(&alice), 1);

    // Create a "forged" state: same subtrees, but nonces reset to 0
    // We can't actually forge the subtrees, but we can check the roots differ
    // because the nonce map IS now included in the state root.
    let forged_state = state.clone(); // genesis-like nonces (alice=0)
    // The forged state has the same wallets/identities but different nonces
    assert_ne!(
        real_state.state_root(),
        forged_state.state_root(),
        "R11-01: forged state with reset nonces must have a different state_root"
    );
}

// ===========================================================================
// R11-02 HIGH: Backup Restore Uses Attacker-Supplied Hash for Wallet
// ===========================================================================

/// ATTACK: An attacker stores a backup with state_hash [0xCC; 32], then submits
/// a BackupRestore with backup_hash [0xFF; 32] (an attacker-chosen value).
/// Previously, the wallet was set to tx.backup_hash (the attacker's value).
/// In mock/test mode where proof verification is skipped, this allowed the
/// attacker to set their wallet to any arbitrary value, bypassing the intended
/// restore-from-backup semantics.
///
/// FIX: The wallet is now always set to the stored backup hash (the authoritative
/// value on chain), not to the user-supplied tx.backup_hash.
#[test]
fn r11_02_backup_restore_uses_stored_hash_not_tx_hash() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    // Store a backup with state_hash [0xCC; 32]
    let tx_store = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3, 4],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_store, &state, 1000, 0).unwrap();
    assert_eq!(state.get_backup(&alice), Some([0xCC; 32]));

    // Attempt to restore with a DIFFERENT hash (attacker-chosen value)
    let tx_restore = Transaction::BackupRestore(BackupRestore {
        account_id: alice,
        backup_hash: [0xFF; 32], // Attacker wants wallet set to this
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let new_state = validate_transaction(&tx_restore, &state, 1000, 0).unwrap();

    // The wallet MUST be set to the stored backup hash [0xCC; 32],
    // NOT to the attacker's [0xFF; 32]
    let wallet_hash = new_state.get_wallet(&alice).expect("wallet should exist after restore");

    // Compute what the wallet hash WOULD be if attacker-supplied hash was used
    let _attacker_wallet = hash_with_domain(
        DOMAIN_WALLET_STATE,
        &[alice.as_slice(), &[0xFF; 32]].concat(),
    );

    // Compute what the wallet hash SHOULD be (using stored backup hash)
    let _correct_wallet = hash_with_domain(
        DOMAIN_WALLET_STATE,
        &[alice.as_slice(), &[0xCC; 32]].concat(),
    );

    // The wallet should NOT match the attacker's desired value
    // (in the old code, it would have been set to [0xFF; 32]-based hash)
    // Note: The actual wallet is set to the stored backup_hash directly,
    // not to hash_with_domain(..., backup_hash). Let's check directly.
    assert_eq!(
        wallet_hash, [0xCC; 32],
        "R11-02 FAILED: wallet was not set to the stored backup hash. \
         Attacker may have manipulated the restore target."
    );
}

/// Verify that restore with the SAME hash as stored backup works correctly.
#[test]
fn r11_02_backup_restore_matching_hash_accepted() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    // Store a backup
    let tx_store = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3, 4],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_store, &state, 1000, 0).unwrap();

    // Restore with matching hash -- should succeed
    let tx_restore = Transaction::BackupRestore(BackupRestore {
        account_id: alice,
        backup_hash: [0xCC; 32], // matches stored
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx_restore, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R11-02 regression: backup restore with matching hash should succeed, got {:?}",
        result
    );
}

/// Verify the wallet is set to the stored backup hash even when tx provides different value.
#[test]
fn r11_02_backup_restore_wallet_always_uses_authoritative_hash() {
    let (state, alice, _bob) = setup_wallets_with_identities();
    let stored_hash = [0xCC; 32];
    let attacker_hash = [0xDD; 32]; // Different from stored

    // Store a backup
    let tx_store = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3, 4],
        state_hash: stored_hash,
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_store, &state, 1000, 0).unwrap();

    // Restore with attacker's hash
    let tx_restore = Transaction::BackupRestore(BackupRestore {
        account_id: alice,
        backup_hash: attacker_hash,
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let new_state = validate_transaction(&tx_restore, &state, 1000, 0).unwrap();

    // Wallet must equal the stored backup hash, not the attacker's
    assert_eq!(
        new_state.get_wallet(&alice),
        Some(stored_hash),
        "R11-02: wallet must be restored to stored backup hash, not tx.backup_hash"
    );
}

// ===========================================================================
// R11-03 HIGH: Fraud Proof Observer Can Be the Fraudulent Account
// ===========================================================================

/// ATTACK: An attacker fabricates a fraud proof where one of the "independent"
/// observers is the fraudulent account itself. This reduces the attestation
/// requirement from two independent third parties to just one colluding party
/// plus the fraudster themselves.
///
/// Example: Eve wants to frame Victim. Eve controls observer_a = Victim's key
/// (or IS the fraudster acting as observer). Only one truly independent
/// observation (observer_b) is needed.
///
/// FIX: Neither observer_a nor observer_b may be the fraudulent_key.
#[test]
fn r11_03_fraud_observer_is_fraudulent_key_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    state.set_wallet(victim, [0xCC; 32]);

    // observer_a IS the fraudulent account
    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: victim, // ATTACK: observer == fraudulent_key
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xBB; 32],
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R11-03 FAILED: fraud proof where observer_a is the fraudulent account was accepted"
    );
    // Verify it's the right error
    let err = result.unwrap_err();
    let err_msg = format!("{err}");
    assert!(
        err_msg.contains("observer cannot be the fraudulent account"),
        "R11-03: expected 'observer cannot be the fraudulent account', got: {err_msg}"
    );
}

/// ATTACK: observer_b is the fraudulent account (reversed position).
#[test]
fn r11_03_fraud_observer_b_is_fraudulent_key_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    state.set_wallet(victim, [0xCC; 32]);

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0xBB; 32],
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: victim, // ATTACK: observer_b == fraudulent_key
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R11-03 FAILED: fraud proof where observer_b is the fraudulent account was accepted"
    );
}

/// ATTACK: BOTH observers are the fraudulent account.
#[test]
fn r11_03_fraud_both_observers_are_fraudulent_key_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    state.set_wallet(victim, [0xCC; 32]);

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: victim,
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: victim, // both == fraudulent_key
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    // Should be caught by EITHER the R11-03 check (observer == fraudulent_key)
    // OR the R5 check (same observer), or both. Either way, it must be rejected.
    assert!(
        result.is_err(),
        "R11-03 FAILED: fraud proof where both observers are the fraudulent account was accepted"
    );
}

/// VALID: Fraud proof with distinct, independent observers still accepted.
#[test]
fn r11_03_fraud_proof_distinct_observers_accepted() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    state.set_wallet(victim, [0xCC; 32]);

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0xBB; 32], // independent
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xCC; 32], // independent
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R11-03 regression: fraud proof with distinct independent observers should succeed, got {:?}",
        result
    );
}

// ===========================================================================
// R11-04 MEDIUM: STP Contract Near-Zero Term Duration
// ===========================================================================

/// ATTACK: An official registers a contract with a 1-second term
/// (term_end = term_start + 1). This satisfies the "has contract" check for
/// TriggerInvestigation but the contract expires almost immediately. If an
/// investigation is triggered after the contract expires, the official can
/// claim the contract is no longer valid. A 24-hour minimum ensures
/// meaningful accountability.
///
/// FIX: Minimum term duration of 86,400 seconds (24 hours).
#[test]
fn r11_04_stp_contract_one_second_term_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 1001, // 1 second duration!
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R11-04 FAILED: 1-second term contract accepted, got {:?}",
        result
    );
    let err_msg = format!("{}", result.unwrap_err());
    assert!(
        err_msg.contains("contract term too short"),
        "R11-04: expected 'contract term too short', got: {err_msg}"
    );
}

/// ATTACK: Term duration of exactly 86,399 seconds (1 second under minimum).
#[test]
fn r11_04_stp_contract_one_under_minimum_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Senator".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 1000 + 86_399, // 1 second under 24h
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R11-04 FAILED: 86,399-second term contract accepted (1 under minimum)"
    );
}

/// VALID: Term duration of exactly 86,400 seconds (exactly at minimum).
#[test]
fn r11_04_stp_contract_exact_minimum_accepted() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 1000 + 86_400, // exactly 24h
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R11-04 regression: 24-hour term contract should be accepted, got {:?}",
        result
    );
}

/// VALID: Normal long-term contract still accepted.
#[test]
fn r11_04_stp_contract_long_term_accepted() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Governor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 1000 + 365 * 86_400, // 1 year
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R11-04 regression: 1-year term contract should be accepted, got {:?}",
        result
    );
}

// ===========================================================================
// R11-05 MEDIUM: CashTransfer Creates Phantom Wallet for Non-Existent Recipient
// ===========================================================================

/// ATTACK: A sender transfers funds to a recipient who has no wallet on chain.
/// Previously, the recipient's wallet hash was computed and stored regardless,
/// creating a "phantom wallet" -- a wallet entry with no associated identity,
/// no KYC tier, and no compliance tracking. This bypasses the normal wallet
/// creation path (which requires IdentityRegister).
///
/// FIX: validate_cash_transfer now checks that the recipient wallet exists.
#[test]
fn r11_05_cash_transfer_to_nonexistent_recipient_rejected() {
    let (state, alice, _bob) = setup_wallets_with_identities();
    let phantom = [0xDE; 32]; // This account has no wallet
    let alice_hash = state.get_wallet(&alice).unwrap();

    assert!(
        state.get_wallet(&phantom).is_none(),
        "precondition: phantom account must not have a wallet"
    );

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: phantom,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xDE; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R11-05 FAILED: cash transfer to non-existent recipient accepted (would create phantom wallet)"
    );
    assert!(
        matches!(result, Err(ChainError::AccountNotFound(_))),
        "R11-05: expected AccountNotFound, got {:?}",
        result
    );
}

/// Verify that phantom accounts still don't have wallets after rejected transfer.
#[test]
fn r11_05_phantom_wallet_not_created_after_rejection() {
    let (state, alice, _bob) = setup_wallets_with_identities();
    let phantom = [0xDE; 32];
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: phantom,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xDE; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let _ = validate_transaction(&tx, &state, 1000, 0);

    // State is unchanged (transaction was rejected)
    assert!(
        state.get_wallet(&phantom).is_none(),
        "R11-05: phantom account wallet must not exist after rejected transfer"
    );
}

/// VALID: Transfer to an existing wallet still works.
#[test]
fn r11_05_cash_transfer_to_existing_wallet_accepted() {
    let (state, alice, bob) = setup_wallets_with_identities();
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R11-05 regression: transfer to existing wallet should succeed, got {:?}",
        result
    );
}

// ===========================================================================
// R11-06 MEDIUM: STP RegisterContract with ZERO_HASH identity_hash
// ===========================================================================

/// DOCUMENTED: An official can register a contract with identity_hash = ZERO_HASH.
/// This creates a contract record referencing a null identity. The identity_hash is
/// used in contract_hash() computation and in the STP subtree. While it doesn't
/// directly enable an exploit (the contract still gets a unique hash due to other
/// fields), it creates a situation where the official's contract has no meaningful
/// identity binding, making it harder to track accountability across contracts.
///
/// This is documented rather than fixed because:
/// 1. The STP system already requires the official to have a registered identity
///    for other operations (like TriggerInvestigation checking for a contract).
/// 2. The contract_hash is still unique even with ZERO_HASH identity.
/// 3. Fixing this would require cross-referencing with the identity SMT, adding
///    complexity for marginal security gain.
#[test]
fn r11_06_stp_contract_zero_identity_hash_documented() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let contract = ServiceContract {
        official,
        identity_hash: ZERO_HASH, // Null identity reference!
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract.clone()),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);

    // Currently accepted -- documenting this behavior
    assert!(
        result.is_ok(),
        "R11-06 DOCUMENTED: STP contract with ZERO_HASH identity_hash is currently accepted"
    );

    // Verify the contract was stored (the hash is still unique due to other fields)
    let new_state = result.unwrap();
    assert!(
        new_state.get_stp_record(&official).is_some(),
        "R11-06: contract should be stored despite ZERO_HASH identity"
    );
}

/// DOCUMENTED: Two contracts with different officials but both using ZERO_HASH
/// identity_hash produce different contract hashes (no collision risk).
#[test]
fn r11_06_stp_zero_identity_no_collision() {
    let _state = GlobalState::genesis();
    let official_a = [0x10; 32];
    let official_b = [0x20; 32];

    let contract_a = ServiceContract {
        official: official_a,
        identity_hash: ZERO_HASH,
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let contract_b = ServiceContract {
        official: official_b,
        identity_hash: ZERO_HASH,
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };

    assert_ne!(
        contract_a.contract_hash(),
        contract_b.contract_hash(),
        "R11-06: different officials with ZERO_HASH identity must still produce different hashes"
    );
}

// ===========================================================================
// R11-07 LOW: Swap Claim/Refund Create Zombie Wallets for Burned Accounts
// ===========================================================================

/// DOCUMENTED: When a swap is claimed, the claimer's wallet is updated using
/// `state.get_wallet(&tx.claimer).unwrap_or(ZERO_HASH)` as the base. If the
/// claimer's wallet was previously burned by a fraud proof (removed from SMT),
/// the fallback ZERO_HASH is used, and a new wallet hash is computed from it.
/// This creates a "zombie wallet" -- the account was burned for fraud but now
/// has a new wallet entry, potentially allowing the fraudster to continue
/// operating after being penalized.
///
/// This is documented because:
/// 1. The claimer must be the swap initiator (verified on line 1231)
/// 2. The swap was created before the fraud burn
/// 3. Preventing the claim would permanently lock the responder's funds
///    (no claim, no refund until timeout)
/// 4. A proper fix requires a "burned accounts" blacklist or timestamp checking
#[test]
fn r11_07_swap_claim_creates_zombie_wallet_after_fraud_burn() {
    let (state, alice, bob) = setup_wallets();

    // Create a swap: alice is initiator, bob is responder
    let swap = make_swap(alice, bob, 5000, 100, 0);
    let tx_init = Transaction::AtomicSwapInit(swap.clone());
    let state = validate_transaction(&tx_init, &state, 1000, 50).unwrap();

    // Now, a fraud proof burns alice's wallet
    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: alice,
            observation_a: StateObservation {
                observer: [0xBB; 32],
                observed_key: alice,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xCC; 32],
                observed_key: alice,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let state = validate_transaction(&fraud_tx, &state, 1000, 0).unwrap();

    // Alice's wallet is burned
    assert!(
        state.get_wallet(&alice).is_none(),
        "precondition: alice's wallet should be burned"
    );

    // Alice claims the swap -- this should create a zombie wallet
    let claim = make_claim(&swap);
    let tx_claim = Transaction::AtomicSwapClaim(claim);
    let new_state = validate_transaction(&tx_claim, &state, 1000, 75).unwrap();

    // Alice now has a wallet again despite being burned for fraud
    assert!(
        new_state.get_wallet(&alice).is_some(),
        "R11-07 DOCUMENTED: swap claim creates a zombie wallet for burned account"
    );
}

/// DOCUMENTED: Swap refund also creates a zombie wallet for a burned responder.
#[test]
fn r11_07_swap_refund_creates_zombie_wallet_after_fraud_burn() {
    let (state, alice, bob) = setup_wallets();

    // Create a swap: alice is initiator, bob is responder
    let swap = make_swap(alice, bob, 5000, 100, 0);
    let tx_init = Transaction::AtomicSwapInit(swap.clone());
    let state = validate_transaction(&tx_init, &state, 1000, 50).unwrap();

    // Fraud proof burns bob's wallet
    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: bob,
            observation_a: StateObservation {
                observer: [0xBB; 32],
                observed_key: bob,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xCC; 32],
                observed_key: bob,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let state = validate_transaction(&fraud_tx, &state, 1000, 0).unwrap();

    // Bob's wallet is burned
    assert!(
        state.get_wallet(&bob).is_none(),
        "precondition: bob's wallet should be burned"
    );

    // Bob refunds after timeout -- creates zombie wallet
    let refund = make_refund(&swap);
    let tx_refund = Transaction::AtomicSwapRefund(refund);
    let new_state = validate_transaction(&tx_refund, &state, 1000, 100).unwrap();

    // Bob now has a wallet again despite being burned
    assert!(
        new_state.get_wallet(&bob).is_some(),
        "R11-07 DOCUMENTED: swap refund creates a zombie wallet for burned account"
    );
}

// ===========================================================================
// R11 Compound Attack: Nonce Reset + Transaction Replay
// ===========================================================================

/// Compound attack demonstrating the nonce-in-state-root fix.
/// Before the fix, an attacker could:
/// 1. Observe the current state (subtrees identical, nonces advanced)
/// 2. Fork the state, resetting nonces to 0
/// 3. The forged state would have the SAME state_root (nonces not committed)
/// 4. Replay old transactions on the forged state (nonces match now)
///
/// After the fix, step 3 fails -- the roots differ.
#[test]
fn r11_compound_nonce_reset_replay_detected() {
    let (state, alice, bob) = setup_wallets_with_identities();
    let alice_hash = state.get_wallet(&alice).unwrap();

    // Alice makes a legitimate transfer
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let state_after = validate_transaction(&tx, &state, 1000, 0).unwrap();

    // Alice's nonce is now 1
    assert_eq!(state_after.get_nonce(&alice), 1);

    // Attempt to replay the same transaction (nonce 0 again)
    // Note: This fails with StateHashMismatch because the first transfer changed
    // alice's wallet hash, so state_pre no longer matches. The state_pre check
    // happens before the nonce check. Both checks protect against replay.
    let replay_result = validate_transaction(&tx, &state_after, 1000, 0);
    assert!(
        replay_result.is_err(),
        "R11 compound: replayed transaction with old nonce must be rejected"
    );
    // The replay is caught by state_pre mismatch (wallet hash changed) or nonce check
    assert!(
        matches!(replay_result, Err(ChainError::StateHashMismatch { .. })
            | Err(ChainError::InvalidNonce { .. })),
        "R11 compound: replay should fail with StateHashMismatch or InvalidNonce, got {:?}",
        replay_result
    );

    // The state roots differ because nonces are committed
    assert_ne!(
        state.state_root(),
        state_after.state_root(),
        "R11 compound: state before and after transfer must have different roots (nonces committed)"
    );
}

// ===========================================================================
// R11 Compound Attack: Backup Restore Hijack Chain
// ===========================================================================

/// Compound attack: attacker stores a backup, then tries multiple restore
/// attempts with different hashes to find one that gives them a favorable
/// wallet state. After the fix, all restores use the stored backup hash.
#[test]
fn r11_compound_backup_restore_multiple_attempts_same_result() {
    let (state, alice, _bob) = setup_wallets_with_identities();
    let stored = [0xCC; 32];

    // Store backup
    let tx_store = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3, 4],
        state_hash: stored,
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_store, &state, 1000, 0).unwrap();

    // Attempt 1: restore with [0xDD; 32]
    let tx1 = Transaction::BackupRestore(BackupRestore {
        account_id: alice,
        backup_hash: [0xDD; 32],
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state1 = validate_transaction(&tx1, &state, 1000, 0).unwrap();

    // Attempt 2: restore with [0xEE; 32] (from a fresh state -- re-store first)
    let state_fresh = validate_transaction(&tx_store, &{
        let (s, _, _) = setup_wallets_with_identities();
        s
    }, 1000, 0).unwrap();
    let tx2 = Transaction::BackupRestore(BackupRestore {
        account_id: alice,
        backup_hash: [0xEE; 32],
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state2 = validate_transaction(&tx2, &state_fresh, 1000, 0).unwrap();

    // Both restores should produce the same wallet (stored backup hash)
    assert_eq!(
        state1.get_wallet(&alice),
        state2.get_wallet(&alice),
        "R11 compound: different tx.backup_hash values must produce the same restored wallet"
    );
    // And the wallet must be the stored backup hash
    assert_eq!(
        state1.get_wallet(&alice),
        Some(stored),
        "R11 compound: restored wallet must equal stored backup hash"
    );
}

// ===========================================================================
// R11 Compound Attack: Fraud Observer Self-Burn Evasion
// ===========================================================================

/// Compound attack: A fraudster (Eve) tries to burn their own wallet by
/// fabricating a fraud proof where they act as one observer. Before the fix,
/// Eve only needed one colluding observer. After the fix, she needs TWO
/// independent observers, neither of which can be herself.
#[test]
fn r11_compound_self_observer_fraud_evasion_blocked() {
    let mut state = GlobalState::genesis();
    let eve = [0xEE; 32];
    state.set_wallet(eve, [0xCC; 32]);

    // Eve tries to submit fraud proof against herself as one observer
    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: eve,
            observation_a: StateObservation {
                observer: eve, // Eve observes herself -- BLOCKED
                observed_key: eve,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x01; 32], // single colluder
                observed_key: eve,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: eve,
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R11 compound: self-observer fraud burn must be blocked"
    );

    // Eve's wallet should still exist
    assert!(
        state.get_wallet(&eve).is_some(),
        "R11 compound: Eve's wallet must NOT be burned by blocked fraud proof"
    );
}

// ===========================================================================
// R11 Compound Attack: Short-Term Contract + Investigation Evasion
// ===========================================================================

/// Compound attack: An official tries to register a contract with a term
/// just under 24 hours, hoping to evade investigation. The contract would
/// expire before any meaningful investigation could be conducted.
#[test]
fn r11_compound_short_term_investigation_evasion_blocked() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    // Try 23 hours 59 minutes 59 seconds -- under minimum
    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 1000 + 86_400 - 1, // 23:59:59 -- under minimum
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R11 compound: contract with 23:59:59 term must be rejected"
    );

    // But exactly 24 hours works
    let contract_ok = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 1000 + 86_400, // exactly 24h -- at minimum
        status: ContractStatus::Active,
    };
    let tx_ok = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract_ok),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result_ok = validate_transaction(&tx_ok, &state, 1000, 0);
    assert!(
        result_ok.is_ok(),
        "R11 compound: exactly 24h term should be accepted, got {:?}",
        result_ok
    );
}

// ===========================================================================
// R11 Regression Tests
// ===========================================================================

/// R10: STP investigation deadline reset still blocked.
#[test]
fn r11_regression_investigation_deadline_reset_still_blocked() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x30; 32];

    let state = register_official(&state, official);

    let pool_id = [0x99; 32];
    let trigger = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger, &state, 1000, 0).unwrap();

    // Re-trigger same investigation -- should be blocked
    let retrigger = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: anyone,
        timestamp: 2000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&retrigger, &state, 2000, 0);
    assert!(
        result.is_err(),
        "R11 regression: investigation deadline reset should still be blocked"
    );
}

/// R9: ZERO_HASH app state update still rejected.
#[test]
fn r11_regression_zero_hash_app_state_still_rejected() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    let tx = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id: [0xA0; 32],
        new_state_hash: ZERO_HASH,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::InvalidEncoding(_))));
}

/// R8: WalletSync ZERO_HASH still rejected.
#[test]
fn r11_regression_wallet_sync_zero_hash_still_rejected() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    let tx = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: ZERO_HASH,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::InvalidEncoding(_))));
}

/// R7: Tier violation without identity still rejected.
#[test]
fn r11_regression_tier_violation_still_rejected() {
    let (state, sender, recipient) = setup_wallets();
    let sender_hash = state.get_wallet(&sender).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::TierViolation(_))));
}

/// R6: Swap zero hash_lock still rejected.
#[test]
fn r11_regression_swap_zero_hash_lock_still_rejected() {
    let (state, alice, bob) = setup_wallets();
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), bob.as_slice(), &0u64.to_le_bytes()].concat(),
    );
    let swap = AtomicSwapInit {
        swap_id,
        initiator: alice,
        responder: bob,
        amount: 5000,
        hash_lock: ZERO_HASH,
        timeout: 100,
        disclosure_root: None,
        execution_proof: None,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    };
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(matches!(result, Err(ChainError::InvalidPreimage)));
}

/// R5: Nonce overflow still caught.
#[test]
fn r11_regression_nonce_overflow_still_caught() {
    let (mut state, alice, bob) = setup_wallets_with_identities();
    state.set_nonce(alice, u64::MAX);
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 100,
        fee: 100,
        nonce: u64::MAX,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::NonceOverflow)));
}

/// R5: Backup size limit still enforced.
#[test]
fn r11_regression_backup_size_limit_still_enforced() {
    let (state, sender, _) = setup_wallets();
    let tx = Transaction::BackupStore(BackupStore {
        account_id: sender,
        encrypted_state: vec![0u8; 1_048_577],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::BackupTooLarge { .. })));
}

/// R5: Same observers in fraud proof still rejected.
#[test]
fn r11_regression_same_observers_still_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    state.set_wallet(victim, [0xCC; 32]);

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0xBB; 32],
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xBB; 32], // same as observer_a
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(result.is_err());
}

/// R6: Conflict type mismatch still rejected.
#[test]
fn r11_regression_conflict_type_mismatch_still_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    state.set_wallet(victim, [0xCC; 32]);

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0xBB; 32],
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xCC; 32],
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::StateInconsistency, // wrong -- it's DoubleSpend
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::FraudDetected(_))));
}

/// Block validation still works.
#[test]
fn r11_regression_block_validation_still_works() {
    let genesis = Block::genesis([0xAA; 32], 1000);
    let child = Block::try_new(&genesis.header, vec![], [0xBB; 32], 2000).unwrap();
    let result = child.validate_against_parent(&genesis.header);
    assert!(result.is_ok());
}

/// Duplicate STP contract still rejected.
#[test]
fn r11_regression_duplicate_stp_contract_still_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let state = register_official(&state, official);

    let contract = ServiceContract {
        official,
        identity_hash: [0xBB; 32],
        office: "Senator".into(),
        jurisdiction: 840,
        reporting_threshold: u64::MAX,
        staked_amount: 1,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::DuplicateSTPContract)));
}
