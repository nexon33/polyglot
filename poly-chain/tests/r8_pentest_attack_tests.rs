//! Round 8 Pentest Attack Tests
//!
//! Tests for vulnerabilities found in Round 8 security audit.
//! Each test verifies a specific attack vector is properly mitigated.
//!
//! Findings summary:
//! - R8-01 HIGH:   STP RegisterContract accepts non-Active status (sham contracts)
//! - R8-02 HIGH:   Identity registration accepts ZERO_HASH identity_hash
//! - R8-03 HIGH:   No block-level validation (parent hash, timestamp ordering, height gaps)
//! - R8-04 HIGH:   WalletSync allows ZERO_HASH new_state_hash (wallet deletion via SMT sentinel)
//! - R8-05 MEDIUM: Fraud submitter can equal fraudulent_key (self-burn for evasion)
//! - R8-06 MEDIUM: Swap init allows timeout u64::MAX (permanent fund lock)
//! - R8-07 MEDIUM: Block tx_count/transactions_root can be forged in deserialized headers
//! - R8-08 MEDIUM: AppStateUpdate uses app_id directly in SMT (no domain separation from wallets)
//! - R8-09 MEDIUM: CashTransfer fee is only checked >= base_fee, not against schedule
//! - R8-10 LOW:    Fee+amount overflow returns InsufficientBalance (misleading error semantics)

use poly_chain::prelude::*;
use poly_chain::block::{Block, BlockHeader};
use poly_chain::fraud::{ConflictType, FraudEvidence, StateObservation};
use poly_chain::identity::Tier;
use poly_chain::stp::{ContractStatus, ServiceContract};
use poly_chain::state::GlobalState;
use poly_chain::transaction::{
    AtomicSwapInit, AtomicSwapClaim, AtomicSwapRefund,
    AppStateUpdate, BackupStore, CashTransfer, FraudProofTx,
    IdentityRegister, STPAction, STPActionTx, WalletSync,
};
use poly_chain::validation::validate_transaction;
use poly_chain::wallet::WalletState;
use poly_verified::types::{PrivacyMode, VerifiedProof, ZERO_HASH};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn mock_proof() -> VerifiedProof {
    VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    }
}

fn setup_wallets() -> (GlobalState, AccountId, AccountId) {
    let mut state = GlobalState::genesis();
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];

    let alice_wallet = WalletState::new([0xAA; 32], Tier::Identified, 1_000_000);
    let bob_wallet = WalletState::new([0xBB; 32], Tier::Identified, 500_000);

    state.set_wallet(alice, alice_wallet.state_hash());
    state.set_wallet(bob, bob_wallet.state_hash());

    (state, alice, bob)
}

fn setup_wallets_with_identities() -> (GlobalState, AccountId, AccountId) {
    let (state, alice, bob) = setup_wallets();

    let tx_alice_id = Transaction::IdentityRegister(IdentityRegister {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_alice_id, &state, 1000, 0).unwrap();

    let tx_bob_id = Transaction::IdentityRegister(IdentityRegister {
        account_id: bob,
        tier: Tier::Identified,
        identity_hash: [0xBB; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_bob_id, &state, 1000, 0).unwrap();

    (state, alice, bob)
}

fn register_official(state: &GlobalState, official: AccountId) -> GlobalState {
    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    validate_transaction(&tx, state, 1000, 0).unwrap()
}

fn make_swap(
    initiator: AccountId,
    responder: AccountId,
    amount: Amount,
    timeout: BlockHeight,
    nonce: Nonce,
) -> AtomicSwapInit {
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[
            initiator.as_slice(),
            responder.as_slice(),
            &nonce.to_le_bytes(),
        ]
        .concat(),
    );
    let secret = [0x5E; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, &secret);

    AtomicSwapInit {
        swap_id,
        initiator,
        responder,
        amount,
        hash_lock,
        timeout,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn make_claim(swap: &AtomicSwapInit) -> AtomicSwapClaim {
    AtomicSwapClaim {
        swap_id: swap.swap_id,
        secret: [0x5E; 32],
        claimer: swap.initiator,
        original_initiator: swap.initiator,
        original_responder: swap.responder,
        original_amount: swap.amount,
        original_hash_lock: swap.hash_lock,
        original_timeout: swap.timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

#[allow(dead_code)]
fn make_refund(swap: &AtomicSwapInit) -> AtomicSwapRefund {
    AtomicSwapRefund {
        swap_id: swap.swap_id,
        refundee: swap.responder,
        original_initiator: swap.initiator,
        original_responder: swap.responder,
        original_amount: swap.amount,
        original_hash_lock: swap.hash_lock,
        original_timeout: swap.timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

// ===========================================================================
// R8-01 HIGH: STP RegisterContract Accepts Non-Active Status
// ===========================================================================

/// ATTACK: An official registers a contract with Suspended status.
/// This contract satisfies the "has STP contract" check in TriggerInvestigation
/// but the Suspended status means the contract is effectively neutered.
/// The official appears compliant (has a registered contract) but cannot
/// actually be held accountable because their contract isn't active.
///
/// FIX: RegisterContract now requires ContractStatus::Active.
#[test]
fn r8_01_stp_register_suspended_contract_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Governor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Suspended, // Not Active!
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::STPError(_))),
        "R8-01 FAILED: Suspended contract accepted, got {:?}",
        result
    );
}

/// ATTACK: An official registers a contract with Terminated status.
/// Same vector as Suspended -- the official has a "contract" but it's dead on arrival.
///
/// FIX: RegisterContract now requires ContractStatus::Active.
#[test]
fn r8_01_stp_register_terminated_contract_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Senator".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Terminated, // Not Active!
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::STPError(_))),
        "R8-01 FAILED: Terminated contract accepted, got {:?}",
        result
    );
}

/// VALID: Active status is still accepted (regression check).
#[test]
fn r8_01_stp_register_active_contract_accepted() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let state = register_official(&state, official);
    assert!(
        state.get_stp_record(&official).is_some(),
        "R8-01 regression: Active contract should be accepted"
    );
}

// ===========================================================================
// R8-02 HIGH: Identity Registration Accepts ZERO_HASH Identity Hash
// ===========================================================================

/// ATTACK: Register an identity with identity_hash = ZERO_HASH (all zeros).
/// ZERO_HASH is the system sentinel for "not set". Registering with it creates
/// a collision risk -- any account that hasn't set its identity hash effectively
/// shares the same identity_hash, breaking the uniqueness assumption.
/// An attacker could exploit this to claim identity-based privileges using
/// a trivially guessable hash.
///
/// FIX: validate_identity_register now rejects ZERO_HASH identity_hash.
#[test]
fn r8_02_identity_register_zero_hash_rejected() {
    let state = GlobalState::genesis();
    let attacker = [0xEE; 32];

    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: attacker,
        tier: Tier::Identified,
        identity_hash: ZERO_HASH, // All zeros!
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::InvalidEncoding(_))),
        "R8-02 FAILED: ZERO_HASH identity accepted, got {:?}",
        result
    );
}

/// VALID: Non-zero identity hash is still accepted (regression check).
#[test]
fn r8_02_identity_register_nonzero_hash_accepted() {
    let state = GlobalState::genesis();
    let user = [0x01; 32];

    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: user,
        tier: Tier::Identified,
        identity_hash: [0xAA; 32], // non-zero
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R8-02 regression: non-zero identity hash should be accepted, got {:?}",
        result
    );
}

// ===========================================================================
// R8-03 HIGH: Block Validation â€” Parent Hash, Timestamp, Height Gaps
// ===========================================================================

/// ATTACK: A block claims height 5 after a genesis block (height 0).
/// Without validation, this creates a gap in the chain that could be exploited
/// to skip blocks containing unfavorable transactions.
///
/// FIX: Block::validate_against_parent checks height = parent.height + 1.
#[test]
fn r8_03_block_height_gap_rejected() {
    let genesis = Block::genesis([0xAA; 32], 1000);

    // Manually construct a block with height 5 (should be 1)
    let bad_header = BlockHeader {
        height: 5, // Gap!
        timestamp: 2000,
        prev_block_hash: genesis.header.block_hash(),
        state_root: [0xBB; 32],
        transactions_root: ZERO_HASH,
        tx_count: 0,
    };
    let bad_block = Block {
        header: bad_header,
        transactions: vec![],
    };
    let result = bad_block.validate_against_parent(&genesis.header);
    assert!(
        result.is_err(),
        "R8-03 FAILED: block with height gap accepted"
    );
    let err_msg = format!("{}", result.unwrap_err());
    assert!(
        err_msg.contains("height gap"),
        "R8-03: error should mention height gap, got: {}",
        err_msg
    );
}

/// ATTACK: A block has the wrong prev_block_hash (does not chain to parent).
/// This breaks the hash chain, allowing insertion of blocks from a fork.
///
/// FIX: Block::validate_against_parent checks prev_block_hash == parent.block_hash().
#[test]
fn r8_03_block_parent_hash_mismatch_rejected() {
    let genesis = Block::genesis([0xAA; 32], 1000);

    let bad_header = BlockHeader {
        height: 1,
        timestamp: 2000,
        prev_block_hash: [0xFF; 32], // Wrong parent hash!
        state_root: [0xBB; 32],
        transactions_root: ZERO_HASH,
        tx_count: 0,
    };
    let bad_block = Block {
        header: bad_header,
        transactions: vec![],
    };
    let result = bad_block.validate_against_parent(&genesis.header);
    assert!(
        result.is_err(),
        "R8-03 FAILED: block with wrong parent hash accepted"
    );
    let err_msg = format!("{}", result.unwrap_err());
    assert!(
        err_msg.contains("parent hash mismatch"),
        "R8-03: error should mention parent hash, got: {}",
        err_msg
    );
}

/// ATTACK: A block has a timestamp earlier than its parent.
/// Timestamp regression could allow temporal manipulation of deadline-based
/// systems (e.g., STP compliance deadlines, rolling 24h windows).
///
/// FIX: Block::validate_against_parent checks timestamp >= parent.timestamp.
#[test]
fn r8_03_block_timestamp_regression_rejected() {
    let genesis = Block::genesis([0xAA; 32], 5000);

    // Build valid child first to get correct prev_block_hash
    let parent_hash = genesis.header.block_hash();
    let bad_header = BlockHeader {
        height: 1,
        timestamp: 4999, // Before parent's timestamp of 5000!
        prev_block_hash: parent_hash,
        state_root: [0xBB; 32],
        transactions_root: ZERO_HASH,
        tx_count: 0,
    };
    let bad_block = Block {
        header: bad_header,
        transactions: vec![],
    };
    let result = bad_block.validate_against_parent(&genesis.header);
    assert!(
        matches!(result, Err(ChainError::InvalidTimestamp)),
        "R8-03 FAILED: block with timestamp regression accepted, got {:?}",
        result
    );
}

/// ATTACK: A block claims tx_count=0 but contains transactions.
/// This could hide transactions from light clients that only verify headers.
///
/// FIX: Block::validate_against_parent checks tx_count == transactions.len().
#[test]
fn r8_03_block_tx_count_mismatch_rejected() {
    let genesis = Block::genesis([0xAA; 32], 1000);

    // Create a valid block with transactions using try_new, then tamper with tx_count
    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: [0x01; 32],
        tier: Tier::Anonymous,
        identity_hash: [0xCC; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let mut block = Block::try_new(&genesis.header, vec![tx], [0xBB; 32], 2000).unwrap();
    assert_eq!(block.header.tx_count, 1);

    // Tamper: set tx_count to 0
    block.header.tx_count = 0;
    let result = block.validate_against_parent(&genesis.header);
    assert!(
        result.is_err(),
        "R8-03 FAILED: block with tx_count mismatch accepted"
    );
    let err_msg = format!("{}", result.unwrap_err());
    assert!(
        err_msg.contains("tx_count mismatch"),
        "R8-03: error should mention tx_count, got: {}",
        err_msg
    );
}

/// ATTACK: A block has tampered transactions_root that does not match actual transactions.
///
/// FIX: Block::validate_against_parent calls verify_transactions_root.
#[test]
fn r8_03_block_transactions_root_mismatch_rejected() {
    let genesis = Block::genesis([0xAA; 32], 1000);
    let mut block = Block::try_new(&genesis.header, vec![], [0xBB; 32], 2000).unwrap();

    // Tamper with transactions_root
    block.header.transactions_root = [0xFF; 32];
    let result = block.validate_against_parent(&genesis.header);
    assert!(
        result.is_err(),
        "R8-03 FAILED: block with tampered transactions_root accepted"
    );
    let err_msg = format!("{}", result.unwrap_err());
    assert!(
        err_msg.contains("transactions_root"),
        "R8-03: error should mention transactions_root, got: {}",
        err_msg
    );
}

/// VALID: A properly constructed child block passes validation.
#[test]
fn r8_03_valid_block_chain_accepted() {
    let genesis = Block::genesis([0xAA; 32], 1000);
    let child = Block::try_new(&genesis.header, vec![], [0xBB; 32], 2000).unwrap();
    let result = child.validate_against_parent(&genesis.header);
    assert!(
        result.is_ok(),
        "R8-03 regression: valid block should pass validation, got {:?}",
        result
    );
}

/// VALID: Timestamp equal to parent is accepted (non-decreasing, not strictly increasing).
#[test]
fn r8_03_block_same_timestamp_accepted() {
    let genesis = Block::genesis([0xAA; 32], 1000);
    let child = Block::try_new(&genesis.header, vec![], [0xBB; 32], 1000).unwrap();
    let result = child.validate_against_parent(&genesis.header);
    assert!(
        result.is_ok(),
        "R8-03: same timestamp as parent should be accepted (non-decreasing), got {:?}",
        result
    );
}

/// Multi-block chain validation: build 5 blocks and validate each against its parent.
#[test]
fn r8_03_multi_block_chain_validation() {
    let genesis = Block::genesis([0xAA; 32], 1000);
    let mut parent = genesis.header.clone();

    for i in 1..=5 {
        let block = Block::try_new(&parent, vec![], [i as u8; 32], 1000 + i * 100).unwrap();
        let result = block.validate_against_parent(&parent);
        assert!(
            result.is_ok(),
            "R8-03: block {} in chain should be valid, got {:?}",
            i,
            result
        );
        assert_eq!(block.header.height, i);
        parent = block.header;
    }
}

// ===========================================================================
// R8-04 HIGH: WalletSync Allows ZERO_HASH (Wallet Deletion via SMT)
// ===========================================================================

/// ATTACK: A user submits WalletSync with new_state_hash = ZERO_HASH.
/// The SMT treats ZERO_HASH as a delete sentinel (see SparseMerkleTree::set).
/// This means the wallet is effectively removed from the chain, allowing
/// an attacker to:
/// - Evade fraud detection (no wallet to freeze/burn)
/// - Bypass balance checks for future transactions
/// - Delete their wallet right before a compliance report is generated
///
/// FIX: validate_wallet_sync rejects ZERO_HASH as new_state_hash.
#[test]
fn r8_04_wallet_sync_zero_hash_rejected() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    let tx = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: ZERO_HASH, // Would delete the wallet!
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::InvalidEncoding(_))),
        "R8-04 FAILED: ZERO_HASH wallet sync accepted (would delete wallet), got {:?}",
        result
    );
}

/// Verify the SMT behavior that motivates this fix: setting to ZERO_HASH deletes.
#[test]
fn r8_04_smt_zero_hash_delete_behavior() {
    let mut state = GlobalState::genesis();
    let account = [0x01; 32];

    // Set a wallet
    state.set_wallet(account, [0xAA; 32]);
    assert!(state.get_wallet(&account).is_some());

    // Setting to ZERO_HASH deletes it
    state.set_wallet(account, ZERO_HASH);
    assert!(
        state.get_wallet(&account).is_none(),
        "R8-04: ZERO_HASH set indeed deletes from SMT (confirming the vulnerability)"
    );
}

/// VALID: Non-zero state hash in WalletSync is still accepted.
#[test]
fn r8_04_wallet_sync_nonzero_hash_accepted() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    let tx = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: [0xCC; 32], // non-zero
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R8-04 regression: non-zero wallet sync should work, got {:?}",
        result
    );
}

// ===========================================================================
// R8-05 MEDIUM: Fraud Submitter == Fraudulent Key (Self-Burn)
// ===========================================================================

/// DOCUMENTED: A user can submit fraud evidence against themselves.
/// This allows a preemptive self-burn: if Alice knows she's about to be
/// caught for fraud, she can burn her own wallet before the legitimate
/// fraud proof is submitted, potentially racing to extract funds first.
///
/// The submitter field is only used for tracking/rewards. The actual fraud
/// detection relies on the evidence (observations), not the submitter identity.
/// A self-burn still destroys the wallet, so it's not a free escape.
#[test]
fn r8_05_fraud_self_burn_documented() {
    let mut state = GlobalState::genesis();
    let fraudster = [0xDE; 32];
    state.set_wallet(fraudster, [0xAA; 32]);

    // Fraudster submits fraud evidence against themselves
    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: fraudster,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: fraudster,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: fraudster,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: fraudster, // Self-burn!
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R8-05 DOCUMENTED: self-burn fraud proof is accepted (wallet destroyed either way)"
    );
    let new_state = result.unwrap();
    assert!(
        new_state.get_wallet(&fraudster).is_none(),
        "R8-05: wallet should be burned on self-submission"
    );
}

// ===========================================================================
// R8-06 MEDIUM: Swap Timeout at u64::MAX (Permanent Fund Lock)
// ===========================================================================

/// DOCUMENTED: A swap with timeout = u64::MAX effectively locks funds permanently.
/// The claim window extends from block 0 to block u64::MAX - 1. The refund
/// requires block_height >= u64::MAX, which is effectively unreachable.
/// If the initiator loses the secret, the funds are permanently locked.
///
/// This is a design choice (no maximum timeout enforced), but users should
/// be aware that extreme timeouts create risk.
#[test]
fn r8_06_swap_timeout_max_documented() {
    let (state, alice, bob) = setup_wallets();

    // Create swap with maximum possible timeout
    let swap = make_swap(alice, bob, 5000, u64::MAX, 0);
    let tx = Transaction::AtomicSwapInit(swap.clone());
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(
        result.is_ok(),
        "R8-06 DOCUMENTED: u64::MAX timeout is accepted"
    );

    let s1 = result.unwrap();

    // Claim still works at any reasonable block height
    let claim_tx = Transaction::AtomicSwapClaim(make_claim(&swap));
    let claim_result = validate_transaction(&claim_tx, &s1, 1000, 1_000_000);
    assert!(
        claim_result.is_ok(),
        "R8-06: claim before u64::MAX should work"
    );
}

/// DOCUMENTED: Refund is unreachable with timeout = u64::MAX.
#[test]
fn r8_06_swap_timeout_max_refund_unreachable() {
    let (state, alice, bob) = setup_wallets();
    let swap = make_swap(alice, bob, 5000, u64::MAX, 0);

    let tx = Transaction::AtomicSwapInit(swap.clone());
    let s1 = validate_transaction(&tx, &state, 1000, 50).unwrap();

    // Refund at a very high block height -- still below u64::MAX
    let refund = make_refund(&swap);
    let refund_tx = Transaction::AtomicSwapRefund(refund);
    let result = validate_transaction(&refund_tx, &s1, 1000, u64::MAX - 1);
    assert!(
        matches!(result, Err(ChainError::SwapNotExpired)),
        "R8-06 DOCUMENTED: refund at u64::MAX-1 is still not expired, got {:?}",
        result
    );
}

// ===========================================================================
// R8-07 MEDIUM: Block Header Deserialization Allows Forged tx_count
// ===========================================================================

/// DOCUMENTED: BlockHeader::from_bytes allows any tx_count value.
/// A malicious peer could serialize a header with tx_count=100 but the
/// actual Block contains 0 transactions. Without validate_against_parent,
/// this mismatch goes undetected.
///
/// The fix via validate_against_parent catches this post-deserialization.
#[test]
fn r8_07_deserialized_header_forged_tx_count() {
    let genesis = Block::genesis([0xAA; 32], 1000);

    // Build a valid header via to_bytes
    let valid_child = Block::try_new(&genesis.header, vec![], [0xBB; 32], 2000).unwrap();
    let mut header_bytes = valid_child.header.to_bytes();

    // Tamper with the tx_count field (last 4 bytes: offset 112-116)
    // Set tx_count to 42 instead of 0
    header_bytes[112..116].copy_from_slice(&42u32.to_le_bytes());

    // Deserialize tampered header -- succeeds (no validation in from_bytes)
    let tampered_header = BlockHeader::from_bytes(&header_bytes).unwrap();
    assert_eq!(tampered_header.tx_count, 42);

    // But validate_against_parent catches the mismatch
    let block_with_tampered_header = Block {
        header: tampered_header,
        transactions: vec![], // 0 transactions, but header says 42
    };
    let result = block_with_tampered_header.validate_against_parent(&genesis.header);
    assert!(
        result.is_err(),
        "R8-07: forged tx_count in deserialized header should be caught by validation"
    );
}

// ===========================================================================
// R8-08 MEDIUM: AppStateUpdate app_id in Shared SMT Namespace
// ===========================================================================

/// DOCUMENTED: The applications SMT uses app_id directly as the key.
/// If app_id happens to equal an account_id, the app state doesn't collide
/// with wallets (different SMT subtree), but two different app_ids that hash
/// to the same value would collide within the applications subtree.
///
/// More importantly, there's no binding between the app_id and the account_id.
/// Account A could update app state for app_id X, then Account B could
/// overwrite it with a different state for the same app_id X.
#[test]
fn r8_08_app_state_cross_account_overwrite_documented() {
    let (state, alice, bob) = setup_wallets_with_identities();
    let app_id = [0xA0; 32];

    // Alice updates app state
    let tx_alice = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: [0x11; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let s1 = validate_transaction(&tx_alice, &state, 1000, 0).unwrap();
    assert_eq!(s1.get_app_state(&app_id), Some([0x11; 32]));

    // Bob overwrites the SAME app_id with different state
    let tx_bob = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: bob,
        app_id,
        new_state_hash: [0x22; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let s2 = validate_transaction(&tx_bob, &s1, 1000, 0).unwrap();
    assert_eq!(
        s2.get_app_state(&app_id),
        Some([0x22; 32]),
        "R8-08 DOCUMENTED: bob can overwrite alice's app state for same app_id"
    );
}

// ===========================================================================
// R8-09 MEDIUM: CashTransfer Fee Only Checked Against Base Fee
// ===========================================================================

/// DOCUMENTED: The fee field in CashTransfer is only validated to be >= base_fee (100).
/// There's no proportional fee check (e.g., fee as percentage of amount).
/// An attacker can transfer u64::MAX / 2 in value while paying only 100 units fee.
#[test]
fn r8_09_large_transfer_minimum_fee_documented() {
    let (state, alice, bob) = setup_wallets_with_identities();
    let alice_hash = state.get_wallet(&alice).unwrap();

    // Transfer a huge amount with minimum fee
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1_000_000_000, // 100,000 MANA
        fee: 100,              // minimum base fee (0.01 MANA)
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1_000_000_000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R8-09 DOCUMENTED: huge transfer with minimum fee is accepted (no proportional fee)"
    );
}

/// Fee below base_fee is still properly rejected.
#[test]
fn r8_09_fee_below_base_fee_rejected() {
    let (state, alice, bob) = setup_wallets_with_identities();
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 1000,
        fee: 99, // below base_fee of 100
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::ComplianceViolation(_))),
        "R8-09: fee below base should be rejected, got {:?}",
        result
    );
}

// ===========================================================================
// R8-10 LOW: Fee + Amount Overflow Error Semantics
// ===========================================================================

/// DOCUMENTED: When fee + amount overflows u64, the error returned is
/// InsufficientBalance rather than a dedicated ArithmeticOverflow error.
/// The overflow IS caught (via checked_add), but the error message is misleading.
#[test]
fn r8_10_fee_amount_overflow_caught_but_misleading_error() {
    let (state, alice, bob) = setup_wallets_with_identities();
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: u64::MAX,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: u64::MAX,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R8-10: fee + amount overflow should be caught"
    );
    // The error is InsufficientBalance, not a dedicated overflow error
    assert!(
        matches!(result, Err(ChainError::InsufficientBalance { .. })),
        "R8-10 DOCUMENTED: overflow returns InsufficientBalance (misleading), got {:?}",
        result
    );
}

// ===========================================================================
// R8 Compound Attack: Sham Contract + Investigation Resistance
// ===========================================================================

/// Compound attack: An official registers a Suspended contract, then a
/// whistleblower tries to investigate them. The investigation should fail
/// because Suspended contracts shouldn't count as valid for the STP protocol.
///
/// Pre-fix: The investigation target check only verified `get_stp_record(target).is_some()`,
/// which would pass for Suspended/Terminated contracts.
/// Post-fix: Registration of non-Active contracts is blocked, so this chain is impossible.
#[test]
fn r8_compound_sham_contract_investigation_resistance() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    // Try to register Suspended contract -- BLOCKED by R8-01 fix
    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Suspended,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R8 compound: Suspended contract registration blocked"
    );

    // No contract registered, so investigation target check also fails
    let trigger = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: [0x99; 32],
        },
        submitter: [0x01; 32],
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&trigger, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::UnauthorizedSTPAction(_))),
        "R8 compound: investigation of official with no valid contract should fail"
    );
}

// ===========================================================================
// R8 Compound Attack: Wallet Deletion Before Fraud
// ===========================================================================

/// Compound attack: Alice knows she's about to be caught for fraud.
/// She races to WalletSync with ZERO_HASH to delete her wallet, making
/// the subsequent fraud proof's wallet burn a no-op.
///
/// Pre-fix: WalletSync to ZERO_HASH would succeed, deleting the wallet.
/// Post-fix: ZERO_HASH is rejected, so Alice cannot self-delete.
#[test]
fn r8_compound_wallet_deletion_before_fraud_blocked() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    // Alice tries to delete her wallet via WalletSync -- BLOCKED
    let delete_tx = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: ZERO_HASH,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&delete_tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R8 compound: wallet deletion via ZERO_HASH blocked"
    );

    // Wallet still exists for fraud proof
    assert!(
        state.get_wallet(&alice).is_some(),
        "R8 compound: alice's wallet should still exist after blocked deletion"
    );

    // Fraud proof can still burn alice's wallet
    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: alice,
            observation_a: StateObservation {
                observer: [0x01; 32],
                observed_key: alice,
                observed_state_hash: [0xAA; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0x02; 32],
                observed_key: alice,
                observed_state_hash: [0xBB; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::DoubleSpend,
        },
        submitter: [0x03; 32],
        proof: mock_proof(),
    });
    let new_state = validate_transaction(&fraud_tx, &state, 1000, 0).unwrap();
    assert!(
        new_state.get_wallet(&alice).is_none(),
        "R8 compound: fraud proof should successfully burn alice's wallet"
    );
}

// ===========================================================================
// R8 Compound Attack: Identity ZERO_HASH + Tier Escalation
// ===========================================================================

/// Compound attack: Attacker registers identity with ZERO_HASH to get
/// a registered identity (enabling higher tier claims in CashTransfer),
/// then uses the escalated tier to evade compliance reporting.
///
/// Post-fix: ZERO_HASH identity registration is blocked.
#[test]
fn r8_compound_zero_identity_tier_escalation_blocked() {
    let (state, alice, bob) = setup_wallets();

    // Alice tries to register identity with ZERO_HASH -- BLOCKED
    let reg_tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: ZERO_HASH,
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&reg_tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R8 compound: ZERO_HASH identity registration blocked"
    );

    // Without identity, alice must use Anonymous tier (low threshold)
    let alice_hash = state.get_wallet(&alice).unwrap();
    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 5_000_000, // above Anonymous threshold
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Anonymous, // forced to use Anonymous
        sender_identity_hash: ZERO_HASH,
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 5_000_000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R8 compound: anonymous transfer should work, got {:?}",
        result
    );
    let new_state = result.unwrap();
    // Compliance report should be generated (5_000_000 >= Anonymous threshold 1_000_000)
    assert!(
        !new_state.compliance.is_empty(),
        "R8 compound: compliance report should be generated for anonymous sender above threshold"
    );
}

// ===========================================================================
// R8 Compound Attack: Block Chain Fork via Mismatched Parent Hash
// ===========================================================================

/// Compound attack: An attacker builds a parallel chain by constructing
/// blocks with forged parent hashes, attempting to rewrite history.
///
/// FIX: validate_against_parent catches the parent hash mismatch at every step.
#[test]
fn r8_compound_parallel_chain_fork_detected() {
    let genesis = Block::genesis([0xAA; 32], 1000);
    let honest_block1 = Block::try_new(&genesis.header, vec![], [0xBB; 32], 2000).unwrap();

    // Attacker builds a "parallel" block 1 with a different state root
    let attacker_block1 = Block::try_new(&genesis.header, vec![], [0xFF; 32], 2000).unwrap();

    // Both block 1s validate against genesis
    assert!(honest_block1.validate_against_parent(&genesis.header).is_ok());
    assert!(attacker_block1.validate_against_parent(&genesis.header).is_ok());

    // But the attacker's block 2 cannot chain off the honest block 1
    let attacker_block2 = Block::try_new(&attacker_block1.header, vec![], [0xEE; 32], 3000).unwrap();
    let result = attacker_block2.validate_against_parent(&honest_block1.header);
    assert!(
        result.is_err(),
        "R8 compound: attacker's block 2 should not validate against honest block 1"
    );
}

// ===========================================================================
// R8 Regression: All previous fixes still work
// ===========================================================================

/// R7: Tier downgrade without identity still rejected.
#[test]
fn r8_regression_tier_downgrade_without_identity_rejected() {
    let (state, sender, recipient) = setup_wallets();
    let sender_hash = state.get_wallet(&sender).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified, // LIE
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::TierViolation(_))));
}

/// R7: Duplicate STP contract still rejected.
#[test]
fn r8_regression_duplicate_stp_contract_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let state = register_official(&state, official);

    // Try to register again
    let contract = ServiceContract {
        official,
        identity_hash: [0xBB; 32],
        office: "Senator".into(),
        jurisdiction: 840,
        reporting_threshold: u64::MAX,
        staked_amount: 1,
        term_start: 1000,
        term_end: u64::MAX,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::DuplicateSTPContract)));
}

/// R6: Fraud proof conflict type mismatch still rejected.
#[test]
fn r8_regression_conflict_type_mismatch_rejected() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    state.set_wallet(victim, [0xCC; 32]);

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0xBB; 32],
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xCC; 32],
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::StateInconsistency, // WRONG: should be DoubleSpend
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::FraudDetected(_))));
}

/// R5: Nonce overflow still caught.
#[test]
fn r8_regression_nonce_overflow_caught() {
    let (mut state, alice, bob) = setup_wallets_with_identities();
    state.set_nonce(alice, u64::MAX);
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 100,
        fee: 100,
        nonce: u64::MAX,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::NonceOverflow)));
}

/// R5: Backup size limit still enforced.
#[test]
fn r8_regression_backup_size_limit() {
    let (state, sender, _) = setup_wallets();
    let tx = Transaction::BackupStore(BackupStore {
        account_id: sender,
        encrypted_state: vec![0u8; 1_048_577],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::BackupTooLarge { .. })));
}

/// R6: Zero hash_lock in swap still rejected.
#[test]
fn r8_regression_swap_zero_hash_lock() {
    let (state, alice, bob) = setup_wallets();
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), bob.as_slice(), &0u64.to_le_bytes()].concat(),
    );
    let swap = AtomicSwapInit {
        swap_id,
        initiator: alice,
        responder: bob,
        amount: 5000,
        hash_lock: ZERO_HASH,
        timeout: 100,
        disclosure_root: None,
        execution_proof: None,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    };
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(matches!(result, Err(ChainError::InvalidPreimage)));
}

/// R7: Cross-official data injection still rejected.
#[test]
fn r8_regression_cross_official_data_injection() {
    let state = GlobalState::genesis();
    let official_a = [0x10; 32];
    let official_b = [0x20; 32];

    let state = register_official(&state, official_a);
    let state = register_official(&state, official_b);

    let pool_id = [0x99; 32];
    let trigger = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official_a,
            pool_id,
        },
        submitter: [0x30; 32],
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger, &state, 1000, 0).unwrap();

    // B tries to provide data for A
    let provide = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: [0xDD; 32],
        },
        submitter: official_b,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::UnauthorizedSTPAction(_))));
}
