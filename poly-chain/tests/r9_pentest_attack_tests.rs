//! Round 9 Pentest Attack Tests
//!
//! Tests for vulnerabilities found in Round 9 security audit.
//! Each test verifies a specific attack vector is properly mitigated.
//!
//! Findings summary:
//! - R9-01 HIGH:   AppStateUpdate allows ZERO_HASH new_state_hash (app state deletion via SMT sentinel)
//! - R9-02 HIGH:   BackupStore allows ZERO_HASH state_hash (backup deletion via SMT sentinel)
//! - R9-03 HIGH:   BackupRestore allows ZERO_HASH backup_hash (wallet deletion via SMT sentinel)
//! - R9-04 HIGH:   STP ProvideData with ZERO_HASH data_hash kills investigation (SMT deletion)
//! - R9-05 HIGH:   Swap init zero amount returned InsufficientBalance, not ZeroAmount (inconsistent)
//! - R9-06 MEDIUM: Identity register and STP RegisterContract accept unbounded office strings
//! - R9-07 MEDIUM: STP signing message used unwrap_or_default (silent collision on serialization failure)
//! - R9-08 MEDIUM: BlockHeader::from_bytes accepted trailing garbage (non-canonical deserialization)
//! - R9-09 MEDIUM: Swap claim credits claimer who may have no wallet or identity (phantom wallet creation)
//! - R9-10 LOW:    STP ProvideData overwrites investigation hash with data_hash (record loss)

use poly_chain::prelude::*;
use poly_chain::block::BlockHeader;
use poly_chain::fraud::{ConflictType, FraudEvidence, StateObservation};
use poly_chain::identity::Tier;
use poly_chain::stp::{ContractStatus, ServiceContract};
use poly_chain::state::GlobalState;
use poly_chain::transaction::{
    AtomicSwapInit, AtomicSwapClaim, AppStateUpdate, BackupRestore, BackupStore,
    CashTransfer, FraudProofTx, IdentityRegister, STPAction, STPActionTx, WalletSync,
};
use poly_chain::validation::validate_transaction;
use poly_chain::wallet::WalletState;
use poly_verified::types::{PrivacyMode, VerifiedProof, ZERO_HASH};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn mock_proof() -> VerifiedProof {
    VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    }
}

fn setup_wallets() -> (GlobalState, AccountId, AccountId) {
    let mut state = GlobalState::genesis();
    let alice = [0xA1; 32];
    let bob = [0xB0; 32];

    let alice_wallet = WalletState::new([0xAA; 32], Tier::Identified, 1_000_000);
    let bob_wallet = WalletState::new([0xBB; 32], Tier::Identified, 500_000);

    state.set_wallet(alice, alice_wallet.state_hash());
    state.set_wallet(bob, bob_wallet.state_hash());

    (state, alice, bob)
}

fn setup_wallets_with_identities() -> (GlobalState, AccountId, AccountId) {
    let (state, alice, bob) = setup_wallets();

    let tx_alice_id = Transaction::IdentityRegister(IdentityRegister {
        account_id: alice,
        tier: Tier::Identified,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_alice_id, &state, 1000, 0).unwrap();

    let tx_bob_id = Transaction::IdentityRegister(IdentityRegister {
        account_id: bob,
        tier: Tier::Identified,
        identity_hash: [0xBB; 32],
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_bob_id, &state, 1000, 0).unwrap();

    (state, alice, bob)
}

fn register_official(state: &GlobalState, official: AccountId) -> GlobalState {
    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: "Mayor".into(),
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    validate_transaction(&tx, state, 1000, 0).unwrap()
}

fn make_swap(
    initiator: AccountId,
    responder: AccountId,
    amount: Amount,
    timeout: BlockHeight,
    nonce: Nonce,
) -> AtomicSwapInit {
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[
            initiator.as_slice(),
            responder.as_slice(),
            &nonce.to_le_bytes(),
        ]
        .concat(),
    );
    let secret = [0x5E; 32];
    let hash_lock = hash_with_domain(DOMAIN_SWAP, &secret);

    AtomicSwapInit {
        swap_id,
        initiator,
        responder,
        amount,
        hash_lock,
        timeout,
        disclosure_root: None,
        execution_proof: None,
        nonce,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

fn make_claim(swap: &AtomicSwapInit) -> AtomicSwapClaim {
    AtomicSwapClaim {
        swap_id: swap.swap_id,
        secret: [0x5E; 32],
        claimer: swap.initiator,
        original_initiator: swap.initiator,
        original_responder: swap.responder,
        original_amount: swap.amount,
        original_hash_lock: swap.hash_lock,
        original_timeout: swap.timeout,
        proof: mock_proof(),
        signature: [0u8; 64],
    }
}

// ===========================================================================
// R9-01 HIGH: AppStateUpdate Allows ZERO_HASH new_state_hash
// ===========================================================================

/// ATTACK: An attacker submits AppStateUpdate with new_state_hash = ZERO_HASH.
/// The SMT treats ZERO_HASH as a delete sentinel (SparseMerkleTree::set deletes
/// on ZERO_HASH). This would allow any user to delete any app state entry they
/// can write to, destroying other users' data.
///
/// FIX: validate_app_state_update now rejects ZERO_HASH as new_state_hash.
#[test]
fn r9_01_app_state_update_zero_hash_rejected() {
    let (state, alice, _bob) = setup_wallets_with_identities();
    let app_id = [0xA0; 32];

    // First, create some app state
    let tx_create = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: [0x11; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_create, &state, 1000, 0).unwrap();
    assert_eq!(state.get_app_state(&app_id), Some([0x11; 32]));

    // Now try to delete it with ZERO_HASH
    let tx_delete = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: ZERO_HASH, // Would delete the app state!
        nonce: 1,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx_delete, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::InvalidEncoding(_))),
        "R9-01 FAILED: ZERO_HASH app state update accepted (would delete app state), got {:?}",
        result
    );
}

/// Confirm that the SMT would indeed delete on ZERO_HASH (motivation for the fix).
#[test]
fn r9_01_smt_app_state_zero_hash_delete_behavior() {
    let mut state = GlobalState::genesis();
    let app_id = [0xA0; 32];

    state.set_app_state(app_id, [0x11; 32]);
    assert!(state.get_app_state(&app_id).is_some());

    // Setting to ZERO_HASH deletes it
    state.set_app_state(app_id, ZERO_HASH);
    assert!(
        state.get_app_state(&app_id).is_none(),
        "R9-01: ZERO_HASH set indeed deletes from applications SMT"
    );
}

/// VALID: Non-zero new_state_hash in AppStateUpdate is still accepted.
#[test]
fn r9_01_app_state_update_nonzero_hash_accepted() {
    let (state, alice, _bob) = setup_wallets_with_identities();
    let app_id = [0xA0; 32];

    let tx = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: [0xDD; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R9-01 regression: non-zero app state update should work, got {:?}",
        result
    );
}

// ===========================================================================
// R9-02 HIGH: BackupStore Allows ZERO_HASH state_hash
// ===========================================================================

/// ATTACK: A user submits BackupStore with state_hash = ZERO_HASH.
/// The backups SMT treats ZERO_HASH as a delete sentinel. This means the backup
/// entry is removed, so a subsequent BackupRestore will fail with AccountNotFound.
/// An attacker could use this to destroy their own backup right before a fraud
/// investigation, preventing recovery of evidence.
///
/// FIX: validate_backup_store now rejects ZERO_HASH as state_hash.
#[test]
fn r9_02_backup_store_zero_hash_rejected() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    let tx = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3, 4],
        state_hash: ZERO_HASH, // Would delete the backup!
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::InvalidEncoding(_))),
        "R9-02 FAILED: ZERO_HASH backup state_hash accepted (would delete backup), got {:?}",
        result
    );
}

/// Confirm the SMT would indeed delete on ZERO_HASH (motivation for fix).
#[test]
fn r9_02_smt_backup_zero_hash_delete_behavior() {
    let mut state = GlobalState::genesis();
    let account = [0x01; 32];

    state.set_backup(account, [0xCC; 32]);
    assert!(state.get_backup(&account).is_some());

    state.set_backup(account, ZERO_HASH);
    assert!(
        state.get_backup(&account).is_none(),
        "R9-02: ZERO_HASH set indeed deletes from backups SMT"
    );
}

/// VALID: Non-zero state_hash in BackupStore is still accepted.
#[test]
fn r9_02_backup_store_nonzero_hash_accepted() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    let tx = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3, 4],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R9-02 regression: non-zero backup state_hash should work, got {:?}",
        result
    );
}

// ===========================================================================
// R9-03 HIGH: BackupRestore Allows ZERO_HASH backup_hash (Wallet Deletion)
// ===========================================================================

/// ATTACK: A user stores a valid backup, then submits BackupRestore with
/// backup_hash = ZERO_HASH. The restore sets the wallet to ZERO_HASH, which
/// the SMT treats as a delete sentinel. The wallet is effectively destroyed,
/// allowing fraud evasion (no wallet to freeze/burn).
///
/// FIX: validate_backup_restore now rejects ZERO_HASH as backup_hash.
#[test]
fn r9_03_backup_restore_zero_hash_rejected() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    // First, store a valid backup
    let tx_store = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3, 4],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_store, &state, 1000, 0).unwrap();
    assert!(state.get_backup(&alice).is_some());

    // Now attempt restore with ZERO_HASH — should be blocked
    let tx_restore = Transaction::BackupRestore(BackupRestore {
        account_id: alice,
        backup_hash: ZERO_HASH, // Would delete the wallet!
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx_restore, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::InvalidEncoding(_))),
        "R9-03 FAILED: ZERO_HASH backup restore accepted (would delete wallet), got {:?}",
        result
    );
}

/// VALID: Non-zero backup_hash restore is still accepted.
#[test]
fn r9_03_backup_restore_nonzero_hash_accepted() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    // Store a backup
    let tx_store = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![1, 2, 3, 4],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_store, &state, 1000, 0).unwrap();

    // Restore with non-zero hash
    let tx_restore = Transaction::BackupRestore(BackupRestore {
        account_id: alice,
        backup_hash: [0xDD; 32], // valid non-zero
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx_restore, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R9-03 regression: non-zero backup restore should work, got {:?}",
        result
    );
}

// ===========================================================================
// R9-04 HIGH: STP ProvideData with ZERO_HASH Kills Investigation
// ===========================================================================

/// ATTACK: An official under investigation provides data_hash = ZERO_HASH.
/// The ProvideData handler does: `new_state.set_stp_record(*investigation_id, *data_hash)`.
/// Since ZERO_HASH is the SMT delete sentinel, this deletes the investigation record
/// from the STP SMT. A subsequent CheckDeadline would fail with "investigation not found",
/// and the official escapes accountability entirely.
///
/// FIX: validate_stp_action now rejects ZERO_HASH as data_hash in ProvideData.
#[test]
fn r9_04_stp_provide_data_zero_hash_kills_investigation() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x30; 32];

    // Register official
    let state = register_official(&state, official);

    // Trigger investigation
    let pool_id = [0x99; 32];
    let trigger = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger, &state, 1000, 0).unwrap();

    // Verify investigation exists
    assert!(
        state.get_stp_record(&pool_id).is_some(),
        "Investigation should exist"
    );

    // Official provides data with ZERO_HASH — should be blocked
    let provide = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: ZERO_HASH, // Would delete the investigation!
        },
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::STPError(_))),
        "R9-04 FAILED: ZERO_HASH data_hash accepted (would kill investigation), got {:?}",
        result
    );
}

/// Confirm the investigation would be deleted without the fix.
#[test]
fn r9_04_smt_stp_zero_hash_delete_behavior() {
    let mut state = GlobalState::genesis();
    let pool_id = [0x99; 32];

    state.set_stp_record(pool_id, [0x11; 32]);
    assert!(state.get_stp_record(&pool_id).is_some());

    // Setting to ZERO_HASH deletes the record
    state.set_stp_record(pool_id, ZERO_HASH);
    assert!(
        state.get_stp_record(&pool_id).is_none(),
        "R9-04: ZERO_HASH set indeed deletes from STP SMT"
    );
}

/// VALID: Non-zero data_hash ProvideData is still accepted.
#[test]
fn r9_04_stp_provide_data_nonzero_accepted() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x30; 32];

    let state = register_official(&state, official);

    let pool_id = [0x99; 32];
    let trigger = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger, &state, 1000, 0).unwrap();

    let provide = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: [0xDD; 32], // non-zero
        },
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R9-04 regression: non-zero data_hash ProvideData should work, got {:?}",
        result
    );
}

// ===========================================================================
// R9-05 HIGH: Swap Init Zero Amount Returns Wrong Error Type
// ===========================================================================

/// ATTACK: Swap init with amount=0 returned InsufficientBalance{needed:1, available:0}
/// instead of ZeroAmount. This made it inconsistent with CashTransfer (which uses
/// ZeroAmount) and could confuse error-handling code that treats InsufficientBalance
/// as a recoverable balance issue rather than a malformed transaction.
///
/// FIX: Now returns ChainError::ZeroAmount for consistency.
#[test]
fn r9_05_swap_init_zero_amount_returns_zero_amount_error() {
    let (state, alice, bob) = setup_wallets();
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), bob.as_slice(), &0u64.to_le_bytes()].concat(),
    );
    let hash_lock = hash_with_domain(DOMAIN_SWAP, &[0x5E; 32]);

    let swap = AtomicSwapInit {
        swap_id,
        initiator: alice,
        responder: bob,
        amount: 0, // Zero amount!
        hash_lock,
        timeout: 100,
        disclosure_root: None,
        execution_proof: None,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    };
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(
        matches!(result, Err(ChainError::ZeroAmount)),
        "R9-05 FAILED: zero-amount swap should return ZeroAmount, got {:?}",
        result
    );
}

/// VALID: Non-zero amount swaps still work fine.
#[test]
fn r9_05_swap_init_nonzero_amount_accepted() {
    let (state, alice, bob) = setup_wallets();
    let swap = make_swap(alice, bob, 5000, 100, 0);
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(
        result.is_ok(),
        "R9-05 regression: non-zero amount swap should work, got {:?}",
        result
    );
}

// ===========================================================================
// R9-06 MEDIUM: Unbounded Office String in Identity & STP
// ===========================================================================

/// ATTACK: Register an identity with a multi-megabyte office string.
/// The unbounded string causes excessive memory use during serialization
/// (to_bytes, serde_json, signing messages, identity record hash computation).
/// A sustained attack with many such transactions could exhaust validator memory.
///
/// FIX: validate_identity_register now limits office length to 1024 bytes.
#[test]
fn r9_06_identity_register_oversized_office_rejected() {
    let state = GlobalState::genesis();
    let attacker = [0xEE; 32];

    let huge_office = "X".repeat(2048); // 2KB, exceeds 1024 limit
    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: attacker,
        tier: Tier::PublicOfficial,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        is_public_official: true,
        office: Some(huge_office),
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::InvalidEncoding(_))),
        "R9-06 FAILED: oversized office string accepted in identity register, got {:?}",
        result
    );
}

/// ATTACK: Register an STP contract with a multi-megabyte office string.
///
/// FIX: validate_stp_action RegisterContract now limits office length to 1024 bytes.
#[test]
fn r9_06_stp_register_oversized_office_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let huge_office = "Y".repeat(2048); // 2KB, exceeds 1024 limit
    let contract = ServiceContract {
        official,
        identity_hash: [0xAA; 32],
        office: huge_office,
        jurisdiction: 840,
        reporting_threshold: 50_000_000,
        staked_amount: 10_000_000,
        term_start: 1000,
        term_end: 100_000,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R9-06 FAILED: oversized office string accepted in STP contract, got {:?}",
        result
    );
}

/// VALID: Office strings within limits are still accepted.
#[test]
fn r9_06_identity_register_normal_office_accepted() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];

    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: official,
        tier: Tier::PublicOfficial,
        identity_hash: [0xAA; 32],
        jurisdiction: 840,
        is_public_official: true,
        office: Some("Minister of Finance".to_string()), // normal length
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R9-06 regression: normal office string should be accepted, got {:?}",
        result
    );
}

/// VALID: Office at exactly 1024 bytes is accepted.
#[test]
fn r9_06_identity_register_office_at_limit_accepted() {
    let state = GlobalState::genesis();
    let user = [0x20; 32];

    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: user,
        tier: Tier::PublicOfficial,
        identity_hash: [0xBB; 32],
        jurisdiction: 840,
        is_public_official: true,
        office: Some("A".repeat(1024)), // exactly at limit
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        result.is_ok(),
        "R9-06: office at exactly 1024 bytes should be accepted, got {:?}",
        result
    );
}

/// Office at 1025 bytes is rejected (one over limit).
#[test]
fn r9_06_identity_register_office_one_over_limit_rejected() {
    let state = GlobalState::genesis();
    let user = [0x30; 32];

    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: user,
        tier: Tier::PublicOfficial,
        identity_hash: [0xCC; 32],
        jurisdiction: 840,
        is_public_official: true,
        office: Some("B".repeat(1025)), // one over limit
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(
        matches!(result, Err(ChainError::InvalidEncoding(_))),
        "R9-06: office at 1025 bytes should be rejected, got {:?}",
        result
    );
}

// ===========================================================================
// R9-07 MEDIUM: STP Signing Message unwrap_or_default
// ===========================================================================

/// The STP signing message previously used `unwrap_or_default()` for action
/// serialization. If the serialization failed (which shouldn't happen for known
/// enum variants, but could in theory), the signing message would have an empty
/// suffix, creating a collision between any two unserializable actions.
///
/// FIX: Now uses `expect()` to panic loudly instead of silently degrading.
/// This test verifies that the signing message includes the action data.
#[test]
fn r9_07_stp_signing_messages_distinct_for_different_actions() {
    // Create two STP transactions with different actions
    let official = [0x10; 32];

    let tx1 = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id: [0x99; 32],
        },
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    let tx2 = Transaction::STPAction(STPActionTx {
        action: STPAction::CheckDeadline {
            investigation_id: [0x99; 32],
        },
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });

    // Both transactions have the same submitter and timestamp.
    // The signing messages must be different because the actions differ.
    let hash1 = tx1.tx_hash();
    let hash2 = tx2.tx_hash();
    assert_ne!(
        hash1, hash2,
        "R9-07: different STP actions must produce different tx hashes"
    );
}

// ===========================================================================
// R9-08 MEDIUM: BlockHeader::from_bytes Accepts Trailing Garbage
// ===========================================================================

/// ATTACK: An attacker sends a block header with 120 bytes (4 bytes of garbage
/// appended). The `from_bytes` method only checked `data.len() < 116` and would
/// silently ignore the extra bytes. This creates non-canonical serializations:
/// the same logical header can have multiple byte representations.
///
/// This matters because block_hash is computed from the canonical `to_bytes()`
/// output (116 bytes), but a receiver who deserializes a 120-byte header and
/// then re-serializes it would get a different byte sequence than what was sent.
///
/// FIX: from_bytes now requires exactly 116 bytes.
#[test]
fn r9_08_block_header_trailing_garbage_rejected() {
    let genesis = poly_chain::block::Block::genesis([0xAA; 32], 1000);
    let mut bytes = genesis.header.to_bytes();
    assert_eq!(bytes.len(), 116);

    // Append garbage bytes
    bytes.extend_from_slice(&[0xFF, 0xFF, 0xFF, 0xFF]);
    assert_eq!(bytes.len(), 120);

    let result = BlockHeader::from_bytes(&bytes);
    assert!(
        result.is_err(),
        "R9-08 FAILED: block header with trailing garbage accepted, got {:?}",
        result.unwrap()
    );
    let err_msg = format!("{}", result.unwrap_err());
    assert!(
        err_msg.contains("too long"),
        "R9-08: error should mention 'too long', got: {}",
        err_msg
    );
}

/// VALID: Exact 116-byte header still accepted.
#[test]
fn r9_08_block_header_exact_length_accepted() {
    let genesis = poly_chain::block::Block::genesis([0xAA; 32], 1000);
    let bytes = genesis.header.to_bytes();
    assert_eq!(bytes.len(), 116);

    let result = BlockHeader::from_bytes(&bytes);
    assert!(
        result.is_ok(),
        "R9-08 regression: 116-byte header should be accepted, got {:?}",
        result
    );
}

/// Header roundtrip still works (regression check).
#[test]
fn r9_08_block_header_roundtrip_intact() {
    let genesis = poly_chain::block::Block::genesis([0xAA; 32], 1000);
    let bytes = genesis.header.to_bytes();
    let decoded = BlockHeader::from_bytes(&bytes).unwrap();
    assert_eq!(decoded.height, genesis.header.height);
    assert_eq!(decoded.timestamp, genesis.header.timestamp);
    assert_eq!(decoded.state_root, genesis.header.state_root);
    assert_eq!(decoded.block_hash(), genesis.header.block_hash());
}

// ===========================================================================
// R9-09 MEDIUM: Swap Claim Creates Phantom Wallet
// ===========================================================================

/// DOCUMENTED: When a swap is claimed, the claimer (initiator) gets a new
/// wallet hash computed from their current wallet hash. If the claimer has NO
/// existing wallet, `claimer_current` is ZERO_HASH (line: `state.get_wallet(&tx.claimer).unwrap_or(ZERO_HASH)`).
/// The new wallet hash is computed from (claimer, ZERO_HASH, swap_id), and since
/// this is non-zero, a wallet is created for an account that may have no
/// registered identity, no KYC, and no compliance tracking.
///
/// This is a known design choice (the claimer is the initiator, who is a
/// legitimate party to the swap), but it means swap claims bypass the normal
/// wallet creation path (which requires IdentityRegister).
#[test]
fn r9_09_swap_claim_creates_wallet_for_no_identity_account() {
    let (state, _alice, bob) = setup_wallets();
    let claimer = [0xC1; 32]; // Has no wallet, no identity

    // Bob creates a swap where claimer is the initiator
    let swap = make_swap(claimer, bob, 5000, 100, 0);
    let tx_init = Transaction::AtomicSwapInit(swap.clone());
    let state = validate_transaction(&tx_init, &state, 1000, 50).unwrap();

    // claimer has no wallet before claim
    // Note: get_wallet for claimer may return Some because swap_init doesn't create
    // a wallet for initiator. Let's check:
    let claimer_wallet_before = state.get_wallet(&claimer);

    // Claim the swap
    let claim = make_claim(&swap);
    let tx_claim = Transaction::AtomicSwapClaim(claim);
    let new_state = validate_transaction(&tx_claim, &state, 1000, 75).unwrap();

    // After claim, claimer has a wallet (even though they have no identity)
    assert!(
        new_state.get_wallet(&claimer).is_some(),
        "R9-09 DOCUMENTED: swap claim creates a wallet for claimer with no identity"
    );
    // The wallet was created from thin air (or changed if it existed)
    if claimer_wallet_before.is_none() {
        // Wallet created without IdentityRegister
        assert!(
            new_state.get_identity(&claimer).is_none(),
            "R9-09 DOCUMENTED: claimer has no registered identity despite having a wallet"
        );
    }
}

// ===========================================================================
// R9-10 LOW: STP ProvideData Overwrites Investigation Hash
// ===========================================================================

/// DOCUMENTED: When ProvideData succeeds, it does:
///   `new_state.set_stp_record(*investigation_id, *data_hash)`
/// This overwrites the investigation record hash with the provided data_hash.
/// After this, the investigation record (deadlines, status) is lost from the SMT.
/// A subsequent CheckDeadline will load the data_hash (which is NOT an investigation
/// hash) and try to interpret it, which could lead to incorrect enforcement actions.
///
/// This is a known Phase 1 limitation — the STP SMT stores only a single hash per
/// key, not a full record. Proper fix requires a structured record storage.
#[test]
fn r9_10_stp_provide_data_overwrites_investigation_record() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x30; 32];

    let state = register_official(&state, official);

    let pool_id = [0x99; 32];
    let trigger = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger, &state, 1000, 0).unwrap();

    // Record the investigation hash before ProvideData
    let investigation_hash_before = state.get_stp_record(&pool_id).unwrap();

    // Official provides data (non-zero)
    let provide = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: [0xDD; 32],
        },
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let new_state = validate_transaction(&provide, &state, 1000, 0).unwrap();

    // The investigation_id now maps to data_hash, NOT the original investigation hash
    let record_after = new_state.get_stp_record(&pool_id).unwrap();
    assert_ne!(
        record_after, investigation_hash_before,
        "R9-10 DOCUMENTED: ProvideData overwrites the investigation hash with data_hash"
    );
    assert_eq!(
        record_after, [0xDD; 32],
        "R9-10 DOCUMENTED: investigation_id now maps to data_hash instead of investigation record"
    );
}

// ===========================================================================
// R9 Compound Attack: Backup Delete + Fraud Evasion
// ===========================================================================

/// Compound attack: Alice stores a backup, then tries to delete it by storing
/// a backup with ZERO_HASH state_hash, then submits a fraud proof against
/// herself to burn her wallet. Without the R9-02 fix, Alice could delete her
/// backup before the fraud proof, making wallet recovery impossible.
#[test]
fn r9_compound_backup_delete_before_fraud_blocked() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    // Store a valid backup
    let tx_store = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![0xAB; 100],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_store, &state, 1000, 0).unwrap();
    assert!(state.get_backup(&alice).is_some(), "backup should exist");

    // Alice tries to delete her backup with ZERO_HASH — BLOCKED
    let tx_delete = Transaction::BackupStore(BackupStore {
        account_id: alice,
        encrypted_state: vec![],
        state_hash: ZERO_HASH,
        nonce: 1,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx_delete, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R9 compound: backup deletion via ZERO_HASH should be blocked"
    );

    // Backup still exists for recovery
    assert!(
        state.get_backup(&alice).is_some(),
        "R9 compound: backup should still exist after blocked deletion"
    );
}

// ===========================================================================
// R9 Compound Attack: Investigation Kill via ProvideData + CheckDeadline
// ===========================================================================

/// Compound attack: An official under investigation provides ZERO_HASH as data.
/// Without the R9-04 fix, this would delete the investigation from the STP SMT.
/// A subsequent CheckDeadline would fail because the investigation doesn't exist
/// anymore, and the official escapes all accountability.
#[test]
fn r9_compound_investigation_kill_then_deadline_check() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let anyone = [0x30; 32];

    let state = register_official(&state, official);

    let pool_id = [0x99; 32];
    let trigger = Transaction::STPAction(STPActionTx {
        action: STPAction::TriggerInvestigation {
            target: official,
            pool_id,
        },
        submitter: anyone,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&trigger, &state, 1000, 0).unwrap();

    // Step 1: Official tries to kill investigation with ZERO_HASH — BLOCKED
    let provide_zero = Transaction::STPAction(STPActionTx {
        action: STPAction::ProvideData {
            investigation_id: pool_id,
            data_hash: ZERO_HASH,
        },
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&provide_zero, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R9 compound: ZERO_HASH ProvideData blocked"
    );

    // Step 2: Investigation still exists, so CheckDeadline still works
    let deadline_tx = Transaction::STPAction(STPActionTx {
        action: STPAction::CheckDeadline {
            investigation_id: pool_id,
        },
        submitter: anyone,
        timestamp: 1000 + 259_200 + 1, // past 72h deadline
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&deadline_tx, &state, 1000 + 259_200 + 1, 0);
    assert!(
        result.is_ok(),
        "R9 compound: CheckDeadline should still work since investigation was not killed"
    );
}

// ===========================================================================
// R9 Compound Attack: App State Deletion + Recreation
// ===========================================================================

/// Compound attack: Alice sets app state, then tries to delete it with ZERO_HASH,
/// then Bob recreates it with different data.
#[test]
fn r9_compound_app_state_deletion_recreation_blocked() {
    let (state, alice, bob) = setup_wallets_with_identities();
    let app_id = [0xA0; 32];

    // Alice creates app state
    let tx1 = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: [0x11; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx1, &state, 1000, 0).unwrap();

    // Alice tries to delete via ZERO_HASH — BLOCKED
    let tx_delete = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: alice,
        app_id,
        new_state_hash: ZERO_HASH,
        nonce: 1,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx_delete, &state, 1000, 0);
    assert!(
        result.is_err(),
        "R9 compound: app state deletion via ZERO_HASH blocked"
    );

    // App state still contains alice's data
    assert_eq!(
        state.get_app_state(&app_id),
        Some([0x11; 32]),
        "R9 compound: alice's app state preserved"
    );

    // Bob can still overwrite with valid data (this is the R8-08 documented behavior)
    let tx_bob = Transaction::AppStateUpdate(AppStateUpdate {
        account_id: bob,
        app_id,
        new_state_hash: [0x22; 32],
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let state = validate_transaction(&tx_bob, &state, 1000, 0).unwrap();
    assert_eq!(state.get_app_state(&app_id), Some([0x22; 32]));
}

// ===========================================================================
// R9 Regression: All previous fixes still work
// ===========================================================================

/// R8: WalletSync ZERO_HASH still rejected.
#[test]
fn r9_regression_wallet_sync_zero_hash_still_rejected() {
    let (state, alice, _bob) = setup_wallets_with_identities();

    let tx = Transaction::WalletSync(WalletSync {
        account_id: alice,
        new_state_hash: ZERO_HASH,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::InvalidEncoding(_))));
}

/// R8: Identity ZERO_HASH still rejected.
#[test]
fn r9_regression_identity_zero_hash_still_rejected() {
    let state = GlobalState::genesis();

    let tx = Transaction::IdentityRegister(IdentityRegister {
        account_id: [0xEE; 32],
        tier: Tier::Identified,
        identity_hash: ZERO_HASH,
        jurisdiction: 840,
        is_public_official: false,
        office: None,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::InvalidEncoding(_))));
}

/// R7: Tier violation without identity still rejected.
#[test]
fn r9_regression_tier_violation_still_rejected() {
    let (state, sender, recipient) = setup_wallets();
    let sender_hash = state.get_wallet(&sender).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: sender,
        to: recipient,
        amount: 1000,
        fee: 100,
        nonce: 0,
        timestamp: 1000,
        state_pre: sender_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified, // LIE: no identity registered
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 1000,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::TierViolation(_))));
}

/// R6: Swap zero hash_lock still rejected.
#[test]
fn r9_regression_swap_zero_hash_lock_still_rejected() {
    let (state, alice, bob) = setup_wallets();
    let swap_id = hash_with_domain(
        DOMAIN_SWAP,
        &[alice.as_slice(), bob.as_slice(), &0u64.to_le_bytes()].concat(),
    );
    let swap = AtomicSwapInit {
        swap_id,
        initiator: alice,
        responder: bob,
        amount: 5000,
        hash_lock: ZERO_HASH,
        timeout: 100,
        disclosure_root: None,
        execution_proof: None,
        nonce: 0,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    };
    let tx = Transaction::AtomicSwapInit(swap);
    let result = validate_transaction(&tx, &state, 1000, 50);
    assert!(matches!(result, Err(ChainError::InvalidPreimage)));
}

/// R5: Nonce overflow still caught.
#[test]
fn r9_regression_nonce_overflow_still_caught() {
    let (mut state, alice, bob) = setup_wallets_with_identities();
    state.set_nonce(alice, u64::MAX);
    let alice_hash = state.get_wallet(&alice).unwrap();

    let tx = Transaction::CashTransfer(CashTransfer {
        from: alice,
        to: bob,
        amount: 100,
        fee: 100,
        nonce: u64::MAX,
        timestamp: 1000,
        state_pre: alice_hash,
        proof: mock_proof(),
        signature: [0u8; 64],
        sender_tier: Tier::Identified,
        sender_identity_hash: [0xAA; 32],
        recipient_identity_hash: [0xBB; 32],
        sender_frozen: false,
        recipient_frozen: false,
        rolling_24h_total_after: 100,
        jurisdiction: 840,
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::NonceOverflow)));
}

/// R5: Backup size limit still enforced.
#[test]
fn r9_regression_backup_size_limit_still_enforced() {
    let (state, sender, _) = setup_wallets();
    let tx = Transaction::BackupStore(BackupStore {
        account_id: sender,
        encrypted_state: vec![0u8; 1_048_577],
        state_hash: [0xCC; 32],
        nonce: 0,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::BackupTooLarge { .. })));
}

/// R7: Duplicate STP contract still rejected.
#[test]
fn r9_regression_duplicate_stp_contract_still_rejected() {
    let state = GlobalState::genesis();
    let official = [0x10; 32];
    let state = register_official(&state, official);

    let contract = ServiceContract {
        official,
        identity_hash: [0xBB; 32],
        office: "Senator".into(),
        jurisdiction: 840,
        reporting_threshold: u64::MAX,
        staked_amount: 1,
        term_start: 1000,
        term_end: u64::MAX,
        status: ContractStatus::Active,
    };
    let tx = Transaction::STPAction(STPActionTx {
        action: STPAction::RegisterContract(contract),
        submitter: official,
        timestamp: 1000,
        proof: mock_proof(),
        signature: [0u8; 64],
    });
    let result = validate_transaction(&tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::DuplicateSTPContract)));
}

/// R8: Block validation against parent still works.
#[test]
fn r9_regression_block_validation_still_works() {
    let genesis = poly_chain::block::Block::genesis([0xAA; 32], 1000);
    let child = poly_chain::block::Block::try_new(&genesis.header, vec![], [0xBB; 32], 2000).unwrap();
    let result = child.validate_against_parent(&genesis.header);
    assert!(result.is_ok());
}

/// R6: Fraud proof conflict type mismatch still rejected.
#[test]
fn r9_regression_fraud_conflict_type_mismatch() {
    let mut state = GlobalState::genesis();
    let victim = [0xAA; 32];
    state.set_wallet(victim, [0xCC; 32]);

    let fraud_tx = Transaction::FraudProof(FraudProofTx {
        evidence: FraudEvidence {
            fraudulent_key: victim,
            observation_a: StateObservation {
                observer: [0xBB; 32],
                observed_key: victim,
                observed_state_hash: [0x11; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            observation_b: StateObservation {
                observer: [0xCC; 32],
                observed_key: victim,
                observed_state_hash: [0x22; 32],
                observed_nonce: 5,
                observer_signature: [0u8; 64],
            },
            conflict_type: ConflictType::StateInconsistency, // WRONG
        },
        submitter: [0xEE; 32],
        proof: mock_proof(),
    });
    let result = validate_transaction(&fraud_tx, &state, 1000, 0);
    assert!(matches!(result, Err(ChainError::FraudDetected(_))));
}
