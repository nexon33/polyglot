// Phase 26d: Component Linker for WASM Component Model
//
// Links multiple WASM components together using wasm-compose.
// Components import/export interfaces defined in WIT, enabling
// true cross-language interop.

use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

use crate::component_builder::ComponentBuildResult;

/// Result of component linking
#[derive(Debug)]
pub struct LinkResult {
    pub output_path: PathBuf,
    pub size_bytes: usize,
    pub components_linked: usize,
}

/// Errors during component linking
#[derive(Debug)]
pub enum LinkError {
    IoError(std::io::Error),
    ToolNotFound(String),
    ToolFailed { tool: String, stderr: String },
    NoComponents,
    ConfigGeneration(String),
}

impl std::fmt::Display for LinkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::IoError(e) => write!(f, "IO error: {}", e),
            Self::ToolNotFound(tool) => write!(f, "Tool not found: {}. Install it first.", tool),
            Self::ToolFailed { tool, stderr } => write!(f, "{} failed:\n{}", tool, stderr),
            Self::NoComponents => write!(f, "No components to link"),
            Self::ConfigGeneration(msg) => write!(f, "Config generation failed: {}", msg),
        }
    }
}

impl std::error::Error for LinkError {}

impl From<std::io::Error> for LinkError {
    fn from(e: std::io::Error) -> Self {
        Self::IoError(e)
    }
}

/// Component linker configuration
pub struct ComponentLinker {
    /// Working directory for temp files
    pub work_dir: PathBuf,
    /// Output file path
    pub output_path: PathBuf,
    /// Verbose output
    pub verbose: bool,
}

impl ComponentLinker {
    pub fn new(work_dir: PathBuf) -> Self {
        let output_path = work_dir.join("composed.wasm");
        Self {
            work_dir,
            output_path,
            verbose: false,
        }
    }

    /// Link multiple components into a single composed component
    pub fn link(&self, components: &[ComponentBuildResult], wit_path: &Path) -> Result<LinkResult, LinkError> {
        if components.is_empty() {
            return Err(LinkError::NoComponents);
        }

        // Check if wasm-compose is installed
        if !self.check_tool("wasm-compose") {
            return Err(LinkError::ToolNotFound(
                "wasm-compose (install with: cargo install wasm-compose)".to_string()
            ));
        }

        fs::create_dir_all(&self.work_dir)?;

        // Generate composition configuration
        let config_path = self.work_dir.join("compose.yaml");
        let config = self.generate_compose_config(components, wit_path)?;
        fs::write(&config_path, &config)?;

        if self.verbose {
            println!("ðŸ“ Generated composition config: {}", config_path.display());
            println!("{}", config);
        }

        // Run wasm-compose
        if self.verbose {
            println!("ðŸ”— Linking {} components with wasm-compose...", components.len());
        }

        let output = Command::new("wasm-compose")
            .args([
                "--config", config_path.to_str().unwrap(),
                "-o", self.output_path.to_str().unwrap(),
            ])
            .output()?;

        if !output.status.success() {
            return Err(LinkError::ToolFailed {
                tool: "wasm-compose".to_string(),
                stderr: String::from_utf8_lossy(&output.stderr).to_string(),
            });
        }

        let size = fs::metadata(&self.output_path)?.len() as usize;

        if self.verbose {
            println!("âœ… Composed component: {} ({} KB)", self.output_path.display(), size / 1024);
        }

        Ok(LinkResult {
            output_path: self.output_path.clone(),
            size_bytes: size,
            components_linked: components.len(),
        })
    }

    /// Generate wasm-compose configuration YAML
    fn generate_compose_config(&self, components: &[ComponentBuildResult], _wit_path: &Path) -> Result<String, LinkError> {
        let mut config = String::new();

        // Header
        config.push_str("# Auto-generated by polyglot component linker\n\n");

        // Components section
        config.push_str("components:\n");
        for (i, comp) in components.iter().enumerate() {
            let name = format!("{}_{}", comp.language, i);
            config.push_str(&format!("  {}:\n", name));
            config.push_str(&format!("    path: \"{}\"\n",
                comp.wasm_path.to_str().unwrap().replace('\\', "/")));
        }

        // Instantiations section - wire up imports/exports
        config.push_str("\ninstantiations:\n");

        // First component is typically the "main" that imports from others
        if let Some(main_comp) = components.first() {
            let main_name = format!("{}_0", main_comp.language);
            config.push_str(&format!("  {}:\n", main_name));
            config.push_str("    arguments:\n");

            // Wire subsequent components as dependencies
            for (i, comp) in components.iter().enumerate().skip(1) {
                let dep_name = format!("{}_{}", comp.language, i);
                // The export name should match the interface name
                config.push_str(&format!("      {}: ${}\n", dep_name, dep_name));
            }
        }

        // Exports section - expose main component's exports
        config.push_str("\nexports:\n");
        if let Some(main_comp) = components.first() {
            let main_name = format!("{}_0", main_comp.language);
            config.push_str(&format!("  - instance: ${}\n", main_name));
        }

        Ok(config)
    }

    /// Alternative: Link using wasm-tools component link
    pub fn link_with_wasm_tools(&self, components: &[ComponentBuildResult]) -> Result<LinkResult, LinkError> {
        if components.is_empty() {
            return Err(LinkError::NoComponents);
        }

        // Check if wasm-tools is installed
        if !self.check_tool("wasm-tools") {
            return Err(LinkError::ToolNotFound(
                "wasm-tools (install with: cargo install wasm-tools)".to_string()
            ));
        }

        fs::create_dir_all(&self.work_dir)?;

        if self.verbose {
            println!("ðŸ”— Linking {} components with wasm-tools...", components.len());
        }

        // wasm-tools component link takes multiple inputs
        let mut args = vec!["component".to_string(), "link".to_string()];

        for comp in components {
            args.push(comp.wasm_path.to_str().unwrap().to_string());
        }

        args.push("-o".to_string());
        args.push(self.output_path.to_str().unwrap().to_string());

        let output = Command::new("wasm-tools")
            .args(&args)
            .output()?;

        if !output.status.success() {
            return Err(LinkError::ToolFailed {
                tool: "wasm-tools".to_string(),
                stderr: String::from_utf8_lossy(&output.stderr).to_string(),
            });
        }

        let size = fs::metadata(&self.output_path)?.len() as usize;

        if self.verbose {
            println!("âœ… Linked component: {} ({} KB)", self.output_path.display(), size / 1024);
        }

        Ok(LinkResult {
            output_path: self.output_path.clone(),
            size_bytes: size,
            components_linked: components.len(),
        })
    }

    /// Check if a tool is available on PATH
    fn check_tool(&self, tool: &str) -> bool {
        Command::new(tool)
            .arg("--version")
            .output()
            .map(|o| o.status.success())
            .unwrap_or(false)
    }
}

/// Simple composition without config file (for two components)
pub fn compose_two_components(
    primary: &Path,
    secondary: &Path,
    output: &Path,
) -> Result<(), LinkError> {
    // Check if wasm-compose is installed
    let has_compose = Command::new("wasm-compose")
        .arg("--version")
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false);

    if !has_compose {
        return Err(LinkError::ToolNotFound(
            "wasm-compose (install with: cargo install wasm-compose)".to_string()
        ));
    }

    // Simple two-component composition
    let output_cmd = Command::new("wasm-compose")
        .args([
            primary.to_str().unwrap(),
            "-d", secondary.to_str().unwrap(),
            "-o", output.to_str().unwrap(),
        ])
        .output()?;

    if !output_cmd.status.success() {
        return Err(LinkError::ToolFailed {
            tool: "wasm-compose".to_string(),
            stderr: String::from_utf8_lossy(&output_cmd.stderr).to_string(),
        });
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_generation() {
        let linker = ComponentLinker::new(PathBuf::from("/tmp/test"));

        let components = vec![
            ComponentBuildResult {
                language: "typescript".to_string(),
                wasm_path: PathBuf::from("/tmp/ts.wasm"),
                size_bytes: 1000,
            },
            ComponentBuildResult {
                language: "python".to_string(),
                wasm_path: PathBuf::from("/tmp/py.wasm"),
                size_bytes: 2000,
            },
        ];

        let config = linker.generate_compose_config(&components, Path::new("/tmp/interfaces.wit")).unwrap();

        println!("Generated config:\n{}", config);

        assert!(config.contains("typescript_0"));
        assert!(config.contains("python_1"));
        assert!(config.contains("/tmp/ts.wasm"));
        assert!(config.contains("/tmp/py.wasm"));
    }
}
