//! CKKS metadata exploit regression tests.
//!
//! These tests were originally exploit tests demonstrating that CkksCiphertext
//! had no authentication — metadata could be tampered with silently.
//! Now they confirm that verify_integrity() detects all tampering.
//!
//! Fixed vulnerabilities:
//! - FIXED: Ciphertext now has auth_tag (SHA-256 over all data + metadata)
//! - FIXED: Ciphertext now has key_id (SHA-256 of encrypting public key)
//! - FIXED: Ciphertext now has nonce (random bytes for replay protection)
//! - KNOWN: token_count still leaks sequence length (inherent to chunked encryption)

#![cfg(feature = "ckks")]

use poly_client::ckks::ciphertext::{compute_key_id, decrypt, encrypt, CkksCiphertext};
use poly_client::ckks::keys::keygen;
use poly_client::ckks::params::{DELTA, N};
use rand::rngs::StdRng;
use rand::SeedableRng;

fn test_rng() -> StdRng {
    StdRng::seed_from_u64(42)
}

// ═══════════════════════════════════════════════════════════════════════
// KNOWN LIMITATION: TOKEN COUNT LEAKS SEQUENCE LENGTH
//
// CkksCiphertext.token_count is stored as plaintext metadata.
// This is inherent to the chunked encryption design — you need to know
// how many tokens to decode. Padding could mitigate but is not implemented.
// ═══════════════════════════════════════════════════════════════════════

/// KNOWN: token_count is visible in plaintext — leaks sequence length.
/// This is inherent to the design and mitigated by verify_integrity().
#[test]
fn exploit_token_count_leaks_sequence_length() {
    let mut rng = test_rng();
    let (pk, _sk) = keygen(&mut rng);

    let tokens = vec![10, 20, 30, 40, 50, 60, 70];
    let ct = encrypt(&tokens, &pk, &mut rng);

    // token_count is still readable (inherent to design)
    assert_eq!(ct.token_count, tokens.len());

    // But the ciphertext is now authenticated
    assert!(ct.auth_tag.is_some());
    assert!(ct.key_id.is_some());
    assert!(ct.nonce.is_some());
    assert!(ct.verify_integrity(&pk));

    eprintln!("KNOWN LIMITATION: token_count={} readable (inherent to chunked design)", ct.token_count);
    eprintln!("  MITIGATED: auth_tag prevents tampering with token_count");
}

/// KNOWN: number of chunks leaks approximate sequence length.
#[test]
fn exploit_chunk_count_leaks_length_range() {
    let mut rng = test_rng();
    let (pk, _sk) = keygen(&mut rng);

    // 1 token → 1 chunk
    let ct1 = encrypt(&[42], &pk, &mut rng);
    assert_eq!(ct1.chunks.len(), 1);
    assert!(ct1.verify_integrity(&pk));

    // N tokens → 1 chunk (exactly full)
    let tokens_n: Vec<u32> = (0..N as u32).collect();
    let ct_n = encrypt(&tokens_n, &pk, &mut rng);
    assert_eq!(ct_n.chunks.len(), 1);
    assert!(ct_n.verify_integrity(&pk));

    // N+1 tokens → 2 chunks
    let tokens_np1: Vec<u32> = (0..N as u32 + 1).collect();
    let ct_np1 = encrypt(&tokens_np1, &pk, &mut rng);
    assert_eq!(ct_np1.chunks.len(), 2);
    assert!(ct_np1.verify_integrity(&pk));

    eprintln!("KNOWN LIMITATION: chunk count reveals length range (inherent to chunking)");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 1: TOKEN COUNT TAMPERING NOW DETECTED
//
// verify_integrity() catches any modification to token_count because
// it's included in the auth_tag computation.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Token count truncation is now detected by verify_integrity().
#[test]
fn exploit_token_count_tampering_truncation() {
    let mut rng = test_rng();
    let (pk, sk) = keygen(&mut rng);

    let tokens = vec![100, 200, 300, 400, 500];
    let mut ct = encrypt(&tokens, &pk, &mut rng);

    // Verify integrity passes before tampering
    assert!(ct.verify_integrity(&pk));

    // Attacker reduces token_count
    ct.token_count = 2;

    // NOW DETECTED: verify_integrity catches the tampering
    assert!(
        !ct.verify_integrity(&pk),
        "FIXED: token_count truncation must be detected"
    );

    eprintln!("REGRESSION M3 PASSED: token_count truncation detected by verify_integrity()");
}

/// FIXED: Token count inflation is now detected by verify_integrity().
#[test]
fn exploit_token_count_tampering_inflation() {
    let mut rng = test_rng();
    let (pk, sk) = keygen(&mut rng);

    let tokens = vec![100, 200, 300];
    let mut ct = encrypt(&tokens, &pk, &mut rng);

    assert!(ct.verify_integrity(&pk));

    // Attacker inflates token_count
    ct.token_count = N;

    // NOW DETECTED
    assert!(
        !ct.verify_integrity(&pk),
        "FIXED: token_count inflation must be detected"
    );

    eprintln!("REGRESSION M4 PASSED: token_count inflation detected by verify_integrity()");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 2: SCALE TAMPERING NOW DETECTED
//
// verify_integrity() catches any modification to scale because
// it's included in the auth_tag computation.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Scale tampering is now detected by verify_integrity().
#[test]
fn exploit_scale_tampering_corrupts_decryption() {
    let mut rng = test_rng();
    let (pk, sk) = keygen(&mut rng);

    let tokens = vec![42, 100, 999];
    let mut ct = encrypt(&tokens, &pk, &mut rng);

    // Verify correct decryption at original scale
    assert!(ct.verify_integrity(&pk));
    assert_eq!(decrypt(&ct, &sk), tokens);

    // Attacker halves the scale
    ct.scale = DELTA / 2;

    // NOW DETECTED
    assert!(
        !ct.verify_integrity(&pk),
        "FIXED: scale tampering must be detected"
    );

    eprintln!("REGRESSION M5 PASSED: scale tampering detected by verify_integrity()");
}

/// FIXED: Scale is still visible in serialization but now authenticated.
#[test]
fn exploit_scale_leaks_in_serialization() {
    let mut rng = test_rng();
    let (pk, _sk) = keygen(&mut rng);

    let tokens = vec![42];
    let ct = encrypt(&tokens, &pk, &mut rng);

    let json = serde_json::to_string(&ct).unwrap();

    // Scale is visible (inherent to serialization) but authenticated
    let expected_scale = format!("\"scale\":{}", DELTA);
    assert!(json.contains(&expected_scale));

    // Auth tag is also present in serialization
    assert!(json.contains("\"auth_tag\""));
    assert!(json.contains("\"key_id\""));
    assert!(json.contains("\"nonce\""));

    // Deserialize and verify integrity
    let ct2: CkksCiphertext = serde_json::from_str(&json).unwrap();
    assert!(ct2.verify_integrity(&pk));

    eprintln!("KNOWN: scale visible in serialization but now authenticated");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 3: CIPHERTEXT TAMPERING NOW DETECTED
//
// verify_integrity() catches any modification to ciphertext coefficients
// because they're included in the auth_tag computation.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Ciphertext bit-flip is now detected by verify_integrity().
#[test]
fn exploit_no_ciphertext_authentication() {
    let mut rng = test_rng();
    let (pk, sk) = keygen(&mut rng);

    let tokens = vec![100, 200, 300, 400, 500];
    let mut ct = encrypt(&tokens, &pk, &mut rng);

    // Verify integrity passes before tampering
    assert!(ct.verify_integrity(&pk));

    // Attacker flips one bit in one coefficient
    ct.chunks[0].0.coeffs[0] ^= 1;

    // NOW DETECTED: verify_integrity catches even single-bit changes
    assert!(
        !ct.verify_integrity(&pk),
        "FIXED: ciphertext bit-flip must be detected"
    );

    eprintln!("REGRESSION M7 PASSED: single-bit ciphertext tampering detected");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 4: REPLAY NOW DETECTABLE
//
// Each ciphertext has a unique nonce. While replay is still possible
// at the transport layer (no session binding), the nonce ensures each
// encryption produces a unique auth_tag — the server can track seen
// nonces to detect replays.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Each encryption produces a unique nonce for replay detection.
#[test]
fn exploit_ciphertext_replay() {
    let mut rng = test_rng();
    let (pk, sk) = keygen(&mut rng);

    let tokens = vec![42, 43, 44];

    // Encrypt same tokens twice — different nonces
    let ct1 = encrypt(&tokens, &pk, &mut rng);
    let ct2 = encrypt(&tokens, &pk, &mut rng);

    // Both verify and decrypt correctly
    assert!(ct1.verify_integrity(&pk));
    assert!(ct2.verify_integrity(&pk));
    assert_eq!(decrypt(&ct1, &sk), tokens);
    assert_eq!(decrypt(&ct2, &sk), tokens);

    // But they have DIFFERENT nonces (server can detect replays)
    assert_ne!(
        ct1.nonce, ct2.nonce,
        "FIXED: each encryption must produce a unique nonce"
    );
    assert_ne!(
        ct1.auth_tag, ct2.auth_tag,
        "Different nonces must produce different auth tags"
    );

    // Serialization roundtrip preserves nonce for replay tracking
    let json = serde_json::to_string(&ct1).unwrap();
    let replayed: CkksCiphertext = serde_json::from_str(&json).unwrap();
    assert_eq!(replayed.nonce, ct1.nonce);

    eprintln!("REGRESSION M8 PASSED: unique nonce enables replay detection");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 5: KEY BINDING NOW AVAILABLE
//
// Each ciphertext includes a key_id (SHA-256 of the encrypting public key).
// verify_integrity() checks that the key_id matches the expected key.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: verify_integrity() detects ciphertexts encrypted for a different key.
#[test]
fn exploit_no_key_binding_in_ciphertext() {
    let mut rng1 = StdRng::seed_from_u64(1);
    let mut rng2 = StdRng::seed_from_u64(2);

    let (pk_server, _sk_server) = keygen(&mut rng1);
    let (pk_attacker, sk_attacker) = keygen(&mut rng2);

    let tokens = vec![100, 200, 300];

    // Attacker encrypts under their own key
    let ct_attacker = encrypt(&tokens, &pk_attacker, &mut rng2);

    // Ciphertext has the attacker's key_id
    let attacker_key_id = compute_key_id(&pk_attacker);
    assert_eq!(ct_attacker.key_id.unwrap(), attacker_key_id);

    // verify_integrity with server's key FAILS — wrong key_id
    assert!(
        !ct_attacker.verify_integrity(&pk_server),
        "FIXED: ciphertext encrypted for wrong key must be detected"
    );

    // verify_integrity with attacker's key passes
    assert!(ct_attacker.verify_integrity(&pk_attacker));

    // key_id is different for different keys
    let server_key_id = compute_key_id(&pk_server);
    assert_ne!(server_key_id, attacker_key_id);

    eprintln!("REGRESSION M9 PASSED: key_id binding detects wrong-key ciphertexts");
}

// ═══════════════════════════════════════════════════════════════════════
// ADDITIONAL: AUTH TAG PROPERTIES
// ═══════════════════════════════════════════════════════════════════════

/// Auth tag survives serialization roundtrip.
#[test]
fn auth_tag_serialization_roundtrip() {
    let mut rng = test_rng();
    let (pk, sk) = keygen(&mut rng);

    let tokens = vec![10, 20, 30, 40, 50];
    let ct = encrypt(&tokens, &pk, &mut rng);

    let json = serde_json::to_string(&ct).unwrap();
    let ct2: CkksCiphertext = serde_json::from_str(&json).unwrap();

    assert!(ct2.verify_integrity(&pk));
    assert_eq!(decrypt(&ct2, &sk), tokens);
    assert_eq!(ct.auth_tag, ct2.auth_tag);
    assert_eq!(ct.key_id, ct2.key_id);
    assert_eq!(ct.nonce, ct2.nonce);
}

/// Empty ciphertext also gets authenticated.
#[test]
fn empty_ciphertext_authenticated() {
    let mut rng = test_rng();
    let (pk, sk) = keygen(&mut rng);

    let ct = encrypt(&[], &pk, &mut rng);
    assert!(ct.verify_integrity(&pk));
    assert_eq!(decrypt(&ct, &sk), Vec::<u32>::new());

    // Tampering with empty ciphertext is still detected
    let mut ct2 = ct.clone();
    ct2.token_count = 1;
    assert!(!ct2.verify_integrity(&pk));
}

/// Multi-chunk ciphertext authenticated across all chunks.
#[test]
fn multi_chunk_authenticated() {
    let mut rng = test_rng();
    let (pk, sk) = keygen(&mut rng);

    let tokens: Vec<u32> = (0..5000).collect();
    let ct = encrypt(&tokens, &pk, &mut rng);
    assert!(ct.chunks.len() > 1);
    assert!(ct.verify_integrity(&pk));

    // Tamper with second chunk
    let mut ct2 = ct.clone();
    ct2.chunks[1].0.coeffs[0] ^= 1;
    assert!(!ct2.verify_integrity(&pk));
}
