//! Round 15 Penetration Test -- Attack Tests for poly-client
//!
//! Focus areas (NEW, not covered in R1-R14):
//! - R15-VULN-01: Ciphertext level/primes metadata desync (level field vs actual num_primes)
//! - R15-VULN-02: Auth tag stripping through homomorphic operations (add/sub/mul/rotate)
//! - R15-VULN-03: RnsPoly residue length mismatch (residues[i].len() != N via deserialization)
//! - R15-VULN-04: Encrypt/decrypt with exactly 1 prime (minimum viable, no rescale possible)
//! - R15-VULN-05: Garner CRT centering boundary (values near Q/2)
//! - R15-VULN-06: WideInt shr edge cases (shift by 0, 64, 128+ bits)
//! - R15-VULN-07: Compression header mutation attacks (twiddling format bytes)
//! - R15-VULN-08: Double-authenticate ciphertext (re-auth after modification)
//! - R15-VULN-09: Serialization roundtrip preserves auth tag semantics
//! - R15-VULN-10: RnsNeuralNet with zero layers (empty forward pass)
//! - R15-VULN-11: rns_ct_add_leveled self-addition (adding ciphertext to itself)
//! - R15-VULN-12: Drop_last_prime on 2-prime poly (minimum rescale)
//! - R15-VULN-13: SIMD encode/decode with exactly 1 slot and exactly NUM_SLOTS
//! - R15-VULN-14: Encrypt with 2 primes then decrypt (minimum viable FHE)
//! - R15-VULN-15: Auth tag recomputation independence with different MAC keys
//! - R15-VULN-16: Compression of ciphertext at different levels (mixed level set)
//! - R15-VULN-17: Galois element computation for edge rotations
//! - R15-VULN-18: RnsPoly::from_coeffs with fewer than N coefficients (zero-padding)
//! - R15-VULN-19: rns_ct_mul_plain_simd with all-zero plaintext
//! - R15-VULN-20: Ciphertext with mismatched c0/c1 level in auth tag

#![cfg(feature = "ckks")]
#![allow(unused_variables)]

use poly_client::ckks::compress::{self, CompressionLevel};
use poly_client::ckks::ntt::{NttContext, NTT_PRIMES};
use poly_client::ckks::params::N;
use poly_client::ckks::poly_eval;
use poly_client::ckks::rns::RnsPoly;
use poly_client::ckks::rns_ckks::*;
use poly_client::ckks::rns_fhe_layer::*;
use poly_client::ckks::simd;

use rand::rngs::StdRng;
use rand::SeedableRng;

fn test_rng_seed(seed: u64) -> StdRng {
    StdRng::seed_from_u64(seed)
}

// =============================================================================
// SECTION 1: Ciphertext Level/Primes Metadata Desync (R15-VULN-01)
// =============================================================================
// Vulnerability: The `level` field in RnsCiphertext is a plain usize that is
// not validated against `c0.num_primes`. A crafted ciphertext can have
// level=0 but only 1 prime, or level=10 but 3 primes. Operations that
// depend on the `level` field (like rns_ct_add which checks level equality)
// could be bypassed while the ciphertext has completely wrong prime counts.

/// R15-VULN-01a: Crafted ciphertext where level says "fresh" (0) but only has
/// 1 prime. Adding two such ciphertexts should work (levels match, primes match)
/// but the result cannot be rescaled.
#[test]
fn r15_level_metadata_desync_still_decryptable() {
    let mut rng = test_rng_seed(1501);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    // Encrypt with 3 primes, then mod-switch to 1 prime
    let ct = rns_encrypt_simd(&[1.0, 2.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct_1prime = rns_ct_mod_switch_to(&ct, 1);

    // After mod_switch_to(1), level becomes 2 (3-1=2 primes dropped)
    assert_eq!(ct_1prime.c0.num_primes, 1);
    assert_eq!(ct_1prime.level, 2);

    // Decrypt with 1 prime should still work (but with reduced precision)
    let dec = rns_decrypt_simd(&ct_1prime, &s, &ctx, 2);
    assert!(
        (dec[0] - 1.0).abs() < 1.0,
        "1-prime decrypt: expected ~1.0, got {}",
        dec[0]
    );
}

/// R15-VULN-01b: Two ciphertexts at different levels but same num_primes
/// (after mod-switch) should be addable via leveled add.
#[test]
fn r15_different_levels_same_primes_leveled_add() {
    let mut rng = test_rng_seed(1502);
    let ctx = RnsCkksContext::new(4);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct_a = rns_encrypt_simd(&[3.0], &pk_b, &pk_a, &ctx, &mut rng);
    // Mod-switch ct_a from 4 to 2 primes (level goes to 2)
    let ct_a2 = rns_ct_mod_switch_to(&ct_a, 2);

    let ct_b = rns_encrypt_simd(&[5.0], &pk_b, &pk_a, &ctx, &mut rng);
    // Mod-switch ct_b from 4 to 2 primes (level goes to 2)
    let ct_b2 = rns_ct_mod_switch_to(&ct_b, 2);

    // Both at 2 primes, should add fine
    let ct_sum = rns_ct_add_leveled(&ct_a2, &ct_b2);
    let dec = rns_decrypt_simd(&ct_sum, &s, &ctx, 1);
    assert!(
        (dec[0] - 8.0).abs() < 1.0,
        "Leveled add: expected ~8.0, got {}",
        dec[0]
    );
}

// =============================================================================
// SECTION 2: Auth Tag Stripping via Homomorphic Operations (R15-VULN-02)
// =============================================================================
// Vulnerability: Every homomorphic operation (add, sub, mul, rescale, rotate,
// mod_switch, etc.) sets auth_tag to None in the result. This means an
// authenticated ciphertext loses its authentication guarantee after any
// operation. A server performing inference could modify the ciphertext after
// operations without detection.

/// R15-VULN-02a: Auth tag is stripped after ciphertext addition.
#[test]
fn r15_auth_tag_stripped_after_add() {
    let mut rng = test_rng_seed(1510);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0xABu8; 32];

    let mut ct1 = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);
    ct1.authenticate(&mac_key);
    assert!(ct1.verify_auth(&mac_key), "Auth should verify before add");

    let ct2 = rns_encrypt_simd(&[2.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct_sum = rns_ct_add(&ct1, &ct2);

    // Auth tag is None after addition — this is by design (operations invalidate tags)
    assert!(
        ct_sum.auth_tag.is_none(),
        "Auth tag should be None after homomorphic add"
    );
}

/// R15-VULN-02b: Auth tag is stripped after rescaling.
#[test]
fn r15_auth_tag_stripped_after_rescale() {
    let mut rng = test_rng_seed(1511);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0xCDu8; 32];
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct1 = rns_encrypt_simd(&[2.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct2 = rns_encrypt_simd(&[3.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct_prod = rns_ct_mul_relin(&ct1, &ct2, &evk, &ctx);
    let ct_rescaled = rns_rescale(&ct_prod);

    assert!(
        ct_rescaled.auth_tag.is_none(),
        "Auth tag should be None after rescale"
    );

    // Re-authenticate after operation
    let mut ct_reauthed = ct_rescaled.clone();
    ct_reauthed.authenticate(&mac_key);
    assert!(ct_reauthed.verify_auth(&mac_key));
}

/// R15-VULN-02c: Auth tag is stripped after mod-switch.
#[test]
fn r15_auth_tag_stripped_after_mod_switch() {
    let mut rng = test_rng_seed(1512);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0xEFu8; 32];

    let mut ct = rns_encrypt_simd(&[4.0], &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    assert!(ct.verify_auth(&mac_key));

    let ct_switched = rns_ct_mod_switch_to(&ct, 3);
    assert!(
        ct_switched.auth_tag.is_none(),
        "Auth tag should be None after mod-switch"
    );
}

// =============================================================================
// SECTION 3: RnsPoly Residue Length Mismatch (R15-VULN-03)
// =============================================================================
// Vulnerability: RnsPoly fields are pub, so a manually constructed or
// deserialized RnsPoly can have residues[i].len() != N, or
// residues.len() != num_primes. The validate_residue_ranges method
// catches the length != N case, but operations like add/mul will panic.

/// R15-VULN-03a: RnsPoly with wrong residue length should fail validation.
#[test]
fn r15_rnspoly_wrong_residue_length_fails_validation() {
    let poly = RnsPoly {
        residues: vec![vec![0i64; N / 2]], // Wrong length: N/2 instead of N
        num_primes: 1,
    };
    assert!(
        !poly.validate_residue_ranges(),
        "Poly with residues of wrong length should fail validation"
    );
}

/// R15-VULN-03b: RnsPoly with residues.len() != num_primes should fail validation.
#[test]
fn r15_rnspoly_residues_count_mismatch_fails_validation() {
    let poly = RnsPoly {
        residues: vec![vec![0i64; N], vec![0i64; N]], // 2 residue channels
        num_primes: 3,                                 // but claims 3 primes
    };
    assert!(
        !poly.validate_residue_ranges(),
        "Poly with mismatched residues count should fail validation"
    );
}

/// R15-VULN-03c: RnsPoly with extra residue channels should fail validation.
#[test]
fn r15_rnspoly_extra_residues_fails_validation() {
    let poly = RnsPoly {
        residues: vec![vec![0i64; N]; 5], // 5 channels
        num_primes: 3,                     // but claims 3
    };
    assert!(
        !poly.validate_residue_ranges(),
        "Poly with extra residue channels should fail validation"
    );
}

/// R15-VULN-03d: Valid poly passes validation.
#[test]
fn r15_rnspoly_valid_passes_validation() {
    let poly = RnsPoly::from_coeffs(&[1, 2, 3], 3);
    assert!(
        poly.validate_residue_ranges(),
        "Valid poly should pass validation"
    );
}

// =============================================================================
// SECTION 4: Encrypt/Decrypt with Exactly 1 Prime (R15-VULN-04)
// =============================================================================
// Vulnerability: A context with num_primes=1 can encrypt but cannot perform
// any multiplication (rescale requires > 1 prime). This is the absolute
// minimum configuration and tests the boundary behavior.

/// R15-VULN-04a: Encrypt and decrypt with 1 prime works.
#[test]
fn r15_single_prime_encrypt_decrypt() {
    let mut rng = test_rng_seed(1520);
    let ctx = RnsCkksContext::new(1);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let values = vec![3.14, -2.7, 0.0, 1.0];
    let ct = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);
    assert_eq!(ct.c0.num_primes, 1);

    let dec = rns_decrypt_simd(&ct, &s, &ctx, 4);
    for i in 0..4 {
        assert!(
            (dec[i] - values[i]).abs() < 0.1,
            "1-prime slot {}: expected {}, got {}",
            i, values[i], dec[i]
        );
    }
}

/// R15-VULN-04b: 1-prime context cannot rescale (correctly panics).
#[test]
#[should_panic(expected = "cannot rescale")]
fn r15_single_prime_cannot_rescale() {
    let mut rng = test_rng_seed(1521);
    let ctx = RnsCkksContext::new(1);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);
    // This should panic — can't rescale with only 1 prime
    let _ = rns_rescale(&ct);
}

/// R15-VULN-04c: 1-prime context has max_depth = 0.
#[test]
fn r15_single_prime_max_depth_zero() {
    let ctx = RnsCkksContext::new(1);
    assert_eq!(ctx.max_depth(), 0, "1-prime context should have max_depth=0");
}

/// R15-VULN-04d: Addition works with 1-prime ciphertexts.
#[test]
fn r15_single_prime_addition() {
    let mut rng = test_rng_seed(1522);
    let ctx = RnsCkksContext::new(1);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct1 = rns_encrypt_simd(&[5.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct2 = rns_encrypt_simd(&[3.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct_sum = rns_ct_add(&ct1, &ct2);

    let dec = rns_decrypt_simd(&ct_sum, &s, &ctx, 1);
    assert!(
        (dec[0] - 8.0).abs() < 0.1,
        "1-prime add: expected ~8.0, got {}",
        dec[0]
    );
}

// =============================================================================
// SECTION 5: Garner CRT Centering Boundary (R15-VULN-05)
// =============================================================================
// Vulnerability: CRT reconstruction centers values in (-Q/2, Q/2]. Values
// exactly at Q/2 could be ambiguous. Test boundary values.

/// R15-VULN-05a: CRT with value near the centering boundary.
#[test]
fn r15_crt_centering_near_boundary() {
    // For 2 primes, Q = q0 * q1. Test with a value near Q/2.
    let q0 = NTT_PRIMES[0];
    let q1 = NTT_PRIMES[1];
    // Use a small positive value
    let val = 1000i64;
    let r0 = ((val % q0) + q0) % q0;
    let r1 = ((val % q1) + q1) % q1;

    let poly = RnsPoly {
        residues: vec![vec![r0; N], vec![r1; N]],
        num_primes: 2,
    };
    let coeffs = poly.to_coeffs();
    assert_eq!(coeffs[0], val, "CRT should recover positive value");
}

/// R15-VULN-05b: CRT with negative value near the centering boundary.
#[test]
fn r15_crt_centering_negative() {
    let val = -999i64;
    let q0 = NTT_PRIMES[0];
    let q1 = NTT_PRIMES[1];
    let r0 = ((val as i128 % q0 as i128 + q0 as i128) % q0 as i128) as i64;
    let r1 = ((val as i128 % q1 as i128 + q1 as i128) % q1 as i128) as i64;

    let poly = RnsPoly {
        residues: vec![vec![r0; N], vec![r1; N]],
        num_primes: 2,
    };
    let coeffs = poly.to_coeffs();
    assert_eq!(coeffs[0], val, "CRT should recover negative value");
}

/// R15-VULN-05c: CRT with zero across all primes.
#[test]
fn r15_crt_zero_value() {
    let poly = RnsPoly {
        residues: vec![vec![0; N]; 3],
        num_primes: 3,
    };
    let coeffs = poly.to_coeffs();
    for &c in &coeffs {
        assert_eq!(c, 0, "CRT of all-zero residues should be zero");
    }
}

// =============================================================================
// SECTION 6: WideInt and Garner Edge Cases (R15-VULN-06)
// =============================================================================
// Vulnerability: WideInt::shr, add, mul_u64 have edge cases at limb boundaries.

/// R15-VULN-06a: Digit decomposition with 4+ primes uses wide arithmetic.
#[test]
fn r15_wide_digit_decomposition_4_primes() {
    // With 4 primes, decompose_digits uses WideInt arithmetic.
    // Verify it doesn't corrupt data.
    let ctx = RnsCkksContext::new(4);
    let mut rng = test_rng_seed(1530);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    // Encrypt a known value
    let values = vec![7.77, -3.33, 0.0, 1.0];
    let ct = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);

    // Multiply (uses relinearization which invokes garner_to_digits with wide ints)
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);
    let ct2 = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_prod = rns_ct_mul_relin(&ct, &ct2, &evk, &ctx);
    let ct_rescaled = rns_rescale(&ct_prod);

    let dec = rns_decrypt_simd(&ct_rescaled, &s, &ctx, 4);
    for i in 0..4 {
        let expected = values[i] * values[i];
        assert!(
            (dec[i] - expected).abs() < 2.0,
            "4-prime mul slot {}: expected ~{:.2}, got {:.2}",
            i, expected, dec[i]
        );
    }
}

/// R15-VULN-06b: CRT reconstruction with 5 primes (wide path).
#[test]
fn r15_crt_wide_path_5_primes() {
    let val = 12345i64;
    let poly = RnsPoly::from_coeffs(&[val], 5);
    let coeffs = poly.to_coeffs();
    assert_eq!(
        coeffs[0], val,
        "5-prime CRT should recover {} but got {}",
        val, coeffs[0]
    );
}

/// R15-VULN-06c: CRT reconstruction with negative value and 5 primes.
#[test]
fn r15_crt_wide_path_negative_5_primes() {
    let val = -54321i64;
    let poly = RnsPoly::from_coeffs(&[val], 5);
    let coeffs = poly.to_coeffs();
    assert_eq!(
        coeffs[0], val,
        "5-prime CRT should recover {} but got {}",
        val, coeffs[0]
    );
}

// =============================================================================
// SECTION 7: Compression Header Mutation Attacks (R15-VULN-07)
// =============================================================================
// Vulnerability: Mutating header bytes after compression should be caught
// during decompression. Test various header mutations.

/// R15-VULN-07a: Mutating magic bytes should fail.
#[test]
fn r15_compress_mutated_magic_fails() {
    let data: Vec<i64> = (0..100).collect();
    let mut compressed = compress::compress(&data).unwrap();
    compressed[0] = b'X'; // Corrupt magic
    let result: Result<Vec<i64>, _> = compress::decompress(&compressed);
    assert!(result.is_err(), "Mutated magic should fail decompression");
}

/// R15-VULN-07b: Mutating version byte should fail.
#[test]
fn r15_compress_mutated_version_fails() {
    let data: Vec<i64> = (0..100).collect();
    let mut compressed = compress::compress(&data).unwrap();
    compressed[4] = 3; // Invalid version
    let result: Result<Vec<i64>, _> = compress::decompress(&compressed);
    assert!(result.is_err(), "Mutated version should fail decompression");
}

/// R15-VULN-07c: Mutating v2 level byte to invalid value should fail.
#[test]
fn r15_compress_v2_mutated_level_fails() {
    let data: Vec<i64> = (0..100).collect();
    let mut compressed = compress::compress_with(&data, CompressionLevel::Compact).unwrap();
    compressed[5] = 0; // Invalid level byte (neither 1 nor 2)
    let result: Result<Vec<i64>, _> = compress::decompress(&compressed);
    assert!(result.is_err(), "Mutated v2 level byte should fail decompression");
}

/// R15-VULN-07d: Mutating v2 reserved byte to non-zero should fail.
#[test]
fn r15_compress_v2_nonzero_reserved_fails() {
    let data: Vec<i64> = (0..100).collect();
    let mut compressed = compress::compress_with(&data, CompressionLevel::Compact).unwrap();
    compressed[6] = 1; // Non-zero reserved byte
    let result: Result<Vec<i64>, _> = compress::decompress(&compressed);
    assert!(result.is_err(), "Non-zero reserved byte should fail decompression");
}

/// R15-VULN-07e: Mutating v2 shuffle element size should fail.
#[test]
fn r15_compress_v2_wrong_element_size_fails() {
    let data: Vec<i64> = (0..100).collect();
    let mut compressed = compress::compress_with(&data, CompressionLevel::Compact).unwrap();
    compressed[7] = 4; // Wrong element size (should be 8)
    let result: Result<Vec<i64>, _> = compress::decompress(&compressed);
    assert!(result.is_err(), "Wrong shuffle element size should fail decompression");
}

/// R15-VULN-07f: Truncated payload should fail.
#[test]
fn r15_compress_truncated_payload_fails() {
    let data: Vec<i64> = (0..100).collect();
    let compressed = compress::compress(&data).unwrap();
    // Truncate to just the header
    let truncated = &compressed[..9];
    let result: Result<Vec<i64>, _> = compress::decompress(truncated);
    assert!(result.is_err(), "Truncated payload should fail decompression");
}

// =============================================================================
// SECTION 8: Double-Authenticate Ciphertext (R15-VULN-08)
// =============================================================================
// Vulnerability: Calling authenticate() twice with different keys overwrites
// the tag. The second tag is valid under the second key only.

/// R15-VULN-08a: Re-authenticating with a different key replaces the tag.
#[test]
fn r15_double_authenticate_replaces_tag() {
    let mut rng = test_rng_seed(1540);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mac_key1 = [0x11u8; 32];
    let mac_key2 = [0x22u8; 32];

    let mut ct = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);

    // First authentication
    ct.authenticate(&mac_key1);
    assert!(ct.verify_auth(&mac_key1));
    assert!(!ct.verify_auth(&mac_key2));

    // Second authentication with different key
    ct.authenticate(&mac_key2);
    assert!(!ct.verify_auth(&mac_key1), "Old key should no longer verify");
    assert!(ct.verify_auth(&mac_key2), "New key should verify");
}

/// R15-VULN-08b: Authenticate, modify, re-authenticate creates valid tag for tampered data.
#[test]
fn r15_modify_and_reauthenticate() {
    let mut rng = test_rng_seed(1541);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x33u8; 32];

    let mut ct = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    let original_tag = ct.auth_tag.unwrap();

    // Tamper with ciphertext
    ct.c0.residues[0][0] = (ct.c0.residues[0][0] + 1) % NTT_PRIMES[0];

    // Old tag should no longer verify
    assert!(!ct.verify_auth(&mac_key));

    // Re-authenticating with same key creates a valid tag for tampered data
    // This is expected behavior — but demonstrates that auth tags alone
    // don't prevent server-side tampering if the server has the MAC key.
    ct.authenticate(&mac_key);
    assert!(ct.verify_auth(&mac_key));
}

// =============================================================================
// SECTION 9: Serialization Roundtrip Auth Tag (R15-VULN-09)
// =============================================================================
// Vulnerability: After serialization/deserialization, the auth tag should
// still verify correctly if the data wasn't modified.

/// R15-VULN-09a: Bincode serialization roundtrip preserves auth tag.
#[test]
fn r15_bincode_roundtrip_preserves_auth_tag() {
    let mut rng = test_rng_seed(1550);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x44u8; 32];

    let mut ct = rns_encrypt_simd(&[2.5, -1.0], &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    assert!(ct.verify_auth(&mac_key));

    // Serialize and deserialize via bincode
    let bytes = bincode::serialize(&ct).unwrap();
    let ct2: RnsCiphertext = bincode::deserialize(&bytes).unwrap();

    assert!(
        ct2.verify_auth(&mac_key),
        "Auth tag should verify after bincode roundtrip"
    );

    // Verify decryption still works
    let dec = rns_decrypt_simd(&ct2, &s, &ctx, 2);
    assert!(
        (dec[0] - 2.5).abs() < 0.1,
        "Bincode roundtrip decrypt: expected ~2.5, got {}",
        dec[0]
    );
}

/// R15-VULN-09b: JSON serialization roundtrip preserves auth tag.
#[test]
fn r15_json_roundtrip_preserves_auth_tag() {
    let mut rng = test_rng_seed(1551);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x55u8; 32];

    let mut ct = rns_encrypt_simd(&[4.0], &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);

    let json = serde_json::to_string(&ct).unwrap();
    let ct2: RnsCiphertext = serde_json::from_str(&json).unwrap();

    assert!(
        ct2.verify_auth(&mac_key),
        "Auth tag should verify after JSON roundtrip"
    );
}

/// R15-VULN-09c: PFHE compression roundtrip preserves auth tag.
#[test]
fn r15_pfhe_compression_roundtrip_preserves_auth_tag() {
    let mut rng = test_rng_seed(1552);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x66u8; 32];

    let mut ct = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);

    let compressed = compress::compress(&ct).unwrap();
    let ct2: RnsCiphertext = compress::decompress(&compressed).unwrap();

    assert!(
        ct2.verify_auth(&mac_key),
        "Auth tag should verify after PFHE compression roundtrip"
    );
}

// =============================================================================
// SECTION 10: RnsNeuralNet with Zero Layers (R15-VULN-10)
// =============================================================================
// Vulnerability: An RnsNeuralNet with 0 layers should be a pass-through.
// The forward function should return the encrypted input unchanged.

/// R15-VULN-10a: Zero-layer neural net is identity.
#[test]
fn r15_zero_layer_neural_net_identity() {
    let d = 4;
    let net = RnsNeuralNet {
        dim: d,
        weights: vec![],
        biases: vec![],
        activations: vec![],
    };

    let input = vec![1.0, 2.0, 3.0, 4.0];
    let result = rns_plaintext_forward(&input, &net);
    assert_eq!(result, input, "Zero-layer net should be identity");
}

/// R15-VULN-10b: Zero-layer encrypted forward pass preserves values.
#[test]
fn r15_zero_layer_encrypted_forward() {
    let mut rng = test_rng_seed(1560);
    let ctx = RnsCkksContext::new(3);
    let d = 4;

    let net = RnsNeuralNet {
        dim: d,
        weights: vec![],
        biases: vec![],
        activations: vec![],
    };

    let keys = rns_neural_net_keygen(&net, &ctx, &mut rng);
    let input = vec![1.0, 2.0, 3.0, 4.0];
    let ct = rns_forward(&input, &net, &keys, &ctx, &mut rng);

    let dec = rns_decrypt_simd(&ct, &keys.secret, &ctx, d);
    for i in 0..d {
        assert!(
            (dec[i] - input[i]).abs() < 0.1,
            "Zero-layer slot {}: expected {}, got {}",
            i, input[i], dec[i]
        );
    }
}

// =============================================================================
// SECTION 11: rns_ct_add_leveled Self-Addition (R15-VULN-11)
// =============================================================================
// Vulnerability: Adding a ciphertext to itself should double the encrypted value.
// This is a basic algebraic property that must hold.

/// R15-VULN-11a: Self-addition doubles the value.
#[test]
fn r15_self_addition_doubles() {
    let mut rng = test_rng_seed(1570);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let values = vec![3.0, -2.0, 5.0, 0.5];
    let ct = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);

    // ct + ct = 2*ct
    let ct_double = rns_ct_add(&ct, &ct);
    let dec = rns_decrypt_simd(&ct_double, &s, &ctx, 4);

    for i in 0..4 {
        assert!(
            (dec[i] - 2.0 * values[i]).abs() < 0.1,
            "Self-add slot {}: expected {}, got {}",
            i, 2.0 * values[i], dec[i]
        );
    }
}

/// R15-VULN-11b: Leveled self-addition works across different levels.
#[test]
fn r15_leveled_self_addition() {
    let mut rng = test_rng_seed(1571);
    let ctx = RnsCkksContext::new(4);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_simd(&[7.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct_switched = rns_ct_mod_switch_to(&ct, 3);

    // Leveled add with itself at different levels — should mod-switch both to 3
    let ct_double = rns_ct_add_leveled(&ct, &ct_switched);
    let dec = rns_decrypt_simd(&ct_double, &s, &ctx, 1);
    assert!(
        (dec[0] - 14.0).abs() < 1.0,
        "Leveled self-add: expected ~14.0, got {}",
        dec[0]
    );
}

// =============================================================================
// SECTION 12: Drop Last Prime on 2-Prime Poly (R15-VULN-12)
// =============================================================================
// Vulnerability: Dropping from 2 primes to 1 is the minimum rescale operation.
// The result has only 1 prime, so further rescaling is impossible.

/// R15-VULN-12a: 2-prime to 1-prime drop preserves approximate value.
#[test]
fn r15_drop_last_prime_2_to_1() {
    let q0 = NTT_PRIMES[0];
    let q1 = NTT_PRIMES[1];

    // Encode a value divisible by q1 so division is exact
    let val = 42 * q1;
    let poly = RnsPoly::from_coeffs(&[val], 2);
    assert_eq!(poly.num_primes, 2);

    let dropped = poly.drop_last_prime();
    assert_eq!(dropped.num_primes, 1);

    let coeffs = dropped.to_coeffs();
    assert!(
        (coeffs[0] - 42).abs() <= 1,
        "2->1 drop: expected ~42, got {}",
        coeffs[0]
    );
}

/// R15-VULN-12b: Cannot drop from 1 prime (correctly panics).
#[test]
#[should_panic(expected = "cannot drop last prime")]
fn r15_cannot_drop_from_single_prime() {
    let poly = RnsPoly::from_coeffs(&[42], 1);
    let _ = poly.drop_last_prime();
}

// =============================================================================
// SECTION 13: SIMD Encode/Decode Edge Cases (R15-VULN-13)
// =============================================================================
// Vulnerability: Encoding with exactly 1 slot or exactly NUM_SLOTS should work.

/// R15-VULN-13a: Single slot encode/decode roundtrip.
#[test]
fn r15_simd_single_slot_roundtrip() {
    let delta = (1u64 << 30) as f64;
    let values = vec![42.0];
    let coeffs = simd::encode_simd(&values, delta);
    let decoded = simd::decode_simd(&coeffs, delta, 1);
    assert!(
        (decoded[0] - 42.0).abs() < 0.01,
        "Single slot: expected 42.0, got {}",
        decoded[0]
    );
}

/// R15-VULN-13b: Full capacity (NUM_SLOTS) encode/decode roundtrip.
#[test]
fn r15_simd_full_capacity_roundtrip() {
    let delta = (1u64 << 30) as f64;
    let values: Vec<f64> = (0..simd::NUM_SLOTS)
        .map(|i| (i as f64 * 0.01).sin() * 3.0)
        .collect();
    let coeffs = simd::encode_simd(&values, delta);
    let decoded = simd::decode_simd(&coeffs, delta, simd::NUM_SLOTS);

    let max_err = values
        .iter()
        .zip(decoded.iter())
        .map(|(a, b)| (a - b).abs())
        .fold(0.0f64, f64::max);
    assert!(
        max_err < 0.01,
        "Full capacity roundtrip max error {} too large",
        max_err
    );
}

/// R15-VULN-13c: Decode with count=0 returns empty vector.
#[test]
fn r15_simd_decode_zero_count() {
    let delta = (1u64 << 30) as f64;
    let values = vec![1.0, 2.0];
    let coeffs = simd::encode_simd(&values, delta);
    let decoded = simd::decode_simd(&coeffs, delta, 0);
    assert!(decoded.is_empty(), "Decode with count=0 should be empty");
}

/// R15-VULN-13d: Encode with 0 values produces all-zero coefficients.
#[test]
fn r15_simd_encode_empty() {
    let delta = (1u64 << 30) as f64;
    let values: Vec<f64> = vec![];
    let coeffs = simd::encode_simd(&values, delta);
    assert_eq!(coeffs.len(), N);
    // All-zero input should produce all-zero coefficients
    for &c in &coeffs {
        assert_eq!(c, 0, "Empty encode should produce zero coefficients");
    }
}

// =============================================================================
// SECTION 14: Encrypt with 2 Primes — Minimum Viable FHE (R15-VULN-14)
// =============================================================================
// Vulnerability: With 2 primes, exactly 1 multiply+rescale is possible,
// bringing the ciphertext to 1 prime. Decryption at 1 prime uses single-prime
// CRT which is just centering.

/// R15-VULN-14a: 2-prime encrypt, multiply, rescale, decrypt.
#[test]
fn r15_two_prime_multiply_and_decrypt() {
    let mut rng = test_rng_seed(1580);
    let ctx = RnsCkksContext::new(2);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct1 = rns_encrypt_simd(&[3.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct2 = rns_encrypt_simd(&[4.0], &pk_b, &pk_a, &ctx, &mut rng);

    let ct_prod = rns_ct_mul_relin(&ct1, &ct2, &evk, &ctx);
    let ct_rescaled = rns_rescale(&ct_prod);

    assert_eq!(ct_rescaled.c0.num_primes, 1, "After rescale should have 1 prime");

    let dec = rns_decrypt_simd(&ct_rescaled, &s, &ctx, 1);
    // With only 1 prime remaining, precision is reduced but value should be approximate
    assert!(
        (dec[0] - 12.0).abs() < 5.0,
        "2-prime mul+rescale: expected ~12.0, got {}",
        dec[0]
    );
}

/// R15-VULN-14b: 2-prime scalar multiplication (no level consumed).
#[test]
fn r15_two_prime_scalar_mul() {
    let mut rng = test_rng_seed(1581);
    let ctx = RnsCkksContext::new(2);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_simd(&[5.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct_scaled = rns_ct_scalar_mul(&ct, 3);

    let dec = rns_decrypt_simd(&ct_scaled, &s, &ctx, 1);
    assert!(
        (dec[0] - 15.0).abs() < 0.1,
        "2-prime scalar mul: expected ~15.0, got {}",
        dec[0]
    );
}

// =============================================================================
// SECTION 15: Auth Tag Independence with Different MAC Keys (R15-VULN-15)
// =============================================================================
// Vulnerability: Two different MAC keys should produce different auth tags.

/// R15-VULN-15a: Different MAC keys produce different tags.
#[test]
fn r15_different_mac_keys_different_tags() {
    let mut rng = test_rng_seed(1590);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);

    let mac_key1 = [0xAAu8; 32];
    let mac_key2 = [0xBBu8; 32];

    let tag1 = ct.compute_auth_tag(&mac_key1);
    let tag2 = ct.compute_auth_tag(&mac_key2);

    assert_ne!(tag1, tag2, "Different MAC keys should produce different tags");
}

/// R15-VULN-15b: Same MAC key on same ciphertext produces same tag (deterministic).
#[test]
fn r15_same_mac_key_same_tag_deterministic() {
    let mut rng = test_rng_seed(1591);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);
    let mac_key = [0xCCu8; 32];

    let tag1 = ct.compute_auth_tag(&mac_key);
    let tag2 = ct.compute_auth_tag(&mac_key);

    assert_eq!(tag1, tag2, "Same key on same data should produce same tag");
}

/// R15-VULN-15c: Auth tag changes when scale is modified.
#[test]
fn r15_auth_tag_changes_with_scale() {
    let mut rng = test_rng_seed(1592);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0xDDu8; 32];

    let mut ct = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);
    let tag_original = ct.compute_auth_tag(&mac_key);

    // Modify scale
    ct.scale *= 2.0;
    let tag_modified = ct.compute_auth_tag(&mac_key);

    assert_ne!(
        tag_original, tag_modified,
        "Auth tag should change when scale is modified"
    );
}

// =============================================================================
// SECTION 16: Compression of Ciphertexts at Different Levels (R15-VULN-16)
// =============================================================================
// Vulnerability: Compressing a ciphertext at level 0 (3 primes) vs level 2
// (1 prime) should produce different sizes and both decompress correctly.

/// R15-VULN-16a: Compress/decompress ciphertext at level 0.
#[test]
fn r15_compress_fresh_ciphertext() {
    let mut rng = test_rng_seed(1600);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_simd(&[1.0, 2.0], &pk_b, &pk_a, &ctx, &mut rng);
    let compressed = compress::compress(&ct).unwrap();
    let ct2: RnsCiphertext = compress::decompress(&compressed).unwrap();

    assert_eq!(ct.c0.num_primes, ct2.c0.num_primes);
    assert_eq!(ct.level, ct2.level);

    let dec = rns_decrypt_simd(&ct2, &s, &ctx, 2);
    assert!(
        (dec[0] - 1.0).abs() < 0.1,
        "Fresh ct compress roundtrip: expected ~1.0, got {}",
        dec[0]
    );
}

/// R15-VULN-16b: Compress/decompress ciphertext after mod-switch.
#[test]
fn r15_compress_mod_switched_ciphertext() {
    let mut rng = test_rng_seed(1601);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_simd(&[3.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct_switched = rns_ct_mod_switch_to(&ct, 2);

    let compressed = compress::compress(&ct_switched).unwrap();
    let ct2: RnsCiphertext = compress::decompress(&compressed).unwrap();

    assert_eq!(ct2.c0.num_primes, 2);
    let dec = rns_decrypt_simd(&ct2, &s, &ctx, 1);
    assert!(
        (dec[0] - 3.0).abs() < 0.5,
        "Mod-switched compress roundtrip: expected ~3.0, got {}",
        dec[0]
    );
}

/// R15-VULN-16c: Smaller ciphertext (fewer primes) compresses to smaller size.
#[test]
fn r15_fewer_primes_smaller_compressed() {
    let mut rng = test_rng_seed(1602);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct_5 = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct_2 = rns_ct_mod_switch_to(&ct_5, 2);

    let compressed_5 = compress::compress(&ct_5).unwrap();
    let compressed_2 = compress::compress(&ct_2).unwrap();

    assert!(
        compressed_2.len() < compressed_5.len(),
        "2-prime ct ({} bytes) should compress smaller than 5-prime ct ({} bytes)",
        compressed_2.len(),
        compressed_5.len()
    );
}

// =============================================================================
// SECTION 17: Galois Element Computation Edge Cases (R15-VULN-17)
// =============================================================================
// Vulnerability: rotation_to_galois computes g^r mod 2N. Edge cases include
// rotation=0 (identity), rotation=NUM_SLOTS (full cycle), negative rotations.

/// R15-VULN-17a: Rotation 0 maps to identity galois element 1.
#[test]
fn r15_rotation_zero_is_identity() {
    let galois = rotation_to_galois(0);
    assert_eq!(galois, 1, "Rotation 0 should be identity (galois=1)");
}

/// R15-VULN-17b: Rotation by NUM_SLOTS is equivalent to identity.
#[test]
fn r15_rotation_num_slots_is_identity() {
    let slots = N / 2; // 2048
    let galois = rotation_to_galois(slots as i32);
    assert_eq!(
        galois, 1,
        "Rotation by NUM_SLOTS should wrap to identity"
    );
}

/// R15-VULN-17c: Negative rotation is equivalent to positive rotation in opposite direction.
#[test]
fn r15_negative_rotation_equivalent() {
    let slots = N / 2; // 2048
    // Rotation by -1 should be equivalent to rotation by (slots - 1)
    let galois_neg1 = rotation_to_galois(-1);
    let galois_pos = rotation_to_galois((slots as i32) - 1);
    assert_eq!(
        galois_neg1, galois_pos,
        "Rotation -1 should equal rotation {}: got {} vs {}",
        slots - 1, galois_neg1, galois_pos
    );
}

/// R15-VULN-17d: Rotation by 1 maps to GALOIS_GEN (5).
#[test]
fn r15_rotation_one_is_galois_gen() {
    let galois = rotation_to_galois(1);
    assert_eq!(
        galois, 5,
        "Rotation 1 should map to generator 5, got {}",
        galois
    );
}

// =============================================================================
// SECTION 18: RnsPoly::from_coeffs with Fewer Than N Coefficients (R15-VULN-18)
// =============================================================================
// Vulnerability: from_coeffs zero-pads to N coefficients. Verify this works
// for various input lengths.

/// R15-VULN-18a: from_coeffs with empty input produces zero polynomial.
#[test]
fn r15_from_coeffs_empty() {
    let poly = RnsPoly::from_coeffs(&[], 2);
    let coeffs = poly.to_coeffs();
    for &c in &coeffs {
        assert_eq!(c, 0, "Empty input should produce zero polynomial");
    }
}

/// R15-VULN-18b: from_coeffs with single coefficient.
#[test]
fn r15_from_coeffs_single() {
    let poly = RnsPoly::from_coeffs(&[42], 3);
    let coeffs = poly.to_coeffs();
    assert_eq!(coeffs[0], 42);
    for i in 1..N {
        assert_eq!(coeffs[i], 0, "Non-zero at position {} (should be zero-padded)", i);
    }
}

/// R15-VULN-18c: from_coeffs with exactly N coefficients.
#[test]
fn r15_from_coeffs_full() {
    let input: Vec<i64> = (0..N as i64).map(|i| (i * 7 + 3) % 100 - 50).collect();
    let poly = RnsPoly::from_coeffs(&input, 3);
    let coeffs = poly.to_coeffs();
    for i in 0..N {
        assert_eq!(coeffs[i], input[i], "Mismatch at position {}", i);
    }
}

// =============================================================================
// SECTION 19: rns_ct_mul_plain_simd with All-Zero Plaintext (R15-VULN-19)
// =============================================================================
// Vulnerability: Multiplying by an all-zero plaintext should zero out the
// ciphertext. This is a valid but potentially dangerous operation.

/// R15-VULN-19a: Multiply by zero plaintext zeros out the message.
#[test]
fn r15_mul_plain_zero_zeros_message() {
    let mut rng = test_rng_seed(1610);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_simd(&[5.0, 10.0, 15.0], &pk_b, &pk_a, &ctx, &mut rng);
    let zeros = vec![0.0; simd::NUM_SLOTS];
    let ct_zero = rns_ct_mul_plain_simd(&ct, &zeros, &ctx);

    // After multiply by zero and rescale, result should be ~0
    let ct_rescaled = rns_rescale(&ct_zero);
    let dec = rns_decrypt_simd(&ct_rescaled, &s, &ctx, 3);
    for i in 0..3 {
        assert!(
            dec[i].abs() < 1.0,
            "Mul by zero slot {}: expected ~0.0, got {}",
            i, dec[i]
        );
    }
}

/// R15-VULN-19b: Multiply by one plaintext preserves message (approximately).
#[test]
fn r15_mul_plain_one_preserves_message() {
    let mut rng = test_rng_seed(1611);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let values = vec![5.0, -3.0, 7.5, 0.0];
    let ct = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);
    let ones = vec![1.0; simd::NUM_SLOTS];
    let ct_one = rns_ct_mul_plain_simd(&ct, &ones, &ctx);
    let ct_rescaled = rns_rescale(&ct_one);

    let dec = rns_decrypt_simd(&ct_rescaled, &s, &ctx, 4);
    for i in 0..4 {
        assert!(
            (dec[i] - values[i]).abs() < 1.0,
            "Mul by one slot {}: expected ~{}, got {}",
            i, values[i], dec[i]
        );
    }
}

// =============================================================================
// SECTION 20: Auth Tag with Mismatched c0/c1 Primes (R15-VULN-20)
// =============================================================================
// Vulnerability: A crafted ciphertext with c0.num_primes != c1.num_primes
// should be caught by auth tag verification (the tag includes both counts).

/// R15-VULN-20a: Auth tag includes both c0 and c1 prime counts.
#[test]
fn r15_auth_tag_binds_c0_c1_prime_counts() {
    let mut rng = test_rng_seed(1620);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0xFFu8; 32];

    let mut ct = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    assert!(ct.verify_auth(&mac_key));

    let tag_original = ct.auth_tag.unwrap();

    // Compute what tag would be if c0 had different num_primes
    // (by creating a modified ciphertext)
    let ct_modified = RnsCiphertext {
        c0: ct.c0.clone(),
        c1: RnsPoly {
            residues: ct.c1.residues[..2].to_vec(), // Truncate to 2 primes
            num_primes: 2,
        },
        scale: ct.scale,
        level: ct.level,
        auth_tag: Some(tag_original),
    };

    // The original tag should NOT verify on the modified ciphertext
    assert!(
        !ct_modified.verify_auth(&mac_key),
        "Auth tag should not verify when c1 prime count is changed"
    );
}

/// R15-VULN-20b: Auth tag changes when level field is modified.
#[test]
fn r15_auth_tag_binds_level() {
    let mut rng = test_rng_seed(1621);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0xEEu8; 32];

    let mut ct = rns_encrypt_simd(&[2.0], &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    let tag = ct.auth_tag.unwrap();

    // Modify level
    let ct_modified = RnsCiphertext {
        c0: ct.c0.clone(),
        c1: ct.c1.clone(),
        scale: ct.scale,
        level: ct.level + 1, // Changed level
        auth_tag: Some(tag),
    };

    assert!(
        !ct_modified.verify_auth(&mac_key),
        "Auth tag should not verify when level is changed"
    );
}

// =============================================================================
// SECTION 21: Plaintext Forward with Single Layer Identity (R15-VULN-21)
// =============================================================================

/// R15-VULN-21a: Plaintext forward with identity matrix + zero bias = input.
#[test]
fn r15_plaintext_forward_identity() {
    let d = 4;
    let mut identity = vec![0.0; d * d];
    for i in 0..d {
        identity[i * d + i] = 1.0;
    }
    let net = RnsNeuralNet {
        dim: d,
        weights: vec![identity],
        biases: vec![vec![0.0; d]],
        activations: vec![Activation::None],
    };

    let input = vec![1.0, 2.0, 3.0, 4.0];
    let result = rns_plaintext_forward(&input, &net);
    for i in 0..d {
        assert!(
            (result[i] - input[i]).abs() < 1e-10,
            "Identity layer slot {}: expected {}, got {}",
            i, input[i], result[i]
        );
    }
}

/// R15-VULN-21b: Plaintext forward with identity matrix + nonzero bias.
#[test]
fn r15_plaintext_forward_identity_with_bias() {
    let d = 4;
    let mut identity = vec![0.0; d * d];
    for i in 0..d {
        identity[i * d + i] = 1.0;
    }
    let biases = vec![10.0, 20.0, 30.0, 40.0];
    let net = RnsNeuralNet {
        dim: d,
        weights: vec![identity],
        biases: vec![biases.clone()],
        activations: vec![Activation::None],
    };

    let input = vec![1.0, 2.0, 3.0, 4.0];
    let result = rns_plaintext_forward(&input, &net);
    for i in 0..d {
        let expected = input[i] + biases[i];
        assert!(
            (result[i] - expected).abs() < 1e-10,
            "Identity+bias slot {}: expected {}, got {}",
            i, expected, result[i]
        );
    }
}

// =============================================================================
// SECTION 22: Compression Entropy Check on Fresh Ciphertext (R15-VULN-22)
// =============================================================================

/// R15-VULN-22a: Fresh ciphertext passes entropy check.
#[test]
fn r15_fresh_ciphertext_passes_entropy() {
    let mut rng = test_rng_seed(1630);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_simd(&[1.0, 2.0, 3.0], &pk_b, &pk_a, &ctx, &mut rng);
    let check = compress::entropy_check(&ct);

    assert!(
        check.pass,
        "Fresh ciphertext should pass entropy check: ratio={:.2}",
        check.ratio
    );
}

/// R15-VULN-22b: Zero polynomial (trivial ciphertext) fails entropy check.
#[test]
fn r15_zero_poly_fails_entropy() {
    let c0 = RnsPoly::zero(3);
    let c1 = RnsPoly::zero(3);
    let ct = RnsCiphertext {
        c0,
        c1,
        scale: (1u64 << 36) as f64,
        level: 0,
        auth_tag: None,
    };
    let check = compress::entropy_check(&ct);

    assert!(
        !check.pass,
        "All-zero ciphertext should fail entropy check: ratio={:.2}",
        check.ratio
    );
}

// =============================================================================
// SECTION 23: NTT Forward/Inverse with Single Nonzero Coefficient (R15-VULN-23)
// =============================================================================

/// R15-VULN-23a: NTT roundtrip with only the constant term nonzero.
#[test]
fn r15_ntt_single_constant_roundtrip() {
    let ctx = NttContext::new(NTT_PRIMES[0]);
    let mut a = vec![0i64; N];
    a[0] = 12345;
    let ntt_a = ctx.forward(&a);
    let back = ctx.inverse(&ntt_a);
    assert_eq!(ctx.center(back[0]), 12345);
    for i in 1..N {
        assert_eq!(ctx.center(back[i]), 0, "Non-zero at {}", i);
    }
}

/// R15-VULN-23b: NTT roundtrip with only the last coefficient nonzero.
#[test]
fn r15_ntt_single_last_coeff_roundtrip() {
    let ctx = NttContext::new(NTT_PRIMES[0]);
    let q = NTT_PRIMES[0];
    let mut a = vec![0i64; N];
    a[N - 1] = 99;
    let ntt_a = ctx.forward(&a);
    let back = ctx.inverse(&ntt_a);
    assert_eq!(ctx.center(back[N - 1]), 99);
    for i in 0..N - 1 {
        assert_eq!(ctx.center(back[i]), 0, "Non-zero at {}", i);
    }
}

/// R15-VULN-23c: NTT roundtrip with coefficient at q-1 (maximum value).
#[test]
fn r15_ntt_max_coefficient_roundtrip() {
    let q = NTT_PRIMES[0];
    let ctx = NttContext::new(q);
    let mut a = vec![0i64; N];
    a[0] = q - 1; // Maximum value in [0, q)
    let ntt_a = ctx.forward(&a);
    let back = ctx.inverse(&ntt_a);
    assert_eq!(back[0], q - 1, "Max coefficient not preserved");
    for i in 1..N {
        assert_eq!(ctx.center(back[i]), 0, "Non-zero at {}", i);
    }
}

// =============================================================================
// SECTION 24: Replicate Vector Edge Cases (R15-VULN-24)
// =============================================================================

/// R15-VULN-24a: replicate_vector with values.len() < d (zero-padded).
#[test]
fn r15_replicate_vector_zero_padded() {
    let values = vec![1.0, 2.0]; // 2 values
    let d = 4; // dimension is 4
    let rep = replicate_vector(&values, d);

    // Expected pattern: [1, 2, 0, 0, 1, 2, 0, 0, ...]
    assert_eq!(rep.len(), simd::NUM_SLOTS);
    for i in 0..simd::NUM_SLOTS {
        let slot = i % d;
        let expected = if slot < values.len() { values[slot] } else { 0.0 };
        assert!(
            (rep[i] - expected).abs() < 1e-10,
            "replicate slot {}: expected {}, got {}",
            i, expected, rep[i]
        );
    }
}

/// R15-VULN-24b: replicate_vector with d=1 (broadcast single value).
#[test]
fn r15_replicate_vector_single_element() {
    let values = vec![7.0];
    let rep = replicate_vector(&values, 1);
    for i in 0..simd::NUM_SLOTS {
        assert!(
            (rep[i] - 7.0).abs() < 1e-10,
            "Broadcast slot {}: expected 7.0, got {}",
            i, rep[i]
        );
    }
}

// =============================================================================
// SECTION 25: Ciphertext Subtraction Self-Cancellation (R15-VULN-25)
// =============================================================================

/// R15-VULN-25a: ct - ct should give approximately zero.
#[test]
fn r15_self_subtraction_gives_zero() {
    let mut rng = test_rng_seed(1640);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let values = vec![100.0, -50.0, 25.0, 0.0];
    let ct = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_zero = rns_ct_sub(&ct, &ct);

    let dec = rns_decrypt_simd(&ct_zero, &s, &ctx, 4);
    for i in 0..4 {
        assert!(
            dec[i].abs() < 0.01,
            "Self-sub slot {}: expected ~0.0, got {}",
            i, dec[i]
        );
    }
}

// =============================================================================
// SECTION 26: Compression Level Detection (R15-VULN-26)
// =============================================================================

/// R15-VULN-26a: detect_level returns correct level for all formats.
#[test]
fn r15_detect_level_all_formats() {
    let data: Vec<i64> = (0..100).collect();

    let v1 = compress::compress(&data).unwrap();
    assert_eq!(compress::detect_level(&v1), Some(CompressionLevel::Lossless));

    let v2_compact = compress::compress_with(&data, CompressionLevel::Compact).unwrap();
    assert_eq!(compress::detect_level(&v2_compact), Some(CompressionLevel::Compact));

    let v2_max = compress::compress_with(&data, CompressionLevel::Max).unwrap();
    assert_eq!(compress::detect_level(&v2_max), Some(CompressionLevel::Max));
}

/// R15-VULN-26b: detect_level returns None for non-PFHE data.
#[test]
fn r15_detect_level_non_pfhe() {
    assert_eq!(compress::detect_level(b"not compressed"), None);
    assert_eq!(compress::detect_level(&[]), None);
    assert_eq!(compress::detect_level(b"PFHE"), None); // Too short
}

/// R15-VULN-26c: is_compressed correctly identifies PFHE data.
#[test]
fn r15_is_compressed_detection() {
    let data: Vec<i64> = (0..50).collect();
    let compressed = compress::compress(&data).unwrap();
    assert!(compress::is_compressed(&compressed));
    assert!(!compress::is_compressed(b"random data"));
    assert!(!compress::is_compressed(&[]));
}

// =============================================================================
// SECTION 27: Mod-Switch Preserves Value (R15-VULN-27)
// =============================================================================

/// R15-VULN-27a: Mod-switch from 5 to 3 primes preserves encrypted value.
#[test]
fn r15_mod_switch_preserves_value() {
    let mut rng = test_rng_seed(1650);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let values = vec![3.14, -2.7, 1.0, 0.5];
    let ct = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);

    let ct_switched = rns_ct_mod_switch_to(&ct, 3);
    assert_eq!(ct_switched.c0.num_primes, 3);

    let dec_original = rns_decrypt_simd(&ct, &s, &ctx, 4);
    let dec_switched = rns_decrypt_simd(&ct_switched, &s, &ctx, 4);

    for i in 0..4 {
        assert!(
            (dec_original[i] - dec_switched[i]).abs() < 0.01,
            "Mod-switch slot {}: original {:.4} vs switched {:.4}",
            i, dec_original[i], dec_switched[i]
        );
    }
}

/// R15-VULN-27b: Mod-switch to same number of primes returns clone.
#[test]
fn r15_mod_switch_identity() {
    let mut rng = test_rng_seed(1651);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_simd(&[5.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct_same = rns_ct_mod_switch_to(&ct, 3);

    // Should be identical
    assert_eq!(ct_same.c0.num_primes, ct.c0.num_primes);
    assert_eq!(ct_same.level, ct.level);
    assert_eq!(ct_same.scale, ct.scale);
}

// =============================================================================
// SECTION 28: Poly Eval Plain Reference (R15-VULN-28)
// =============================================================================

/// R15-VULN-28a: poly_eval_plain with constant polynomial.
#[test]
fn r15_poly_eval_plain_constant() {
    let result = poly_eval::poly_eval_plain(100.0, &[42.0]);
    assert!((result - 42.0).abs() < 1e-10, "Constant poly: expected 42, got {}", result);
}

/// R15-VULN-28b: poly_eval_plain with linear polynomial.
#[test]
fn r15_poly_eval_plain_linear() {
    // P(x) = 3 + 2x at x=5 -> 13
    let result = poly_eval::poly_eval_plain(5.0, &[3.0, 2.0]);
    assert!((result - 13.0).abs() < 1e-10, "Linear poly: expected 13, got {}", result);
}

/// R15-VULN-28c: poly_eval_plain with x=0 returns constant term.
#[test]
fn r15_poly_eval_plain_at_zero() {
    let coeffs = [7.0, 3.0, 2.0, 1.0];
    let result = poly_eval::poly_eval_plain(0.0, &coeffs);
    assert!((result - 7.0).abs() < 1e-10, "P(0) should be constant term: got {}", result);
}

// =============================================================================
// SECTION 29: Ciphertext with No Auth Tag Fails verify_auth (R15-VULN-29)
// =============================================================================

/// R15-VULN-29a: Ciphertext without auth tag fails verify_auth.
#[test]
fn r15_no_auth_tag_fails_verify() {
    let mut rng = test_rng_seed(1660);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0xAAu8; 32];

    let ct = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);
    assert!(ct.auth_tag.is_none(), "Fresh ct should have no auth tag");
    assert!(!ct.verify_auth(&mac_key), "No auth tag should fail verification");
}

/// R15-VULN-29b: Empty MAC key (all zeros) still produces valid tag.
#[test]
fn r15_zero_mac_key_valid_tag() {
    let mut rng = test_rng_seed(1661);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0u8; 32];

    let mut ct = rns_encrypt_simd(&[1.0], &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    assert!(ct.verify_auth(&mac_key), "Zero MAC key should still produce valid tag");
}

// =============================================================================
// SECTION 30: Encrypt and Decrypt SIMD with Various Slot Counts (R15-VULN-30)
// =============================================================================

/// R15-VULN-30a: Encrypt 1 value, decrypt asking for more slots.
#[test]
fn r15_encrypt_few_decrypt_more() {
    let mut rng = test_rng_seed(1670);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    // Encrypt with 1 value (other slots are zero-padded by encode_simd)
    let ct = rns_encrypt_simd(&[7.0], &pk_b, &pk_a, &ctx, &mut rng);

    // Decrypt asking for 4 slots
    let dec = rns_decrypt_simd(&ct, &s, &ctx, 4);
    assert!(
        (dec[0] - 7.0).abs() < 0.1,
        "Slot 0: expected ~7.0, got {}",
        dec[0]
    );
    // Other slots should be approximately 0
    for i in 1..4 {
        assert!(
            dec[i].abs() < 0.1,
            "Slot {}: expected ~0.0, got {}",
            i, dec[i]
        );
    }
}

/// R15-VULN-30b: Encrypt NUM_SLOTS values and decrypt all.
#[test]
fn r15_encrypt_full_slots() {
    let mut rng = test_rng_seed(1671);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let values: Vec<f64> = (0..simd::NUM_SLOTS)
        .map(|i| (i as f64 * 0.1).sin())
        .collect();
    let ct = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);
    let dec = rns_decrypt_simd(&ct, &s, &ctx, simd::NUM_SLOTS);

    let max_err = values
        .iter()
        .zip(dec.iter())
        .map(|(a, b)| (a - b).abs())
        .fold(0.0f64, f64::max);
    assert!(
        max_err < 0.1,
        "Full-slot roundtrip max error {} too large",
        max_err
    );
}
