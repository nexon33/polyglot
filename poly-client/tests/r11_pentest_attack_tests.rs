//! Round 11 Penetration Test — Attack Tests for poly-client
//!
//! Focus areas:
//! - rns_ct_mod_switch_to missing c0/c1 consistency check (R11-VULN-01)
//! - rns_rescale missing c0/c1 consistency check (R11-VULN-02)
//! - rns_ct_add_leveled scale averaging without compatibility check (R11-VULN-03)
//! - encode_simd / decode_simd missing delta/scale validation (R11-VULN-04)
//! - replicate_vector values.len() > d silent truncation (R11-VULN-05)
//! - Compression v2 level_byte not validated on decompress (R11-VULN-06)
//! - rns_rotate missing c0/c1 consistency check (R11-VULN-07)
//! - Scale chain corruption via crafted operation sequences (R11-VULN-08)

#![cfg(feature = "ckks")]
#![allow(unused_variables)]

use poly_client::ckks::compress::{self, CompressionLevel};
use poly_client::ckks::rns::RnsPoly;
use poly_client::ckks::rns_ckks::*;
use poly_client::ckks::simd;

use rand::rngs::StdRng;
use rand::SeedableRng;

fn test_rng_seed(seed: u64) -> StdRng {
    StdRng::seed_from_u64(seed)
}

// =============================================================================
// SECTION 1: rns_ct_mod_switch_to missing c0/c1 consistency (HIGH)
// =============================================================================

/// R11-VULN-01a: rns_ct_mod_switch_to did not validate that c0 and c1 have
/// matching prime counts. A crafted ciphertext with c0.num_primes=5 and
/// c1.num_primes=2 would pass the target_primes check (which only looked at
/// c0.num_primes), then rns_truncate(&ct.c1, target_primes=3) would try to
/// take residues[..3] from a c1 that only has 2 residue channels, causing
/// an out-of-bounds panic with an unhelpful error message.
#[test]
#[should_panic(expected = "rns_ct_mod_switch_to: c0 has")]
fn r11_mod_switch_c0_c1_prime_mismatch_c1_fewer() {
    let mut rng = test_rng_seed(11001);
    let ctx = RnsCkksContext::new(5);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Tamper: truncate c1 to only 2 primes while c0 remains at 5
    ct.c1 = RnsPoly {
        residues: ct.c1.residues[..2].to_vec(),
        num_primes: 2,
    };

    // Pre-R11: would try rns_truncate(&ct.c1, 3) which panics with index OOB
    let _ = rns_ct_mod_switch_to(&ct, 3);
}

/// R11-VULN-01b: Same vulnerability but c1 has MORE primes than c0.
/// The mod-switch checks target_primes <= ct.c0.num_primes (which is small)
/// but c1 has extra residue channels. The result would have c0 truncated
/// correctly but c1 would retain extra channels that don't belong.
#[test]
#[should_panic(expected = "rns_ct_mod_switch_to: c0 has")]
fn r11_mod_switch_c0_c1_prime_mismatch_c1_more() {
    let mut rng = test_rng_seed(11002);
    let ctx = RnsCkksContext::new(5);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Tamper: truncate c0 to 3 primes while c1 stays at 5
    ct.c0 = RnsPoly {
        residues: ct.c0.residues[..3].to_vec(),
        num_primes: 3,
    };

    // Pre-R11: target=3 (min of 3,5), mod-switch c0 from 3->3 (noop),
    // mod-switch c1 from 5->3 (truncate) — silent mismatch in the input
    let _ = rns_ct_mod_switch_to(&ct, 3);
}

/// Verify that matching c0/c1 prime counts still work.
#[test]
fn r11_mod_switch_matching_primes_ok() {
    let mut rng = test_rng_seed(11003);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(3.14, &pk_b, &pk_a, &ctx, &mut rng);
    assert_eq!(ct.c0.num_primes, 5);
    assert_eq!(ct.c1.num_primes, 5);

    let ct_switched = rns_ct_mod_switch_to(&ct, 3);
    assert_eq!(ct_switched.c0.num_primes, 3);
    assert_eq!(ct_switched.c1.num_primes, 3);

    let result = rns_decrypt_f64(&ct_switched, &s, &ctx);
    assert!((result - 3.14).abs() < 0.1, "mod-switch should preserve value, got {}", result);
}

// =============================================================================
// SECTION 2: rns_rescale missing c0/c1 consistency (HIGH)
// =============================================================================

/// R11-VULN-02a: rns_rescale did not validate c0/c1 consistency.
/// A crafted ciphertext with c0.num_primes=3 but c1.num_primes=2 would have
/// c0 drop prime index 2 (its last) while c1 drops prime index 1 (its last).
/// The resulting ciphertext has c0 in modulus {q0,q1} and c1 in modulus {q0},
/// producing an incompatible ciphertext that corrupts all downstream operations.
#[test]
#[should_panic(expected = "rns_rescale: c0 has")]
fn r11_rescale_c0_c1_prime_mismatch() {
    let mut rng = test_rng_seed(11010);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    // Create a legitimate ciphertext and do ct*ct to get one at scale delta^2
    let ct = rns_encrypt_f64(2.0, &pk_b, &pk_a, &ctx, &mut rng);
    let mut ct_mul = rns_ct_mul_relin(&ct, &ct, &evk, &ctx);

    // Tamper: truncate c1 to fewer primes
    ct_mul.c1 = RnsPoly {
        residues: ct_mul.c1.residues[..3].to_vec(),
        num_primes: 3,
    };

    // Pre-R11: c0 would drop prime 4, c1 would drop prime 2 — incompatible chains
    let _ = rns_rescale(&ct_mul);
}

/// R11-VULN-02b: Verify rescale with matching primes still works.
#[test]
fn r11_rescale_matching_primes_ok() {
    let mut rng = test_rng_seed(11011);
    let ctx = RnsCkksContext::new(4);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct = rns_encrypt_f64(3.0, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_mul = rns_ct_mul_relin(&ct, &ct, &evk, &ctx);
    let ct_rescaled = rns_rescale(&ct_mul);

    assert_eq!(ct_rescaled.c0.num_primes, ct_rescaled.c1.num_primes);
    let result = rns_decrypt_f64(&ct_rescaled, &s, &ctx);
    assert!((result - 9.0).abs() < 0.5, "3^2 should be ~9.0, got {}", result);
}

// =============================================================================
// SECTION 3: rns_ct_add_leveled scale averaging without compatibility (HIGH)
// =============================================================================

/// R11-VULN-03a: rns_ct_add_leveled used scale averaging without checking
/// that the two scales are approximately equal. If a.scale = delta (~2^36)
/// and b.scale = delta^2 (~2^72), the average is ~2^71.5, which is neither
/// correct for a nor for b. Decryption at this scale produces garbage.
#[test]
#[should_panic(expected = "rns_ct_add_leveled: scale mismatch too large")]
fn r11_add_leveled_scale_mismatch_rejected() {
    let mut rng = test_rng_seed(11020);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    // ct_a at scale delta (fresh)
    let ct_a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // ct_b at scale delta^2 (after ct*ct, NOT rescaled)
    let ct_b_fresh = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_b = rns_ct_mul_relin(&ct_b_fresh, &ct_b_fresh, &evk, &ctx);
    // ct_b.scale = delta^2 ≈ 2^72

    // Pre-R11: average of delta and delta^2 = (2^36 + 2^72) / 2 ≈ 2^71.5
    // This is meaningless — decryption would produce garbage
    let _ = rns_ct_add_leveled(&ct_a, &ct_b);
}

/// R11-VULN-03b: Verify that approximately equal scales still work.
/// After rescaling, two ciphertexts at different levels have scales that
/// are approximately equal (both ≈ delta due to scale = delta^2 / q_i).
#[test]
fn r11_add_leveled_approx_equal_scales_ok() {
    let mut rng = test_rng_seed(11021);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct_a = rns_encrypt_f64(2.0, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_b = rns_encrypt_f64(3.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Both at same scale (delta) — should work
    let ct_sum = rns_ct_add_leveled(&ct_a, &ct_b);
    let result = rns_decrypt_f64(&ct_sum, &s, &ctx);
    assert!((result - 5.0).abs() < 0.1, "2+3 should be ~5.0, got {}", result);
}

/// R11-VULN-03c: Verify that scales differing by exactly 2x are rejected.
#[test]
#[should_panic(expected = "rns_ct_add_leveled: scale mismatch too large")]
fn r11_add_leveled_scale_double_rejected() {
    let mut rng = test_rng_seed(11022);
    let ctx = RnsCkksContext::new(5);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct_a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let mut ct_b = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Artificially set b's scale to exactly 2x a's scale
    ct_b.scale = ct_a.scale * 2.0;

    let _ = rns_ct_add_leveled(&ct_a, &ct_b);
}

// =============================================================================
// SECTION 4: encode_simd / decode_simd missing delta/scale validation (MEDIUM)
// =============================================================================

/// R11-VULN-04a: encode_simd did not validate delta. A NaN delta produces
/// NaN coefficients after scaling, which round to 0 as i64 (platform-dependent),
/// silently destroying the encoded values.
#[test]
#[should_panic(expected = "encode_simd: delta must be finite and positive")]
fn r11_encode_simd_nan_delta_rejected() {
    let values = vec![1.0, 2.0, 3.0];
    let _ = simd::encode_simd(&values, f64::NAN);
}

/// R11-VULN-04b: encode_simd with Inf delta.
#[test]
#[should_panic(expected = "encode_simd: delta must be finite and positive")]
fn r11_encode_simd_inf_delta_rejected() {
    let values = vec![1.0, 2.0];
    let _ = simd::encode_simd(&values, f64::INFINITY);
}

/// R11-VULN-04c: encode_simd with zero delta.
#[test]
#[should_panic(expected = "encode_simd: delta must be finite and positive")]
fn r11_encode_simd_zero_delta_rejected() {
    let values = vec![1.0];
    let _ = simd::encode_simd(&values, 0.0);
}

/// R11-VULN-04d: encode_simd with negative delta.
#[test]
#[should_panic(expected = "encode_simd: delta must be finite and positive")]
fn r11_encode_simd_negative_delta_rejected() {
    let values = vec![1.0, 2.0];
    let _ = simd::encode_simd(&values, -1.0);
}

/// R11-VULN-04e: decode_simd did not validate scale. Dividing by NaN/Inf/zero
/// produces garbage values. While rns_decrypt_simd validates ct.scale,
/// decode_simd is public and can be called directly.
#[test]
#[should_panic(expected = "decode_simd: scale must be finite and positive")]
fn r11_decode_simd_nan_scale_rejected() {
    let coeffs = vec![0i64; 4096];
    let _ = simd::decode_simd(&coeffs, f64::NAN, 1);
}

/// R11-VULN-04f: decode_simd with zero scale.
#[test]
#[should_panic(expected = "decode_simd: scale must be finite and positive")]
fn r11_decode_simd_zero_scale_rejected() {
    let coeffs = vec![0i64; 4096];
    let _ = simd::decode_simd(&coeffs, 0.0, 1);
}

/// R11-VULN-04g: decode_simd with negative scale.
#[test]
#[should_panic(expected = "decode_simd: scale must be finite and positive")]
fn r11_decode_simd_negative_scale_rejected() {
    let coeffs = vec![0i64; 4096];
    let _ = simd::decode_simd(&coeffs, -100.0, 1);
}

/// Verify that valid encode/decode still works.
#[test]
fn r11_encode_decode_simd_valid_roundtrip() {
    let values = vec![1.0, -2.5, 3.14, 0.0, 100.0];
    let delta = (1u64 << 30) as f64;
    let coeffs = simd::encode_simd(&values, delta);
    let decoded = simd::decode_simd(&coeffs, delta, values.len());
    for (i, (&expected, &got)) in values.iter().zip(decoded.iter()).enumerate() {
        assert!(
            (expected - got).abs() < 0.01,
            "slot {} encode/decode: expected {}, got {}",
            i, expected, got
        );
    }
}

// =============================================================================
// SECTION 5: replicate_vector values.len() > d silent truncation (MEDIUM)
// =============================================================================

/// R11-VULN-05a: replicate_vector with values.len() > d would silently
/// ignore values beyond index d. For example, replicate_vector(&[1,2,3,4], 2)
/// would use only values[0..2] = [1,2] and silently discard [3,4].
/// This is a logic error that should be caught at the call site.
#[test]
#[should_panic(expected = "replicate_vector: values.len()")]
fn r11_replicate_vector_values_exceed_dim() {
    let values = vec![1.0, 2.0, 3.0, 4.0];
    let _ = replicate_vector(&values, 2); // d=2 but 4 values
}

/// R11-VULN-05b: Edge case — values.len() == d+1 (off by one).
#[test]
#[should_panic(expected = "replicate_vector: values.len()")]
fn r11_replicate_vector_off_by_one() {
    let values = vec![1.0, 2.0, 3.0];
    let _ = replicate_vector(&values, 2); // d=2 but 3 values
}

/// Verify that values.len() == d still works.
#[test]
fn r11_replicate_vector_exact_fit_ok() {
    let values = vec![1.0, 2.0, 3.0, 4.0];
    let replicated = replicate_vector(&values, 4);
    assert_eq!(replicated.len(), simd::NUM_SLOTS);
    // Check pattern repeats correctly
    for i in 0..simd::NUM_SLOTS {
        assert_eq!(replicated[i], values[i % 4]);
    }
}

/// R11-VULN-05c: values.len() < d previously caused index out-of-bounds in values[i % d].
/// R13 fixed this by bounds-checking the index and zero-padding missing slots.
/// Now values.len() < d is valid: positions where (i%d) >= values.len() are zero-padded.
#[test]
fn r11_replicate_vector_fewer_values_panics() {
    let values = vec![1.0, 2.0];
    // R13 fix: this no longer panics — positions 2,3 in each d=4 block are zero-padded
    let rep = replicate_vector(&values, 4);
    assert_eq!(rep[0], 1.0);
    assert_eq!(rep[1], 2.0);
    assert_eq!(rep[2], 0.0); // zero-padded
    assert_eq!(rep[3], 0.0); // zero-padded
}

// =============================================================================
// SECTION 6: Compression v2 level_byte validation (MEDIUM)
// =============================================================================

/// R11-VULN-06a: decompress_v2_raw accepted any level_byte (0, 3, 255, etc.)
/// without validation. detect_level returns None for these, but decompress
/// would succeed — creating an inconsistency where a caller checking
/// detect_level before decompress gets mismatched results.
#[test]
fn r11_compress_v2_invalid_level_byte_rejected() {
    // Create a valid Compact-compressed payload
    let data: Vec<i64> = (0..100).collect();
    let compressed = compress::compress_with(&data, CompressionLevel::Compact).unwrap();

    // Tamper: change level_byte from 1 (Compact) to 0 (invalid)
    let mut tampered = compressed.clone();
    tampered[5] = 0; // level_byte position in v2 header

    let result: Result<Vec<i64>, _> = compress::decompress(&tampered);
    assert!(
        result.is_err(),
        "v2 decompress should reject level_byte=0 (not a valid compression level)"
    );
}

/// R11-VULN-06b: level_byte = 3 (beyond valid range).
#[test]
fn r11_compress_v2_level_byte_3_rejected() {
    let data: Vec<i64> = (0..100).collect();
    let compressed = compress::compress_with(&data, CompressionLevel::Max).unwrap();

    let mut tampered = compressed.clone();
    tampered[5] = 3; // invalid level byte

    let result: Result<Vec<i64>, _> = compress::decompress(&tampered);
    assert!(result.is_err(), "v2 decompress should reject level_byte=3");
}

/// R11-VULN-06c: level_byte = 255 (extreme invalid).
#[test]
fn r11_compress_v2_level_byte_255_rejected() {
    let data: Vec<i64> = (0..100).collect();
    let compressed = compress::compress_with(&data, CompressionLevel::Compact).unwrap();

    let mut tampered = compressed.clone();
    tampered[5] = 255;

    let result: Result<Vec<i64>, _> = compress::decompress(&tampered);
    assert!(result.is_err(), "v2 decompress should reject level_byte=255");
}

/// Verify valid level bytes 1 and 2 still work.
#[test]
fn r11_compress_v2_valid_level_bytes_ok() {
    let data: Vec<i64> = (0..100).collect();

    // Compact (level_byte=1)
    let compact = compress::compress_with(&data, CompressionLevel::Compact).unwrap();
    let decoded_compact: Vec<i64> = compress::decompress(&compact).unwrap();
    assert_eq!(data, decoded_compact);

    // Max (level_byte=2)
    let max = compress::compress_with(&data, CompressionLevel::Max).unwrap();
    let decoded_max: Vec<i64> = compress::decompress(&max).unwrap();
    assert_eq!(data, decoded_max);
}

/// Verify detect_level and decompress are now consistent.
#[test]
fn r11_compress_detect_level_decompress_consistency() {
    let data: Vec<i64> = (0..100).collect();
    let compressed = compress::compress_with(&data, CompressionLevel::Compact).unwrap();

    // If detect_level says it's valid, decompress should succeed
    let level = compress::detect_level(&compressed);
    assert_eq!(level, Some(CompressionLevel::Compact));
    let decoded: Vec<i64> = compress::decompress(&compressed).unwrap();
    assert_eq!(data, decoded);

    // Tamper level byte to invalid value
    let mut tampered = compressed.clone();
    tampered[5] = 99;

    // Both should now consistently reject
    let level = compress::detect_level(&tampered);
    assert_eq!(level, None, "detect_level should return None for invalid level_byte");
    let result: Result<Vec<i64>, _> = compress::decompress(&tampered);
    assert!(result.is_err(), "decompress should also reject invalid level_byte");
}

// =============================================================================
// SECTION 7: rns_rotate missing c0/c1 consistency check (HIGH)
// =============================================================================

/// R11-VULN-07a: rns_rotate did not validate c0/c1 prime count consistency.
/// It applies automorphism to both c0 and c1, then key-switches c1.
/// If c0 has 5 primes and c1 has 3, the key-switching decomposition uses
/// c1's 3-prime digit count, but the output accumulates into c0_new which
/// has 5 primes. The resulting ciphertext is internally inconsistent.
#[test]
#[should_panic(expected = "rns_rotate: c0 has")]
fn r11_rotate_c0_c1_prime_mismatch() {
    let mut rng = test_rng_seed(11070);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let rot_keys = rns_gen_rotation_keys(&s, &[1], &ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Tamper: truncate c1 to 3 primes
    ct.c1 = RnsPoly {
        residues: ct.c1.residues[..3].to_vec(),
        num_primes: 3,
    };

    // Pre-R11: automorphism would work on both (different prime counts),
    // then key-switching would produce inconsistent result
    let _ = rns_rotate(&ct, 1, &rot_keys, &ctx);
}

/// Verify rotation with matching primes still works.
#[test]
fn r11_rotate_matching_primes_ok() {
    let mut rng = test_rng_seed(11071);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let rot_keys = rns_gen_rotation_keys(&s, &[1, 2], &ctx, &mut rng);

    let input = vec![1.0, 2.0, 3.0, 4.0];
    let mut full_input = vec![0.0; simd::NUM_SLOTS];
    for (i, &v) in input.iter().enumerate() {
        full_input[i] = v;
    }
    let ct = rns_encrypt_simd(&full_input, &pk_b, &pk_a, &ctx, &mut rng);

    // Rotate by 1 should shift slots
    let ct_rot = rns_rotate(&ct, 1, &rot_keys, &ctx);
    let result = rns_decrypt_simd(&ct_rot, &s, &ctx, 4);

    // After rotating left by 1: slot[0] gets old slot[1], etc.
    assert!((result[0] - 2.0).abs() < 0.1, "slot 0 after rot-1 should be ~2.0, got {}", result[0]);
    assert!((result[1] - 3.0).abs() < 0.1, "slot 1 after rot-1 should be ~3.0, got {}", result[1]);
    assert!((result[2] - 4.0).abs() < 0.1, "slot 2 after rot-1 should be ~4.0, got {}", result[2]);
}

// =============================================================================
// SECTION 8: Scale chain corruption compound attacks (HIGH)
// =============================================================================

/// R11-VULN-08a: Chain through leveled multiply with c0/c1 mismatch.
/// rns_ct_mul_leveled computes target = min(a.c0.num_primes, b.c0.num_primes)
/// then mod-switches both to target. If a has mismatched c0/c1, mod-switch
/// would fail (post-R11) or produce garbage (pre-R11).
#[test]
#[should_panic(expected = "c0 has")]
fn r11_mul_leveled_c0_c1_mismatch_propagation() {
    let mut rng = test_rng_seed(11080);
    let ctx = RnsCkksContext::new(5);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct_a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_b = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Tamper ct_a: truncate c1 to 3 primes
    ct_a.c1 = RnsPoly {
        residues: ct_a.c1.residues[..3].to_vec(),
        num_primes: 3,
    };

    // rns_ct_mul_leveled -> rns_ct_mod_switch_to -> R11 check catches it
    let _ = rns_ct_mul_leveled(&ct_a, &ct_b, &ctx);
}

/// R11-VULN-08b: Chain through leveled add with c0/c1 mismatch.
#[test]
#[should_panic(expected = "c0 has")]
fn r11_add_leveled_c0_c1_mismatch_propagation() {
    let mut rng = test_rng_seed(11081);
    let ctx = RnsCkksContext::new(5);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct_a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_b = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    ct_a.c1 = RnsPoly {
        residues: ct_a.c1.residues[..3].to_vec(),
        num_primes: 3,
    };

    let _ = rns_ct_add_leveled(&ct_a, &ct_b);
}

/// R11-VULN-08c: Compound — tampered ciphertext passes through encrypt
/// then immediately to mod-switch, demonstrating end-to-end attack.
#[test]
#[should_panic(expected = "rns_ct_mod_switch_to: c0 has")]
fn r11_end_to_end_c0_c1_mismatch_attack() {
    let mut rng = test_rng_seed(11082);
    let ctx = RnsCkksContext::new(5);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(42.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Simulate deserialization attack: attacker modifies c1's prime count
    // in the serialized ciphertext before sending to the victim
    let serialized = bincode::serialize(&ct).unwrap();
    let mut ct_deserialized: RnsCiphertext = bincode::deserialize(&serialized).unwrap();

    // Tamper the deserialized ciphertext
    ct_deserialized.c1 = RnsPoly {
        residues: ct_deserialized.c1.residues[..2].to_vec(),
        num_primes: 2,
    };

    // Victim tries to mod-switch the received ciphertext
    let _ = rns_ct_mod_switch_to(&ct_deserialized, 3);
}

/// R11-VULN-08d: Verify that a complete legitimate pipeline still works.
/// encrypt -> mul_relin -> rescale -> add_leveled -> decrypt
#[test]
fn r11_full_pipeline_legitimate_ok() {
    let mut rng = test_rng_seed(11083);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct_a = rns_encrypt_f64(3.0, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_b = rns_encrypt_f64(4.0, &pk_b, &pk_a, &ctx, &mut rng);

    // 3 * 4 = 12
    let ct_prod = rns_ct_mul_relin(&ct_a, &ct_b, &evk, &ctx);
    let ct_rescaled = rns_rescale(&ct_prod);

    // Encrypt another value and add at different level
    let ct_c = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_sum = rns_ct_add_leveled(&ct_rescaled, &ct_c);

    let result = rns_decrypt_f64(&ct_sum, &s, &ctx);
    assert!(
        (result - 13.0).abs() < 1.0,
        "3*4 + 1 should be ~13.0, got {}",
        result
    );
}

// =============================================================================
// SECTION 9: Additional edge cases and regression tests
// =============================================================================

/// R11-EXTRA-01: Verify auth tag computation is deterministic and includes
/// all R7+R10+R11 fields. Recomputing should produce the same tag.
#[test]
fn r11_auth_tag_deterministic() {
    let mut rng = test_rng_seed(11090);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mac_key = [42u8; 32];
    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    let tag1 = ct.auth_tag.unwrap();

    // Recompute — should be identical
    let tag2 = ct.compute_auth_tag(&mac_key);
    assert_eq!(tag1, tag2, "Auth tag should be deterministic");
}

/// R11-EXTRA-02: Verify that encode_simd with maximum valid delta works.
#[test]
fn r11_encode_simd_large_delta_ok() {
    let values = vec![1.0, 2.0];
    let delta = (1u64 << 50) as f64;
    let coeffs = simd::encode_simd(&values, delta);
    let decoded = simd::decode_simd(&coeffs, delta, 2);
    for (i, (&expected, &got)) in values.iter().zip(decoded.iter()).enumerate() {
        assert!(
            (expected - got).abs() < 0.01,
            "slot {} large delta: expected {}, got {}",
            i, expected, got
        );
    }
}

/// R11-EXTRA-03: mod-switch to self (target_primes == num_primes) should
/// return an identical ciphertext (no change).
#[test]
fn r11_mod_switch_to_self_noop() {
    let mut rng = test_rng_seed(11092);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(7.7, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_same = rns_ct_mod_switch_to(&ct, 5);

    assert_eq!(ct_same.c0.num_primes, 5);
    assert_eq!(ct_same.c1.num_primes, 5);
    let result = rns_decrypt_f64(&ct_same, &s, &ctx);
    assert!((result - 7.7).abs() < 0.1, "mod-switch-to-self should preserve value");
}

/// R11-EXTRA-04: rescale with exactly 2 primes should leave 1 prime.
/// This tests the boundary condition (2->1 rescale is catastrophically lossy
/// for SIMD data, but the function itself should still work mechanically).
#[test]
fn r11_rescale_2_to_1_primes_works_mechanically() {
    let mut rng = test_rng_seed(11093);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    // ct*ct -> 3 primes, rescale -> 2 primes
    let ct_mul = rns_ct_mul_relin(&ct, &ct, &evk, &ctx);
    let ct_2 = rns_rescale(&ct_mul);
    assert_eq!(ct_2.c0.num_primes, 2);

    // Multiply again to get scale=delta^2, then rescale 2->1
    // This is catastrophically lossy for SIMD but should not panic
    // Actually we can't do ct*ct at 2 primes then rescale to 1...
    // Let's just check that 2-prime decrypt works
    let result = rns_decrypt_f64(&ct_2, &s, &ctx);
    assert!((result - 1.0).abs() < 1.0, "2-prime decrypt should be reasonable");
}

/// R11-EXTRA-05: Verify compression round-trip with ciphertext data after R11 changes.
#[test]
fn r11_compress_ciphertext_roundtrip() {
    let mut rng = test_rng_seed(11094);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(3.14, &pk_b, &pk_a, &ctx, &mut rng);

    // Compress and decompress the ciphertext
    let compressed = compress::compress_with(&ct, CompressionLevel::Compact).unwrap();
    let decompressed: RnsCiphertext = compress::decompress(&compressed).unwrap();

    // Verify decryption works on decompressed ciphertext
    let result = rns_decrypt_f64(&decompressed, &s, &ctx);
    assert!((result - 3.14).abs() < 0.1, "compressed roundtrip should preserve value");
}

/// R11-EXTRA-06: Verify c0/c1 checks work across the full operation suite.
/// This is a negative regression test ensuring all operations now consistently
/// check c0/c1 consistency.
#[test]
fn r11_c0_c1_consistency_comprehensive() {
    let mut rng = test_rng_seed(11095);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Verify all components start consistent
    assert_eq!(ct.c0.num_primes, ct.c1.num_primes);
    assert_eq!(ct.c0.num_primes, 5);

    // After mod-switch, should still be consistent
    let ct2 = rns_ct_mod_switch_to(&ct, 3);
    assert_eq!(ct2.c0.num_primes, ct2.c1.num_primes);
    assert_eq!(ct2.c0.num_primes, 3);
}
