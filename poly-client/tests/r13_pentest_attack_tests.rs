//! Round 13 Penetration Test -- Attack Tests for poly-client
//!
//! Focus areas:
//! - R13-VULN-01: Galois element validation in rotation key and apply_automorphism
//! - R13-VULN-02: Rotation key Galois element mismatch (key says m=5 but was built for m=25)
//! - R13-VULN-03: NTT forward/inverse consistency at ring boundary coefficients
//! - R13-VULN-04: Polynomial evaluation with extreme/degenerate coefficients
//! - R13-VULN-05: Matvec dimension mismatch and edge cases
//! - R13-VULN-06: FHE layer weight/bias shape validation
//! - R13-VULN-07: Encrypt with zero public key components (trivial key attack)
//! - R13-VULN-08: RNS reconstruction correctness for boundary values
//! - R13-VULN-09: Compression side-channel via timing/ratio leakage
//! - R13-VULN-10: Ciphertext level/prime count desynchronization after operation chains
//! - R13-VULN-11: Key-switching noise growth audit (rotation preserves correctness)
//! - R13-VULN-12: Auth tag missing nonce/replay binding for RNS ciphertexts
//! - R13-VULN-13: garner_to_digits with single prime (degenerate CRT)
//! - R13-VULN-14: Automorphism with even index (violates odd requirement)
//! - R13-VULN-15: apply_automorphism collision detection for non-coprime m

#![cfg(feature = "ckks")]
#![allow(unused_variables)]

use poly_client::ckks::compress::{self, CompressionLevel};
use poly_client::ckks::ntt::{mod_inv, mod_pow, NttContext, NTT_PRIMES};
use poly_client::ckks::params::N;
use poly_client::ckks::poly_eval;
use poly_client::ckks::rns::RnsPoly;
use poly_client::ckks::rns_ckks::*;
use poly_client::ckks::rns_fhe_layer::*;
use poly_client::ckks::simd;

use rand::rngs::StdRng;
use rand::SeedableRng;

fn test_rng_seed(seed: u64) -> StdRng {
    StdRng::seed_from_u64(seed)
}

// =============================================================================
// SECTION 1: Galois element validation (R13-VULN-01)
// =============================================================================

/// R13-VULN-01a: apply_automorphism with even index m should panic.
/// Even m means gcd(m, 2N) != 1, so the map j -> m*j mod 2N is NOT a
/// bijection. Multiple input positions collide at the same output position,
/// silently overwriting coefficients and destroying the polynomial.
#[test]
#[should_panic(expected = "automorphism index must be odd")]
fn r13_automorphism_even_index_panics() {
    let p = RnsPoly::from_coeffs(&[1, 2, 3], 3);
    // m=4 is even -> not coprime to 2N=8192, not a valid automorphism
    let _ = p.apply_automorphism(4);
}

/// R13-VULN-01b: apply_automorphism with m=0 should panic.
/// 0 maps every coefficient to position 0, destroying the polynomial.
#[test]
#[should_panic(expected = "automorphism index must be odd")]
fn r13_automorphism_zero_index_panics() {
    let p = RnsPoly::from_coeffs(&[1, 2, 3], 3);
    let _ = p.apply_automorphism(0);
}

/// R13-VULN-01c: apply_automorphism with m >= 2N should panic.
/// The index must be in [1, 2N). Out of range violates the ring structure.
#[test]
#[should_panic(expected = "automorphism index must be < 2N")]
fn r13_automorphism_index_too_large() {
    let p = RnsPoly::from_coeffs(&[1, 2, 3], 3);
    let _ = p.apply_automorphism(2 * N + 1); // 8193, but valid range is [1, 8192)
}

/// R13-VULN-01d: apply_automorphism with m=1 is identity (no panic).
/// Verify this fundamental property holds.
#[test]
fn r13_automorphism_identity_preserves_coefficients() {
    let coeffs: Vec<i64> = (0..N as i64).map(|i| (i * 7 + 3) % 100 - 50).collect();
    let p = RnsPoly::from_coeffs(&coeffs, 3);
    let q = p.apply_automorphism(1);
    let result = q.to_coeffs();
    for i in 0..N {
        assert_eq!(result[i], coeffs[i], "identity automorphism failed at index {}", i);
    }
}

/// R13-VULN-01e: apply_automorphism with valid odd m < 2N is a bijection.
/// For m=3, verify every output position is written exactly once.
#[test]
fn r13_automorphism_bijection_property() {
    // Verify that m=3 maps all N positions to distinct output positions
    let two_n = 2 * N;
    let m = 3usize;
    let mut output_positions = std::collections::HashSet::new();
    for j in 0..N {
        let idx = (m * j) % two_n;
        let out_pos = if idx < N { idx } else { idx - N };
        output_positions.insert(out_pos);
    }
    assert_eq!(
        output_positions.len(),
        N,
        "automorphism with m={} is not a bijection: {} unique outputs from {} inputs",
        m, output_positions.len(), N
    );
}

// =============================================================================
// SECTION 2: Rotation key Galois element mismatch (R13-VULN-02)
// =============================================================================

/// R13-VULN-02a: Verify rotation_to_galois produces correct Galois elements.
/// The Galois element for rotation r is g^r mod 2N where g=5.
#[test]
fn r13_rotation_to_galois_correctness() {
    let two_n = 2 * N;
    // rotation 0 -> identity (galois=1)
    assert_eq!(rotation_to_galois(0), 1, "rotation 0 should give identity");
    // rotation 1 -> 5^1 mod 8192 = 5
    assert_eq!(rotation_to_galois(1), 5, "rotation 1 should give 5");
    // rotation 2 -> 5^2 mod 8192 = 25
    assert_eq!(rotation_to_galois(2), 25, "rotation 2 should give 25");
}

/// R13-VULN-02b: Negative rotations should wrap correctly.
/// rotation(-1) should equal rotation(N/2 - 1) since slots are cyclic with period N/2.
#[test]
fn r13_negative_rotation_wraps_correctly() {
    let slots = N / 2; // 2048
    let galois_neg1 = rotation_to_galois(-1);
    let galois_wrap = rotation_to_galois((slots - 1) as i32);
    assert_eq!(
        galois_neg1, galois_wrap,
        "rotation(-1) and rotation({}) should produce the same Galois element",
        slots - 1
    );
}

/// R13-VULN-02c: Rotation by N/2 (full cycle) should be identity.
#[test]
fn r13_full_cycle_rotation_is_identity() {
    let slots = N / 2; // 2048
    let galois = rotation_to_galois(slots as i32);
    assert_eq!(galois, 1, "rotation by N/2 should be identity (Galois element 1)");
}

/// R13-VULN-02d: Rotation correctness end-to-end: encrypt, rotate, decrypt.
/// Validates that slot rotation produces the expected cyclic shift.
#[test]
fn r13_rotation_correctness_e2e() {
    let mut rng = test_rng_seed(13201);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let d = 4;
    let values = vec![10.0, 20.0, 30.0, 40.0];
    let x_rep = replicate_vector(&values, d);
    let ct = rns_encrypt_simd(&x_rep, &pk_b, &pk_a, &ctx, &mut rng);

    // Generate rotation key for rotation=1
    let rot_keys = rns_gen_rotation_keys(&s, &[1], &ctx, &mut rng);

    let ct_rot = rns_rotate(&ct, 1, &rot_keys, &ctx);
    let dec = rns_decrypt_simd(&ct_rot, &s, &ctx, d);

    // After rotating left by 1 within the replicated pattern of period d:
    // slot 0 <- slot 1 = 20.0, slot 1 <- slot 2 = 30.0,
    // slot 2 <- slot 3 = 40.0, slot 3 <- slot 0 (next period) = 10.0
    let expected = vec![20.0, 30.0, 40.0, 10.0];
    for i in 0..d {
        assert!(
            (dec[i] - expected[i]).abs() < 2.0,
            "rotation slot {}: expected {}, got {}", i, expected[i], dec[i]
        );
    }
}

/// R13-VULN-02e: Requesting a rotation for which no key exists should panic.
#[test]
#[should_panic(expected = "no rotation key for rotation")]
fn r13_missing_rotation_key_panics() {
    let mut rng = test_rng_seed(13202);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Generate rotation keys for rotation=1 only
    let rot_keys = rns_gen_rotation_keys(&s, &[1], &ctx, &mut rng);

    // Try rotation=2 — no key exists
    let _ = rns_rotate(&ct, 2, &rot_keys, &ctx);
}

// =============================================================================
// SECTION 3: NTT forward/inverse boundary consistency (R13-VULN-03)
// =============================================================================

/// R13-VULN-03a: NTT roundtrip for all-ones polynomial.
/// Every coefficient is 1 — this exercises all butterfly paths uniformly.
#[test]
fn r13_ntt_roundtrip_all_ones() {
    let q = NTT_PRIMES[0];
    let ctx = NttContext::new(q);
    let a = vec![1i64; N];

    let ntt_a = ctx.forward(&a);
    let back = ctx.inverse(&ntt_a);

    for i in 0..N {
        assert_eq!(ctx.center(back[i]), 1, "mismatch at index {}", i);
    }
}

/// R13-VULN-03b: NTT roundtrip for alternating +1/-1 pattern.
/// This is a high-frequency signal that exercises the butterfly structure maximally.
#[test]
fn r13_ntt_roundtrip_alternating() {
    let q = NTT_PRIMES[0];
    let ctx = NttContext::new(q);
    let a: Vec<i64> = (0..N).map(|i| if i % 2 == 0 { 1 } else { q - 1 }).collect();

    let ntt_a = ctx.forward(&a);
    let back = ctx.inverse(&ntt_a);

    for i in 0..N {
        assert_eq!(back[i], a[i], "alternating roundtrip mismatch at index {}", i);
    }
}

/// R13-VULN-03c: NTT with maximum coefficient (q-1) at all positions.
/// Ensures no overflow in butterfly stages even with worst-case inputs.
#[test]
fn r13_ntt_roundtrip_max_coefficients() {
    let q = NTT_PRIMES[0];
    let ctx = NttContext::new(q);
    let a = vec![q - 1; N];

    let ntt_a = ctx.forward(&a);
    let back = ctx.inverse(&ntt_a);

    for i in 0..N {
        assert_eq!(back[i], a[i], "max-coeff roundtrip mismatch at index {}", i);
    }
}

/// R13-VULN-03d: NTT multiplication consistency across all 20 primes.
/// Verify that (1+X) * (1-X) = 1-X^2 for every prime in the chain.
#[test]
fn r13_ntt_mul_all_primes_consistent() {
    for (idx, &q) in NTT_PRIMES.iter().enumerate() {
        let ctx = NttContext::new(q);

        // a = 1 + X
        let mut a = vec![0i64; N];
        a[0] = 1;
        a[1] = 1;

        // b = 1 - X = 1 + (q-1)*X
        let mut b = vec![0i64; N];
        b[0] = 1;
        b[1] = q - 1;

        let c = ctx.mul(&a, &b);

        // Expected: 1 - X^2 => coeff[0]=1, coeff[2]=-1 (i.e., q-1), rest 0
        assert_eq!(ctx.center(c[0]), 1, "prime[{}] (1+X)(1-X) const term", idx);
        assert_eq!(ctx.center(c[1]), 0, "prime[{}] (1+X)(1-X) X term", idx);
        assert_eq!(ctx.center(c[2]), -1, "prime[{}] (1+X)(1-X) X^2 term", idx);
        for i in 3..N {
            assert_eq!(ctx.center(c[i]), 0, "prime[{}] non-zero at index {}", idx, i);
        }
    }
}

/// R13-VULN-03e: NTT inverse of the forward should give identity for sparse poly.
/// Specifically: poly with only the last coefficient set (X^{N-1}).
#[test]
fn r13_ntt_roundtrip_last_coefficient() {
    let q = NTT_PRIMES[0];
    let ctx = NttContext::new(q);
    let mut a = vec![0i64; N];
    a[N - 1] = 42;

    let ntt_a = ctx.forward(&a);
    let back = ctx.inverse(&ntt_a);

    for i in 0..N {
        assert_eq!(ctx.center(back[i]), if i == N - 1 { 42 } else { 0 },
            "last-coeff roundtrip mismatch at index {}", i);
    }
}

// =============================================================================
// SECTION 4: Polynomial evaluation edge cases (R13-VULN-04)
// =============================================================================

/// R13-VULN-04a: poly_eval_plain with constant polynomial (degree 0 implicitly
/// as slice of length 1). Horner requires degree >= 1. Verify the assertion.
#[test]
#[should_panic(expected = "polynomial must have degree >= 1")]
fn r13_poly_eval_constant_panics() {
    let mut rng = test_rng_seed(13401);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct_x = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    // Degree 0 polynomial (only a constant) — should panic
    let _ = poly_eval::rns_poly_eval(&ct_x, &[5.0], &evk, &ctx);
}

/// R13-VULN-04b: poly_eval_plain with all-zero non-constant coefficients.
/// P(x) = 0 + 0*x + 0*x^2 = 0 for all x. Should still produce ~0.
#[test]
fn r13_poly_eval_all_zero_coefficients() {
    let mut rng = test_rng_seed(13402);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let input = vec![3.14; simd::NUM_SLOTS];
    let ct_x = rns_encrypt_simd(&input, &pk_b, &pk_a, &ctx, &mut rng);

    // P(x) = 0 + 0*x + 0*x^2 — trivial zero polynomial
    let coeffs = [0.0, 0.0, 0.0];
    let ct_result = poly_eval::rns_poly_eval(&ct_x, &coeffs, &evk, &ctx);
    let dec = rns_decrypt_simd(&ct_result, &s, &ctx, 4);

    for i in 0..4 {
        assert!(
            dec[i].abs() < 1.0,
            "zero polynomial slot {}: expected ~0, got {}", i, dec[i]
        );
    }
}

/// R13-VULN-04c: poly_eval_plain reference function matches expectations for
/// extreme x values near the SiLU approximation boundary.
#[test]
fn r13_poly_eval_plain_silu_boundary() {
    let coeffs = &SILU_COEFFS;
    // Evaluate at the boundary of the approximation domain [-5, 5]
    let at_5 = poly_eval::poly_eval_plain(5.0, coeffs);
    let at_neg5 = poly_eval::poly_eval_plain(-5.0, coeffs);
    let at_0 = poly_eval::poly_eval_plain(0.0, coeffs);

    // SiLU(0) = 0 (by symmetry of the odd component + offset a0)
    // Our polynomial: P(0) = a0 = 0.02673
    assert!(
        (at_0 - coeffs[0]).abs() < 1e-10,
        "P(0) should equal a0={}, got {}", coeffs[0], at_0
    );

    // Verify finite results at boundaries
    assert!(at_5.is_finite(), "P(5) should be finite, got {}", at_5);
    assert!(at_neg5.is_finite(), "P(-5) should be finite, got {}", at_neg5);
}

/// R13-VULN-04d: Paterson-Stockmeyer fallback to Horner for degree <= 2.
#[test]
fn r13_bsgs_fallback_to_horner_degree2() {
    let mut rng = test_rng_seed(13404);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let x_val = 2.0;
    let input = vec![x_val; simd::NUM_SLOTS];
    let ct_x = rns_encrypt_simd(&input, &pk_b, &pk_a, &ctx, &mut rng);

    // Degree 2: P(x) = 1 + x + x^2 => P(2) = 7
    let coeffs = [1.0, 1.0, 1.0];
    let ct_horner = poly_eval::rns_poly_eval(&ct_x, &coeffs, &evk, &ctx);
    let ct_bsgs = poly_eval::rns_poly_eval_bsgs(&ct_x, &coeffs, &evk, &ctx);

    let dec_horner = rns_decrypt_simd(&ct_horner, &s, &ctx, 2);
    let dec_bsgs = rns_decrypt_simd(&ct_bsgs, &s, &ctx, 2);

    let expected = 7.0;
    assert!(
        (dec_horner[0] - expected).abs() < 1.0,
        "Horner degree-2: expected {}, got {}", expected, dec_horner[0]
    );
    assert!(
        (dec_bsgs[0] - expected).abs() < 1.0,
        "BSGS degree-2: expected {}, got {}", expected, dec_bsgs[0]
    );
}

// =============================================================================
// SECTION 5: Matvec dimension and edge cases (R13-VULN-05)
// =============================================================================

/// R13-VULN-05a: rns_matvec with d=1 (scalar multiply). This is a degenerate
/// case where the matrix is 1x1 and no rotations are needed.
#[test]
fn r13_matvec_dimension_1_scalar() {
    let mut rng = test_rng_seed(13501);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let d = 1;
    let values = vec![5.0];
    let matrix = vec![3.0]; // 1x1 matrix = scalar multiply by 3

    let x_rep = replicate_vector(&values, d);
    let ct = rns_encrypt_simd(&x_rep, &pk_b, &pk_a, &ctx, &mut rng);

    // No rotation keys needed for d=1
    let rot_keys = rns_gen_rotation_keys(&s, &[], &ctx, &mut rng);
    let ct_result = rns_matvec(&ct, &matrix, d, &rot_keys, &ctx);
    let ct_rescaled = rns_rescale(&ct_result);

    let dec = rns_decrypt_simd(&ct_rescaled, &s, &ctx, 1);
    assert!(
        (dec[0] - 15.0).abs() < 1.0,
        "1x1 matvec: expected 15.0, got {}", dec[0]
    );
}

/// R13-VULN-05b: rns_matvec with wrong matrix dimensions should panic.
#[test]
#[should_panic(expected = "matrix must be d")]
fn r13_matvec_wrong_matrix_size_panics() {
    let mut rng = test_rng_seed(13502);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let d = 4;
    let values = vec![1.0; d];
    let matrix = vec![1.0; 9]; // 3x3 matrix, but d=4 expects 4x4=16 elements

    let x_rep = replicate_vector(&values, d);
    let ct = rns_encrypt_simd(&x_rep, &pk_b, &pk_a, &ctx, &mut rng);
    let rot_keys = rns_gen_rotation_keys(&s, &(1..d as i32).collect::<Vec<_>>(), &ctx, &mut rng);

    let _ = rns_matvec(&ct, &matrix, d, &rot_keys, &ctx);
}

/// R13-VULN-05c: rns_matvec with d=0 should panic (division by zero protection).
#[test]
#[should_panic(expected = "rns_matvec: dimension d must be > 0")]
fn r13_matvec_dimension_zero_panics() {
    let mut rng = test_rng_seed(13503);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let rot_keys = rns_gen_rotation_keys(&s, &[], &ctx, &mut rng);

    let _ = rns_matvec(&ct, &[], 0, &rot_keys, &ctx);
}

/// R13-VULN-05d: rns_ct_add_plain_simd with d=0 should panic.
#[test]
#[should_panic(expected = "rns_ct_add_plain_simd: dim must be > 0")]
fn r13_add_plain_simd_dim_zero_panics() {
    let mut rng = test_rng_seed(13504);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let _ = rns_ct_add_plain_simd(&ct, &[1.0], 0);
}

// =============================================================================
// SECTION 6: FHE layer shape validation (R13-VULN-06)
// =============================================================================

/// R13-VULN-06a: rns_linear_layer with weight matrix that doesn't match d*d should panic.
#[test]
#[should_panic(expected = "rns_linear_layer: weights.len()")]
fn r13_linear_layer_wrong_weight_size_panics() {
    let mut rng = test_rng_seed(13601);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let d = 4;
    let values = vec![1.0; d];
    let x_rep = replicate_vector(&values, d);
    let ct = rns_encrypt_simd(&x_rep, &pk_b, &pk_a, &ctx, &mut rng);
    let rot_keys = rns_gen_rotation_keys(&s, &(1..d as i32).collect::<Vec<_>>(), &ctx, &mut rng);

    // Wrong weight size: 3*3=9 instead of 4*4=16
    let weights = vec![0.5; 9];
    let biases = vec![0.1; d];

    let _ = rns_linear_layer(&ct, &weights, &biases, d, &rot_keys, &ctx);
}

/// R13-VULN-06b: rns_linear_layer with wrong bias size should panic.
#[test]
#[should_panic(expected = "rns_linear_layer: biases.len()")]
fn r13_linear_layer_wrong_bias_size_panics() {
    let mut rng = test_rng_seed(13602);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let d = 4;
    let values = vec![1.0; d];
    let x_rep = replicate_vector(&values, d);
    let ct = rns_encrypt_simd(&x_rep, &pk_b, &pk_a, &ctx, &mut rng);
    let rot_keys = rns_gen_rotation_keys(&s, &(1..d as i32).collect::<Vec<_>>(), &ctx, &mut rng);

    let weights = vec![0.5; d * d];
    let biases = vec![0.1; d + 1]; // Wrong: d+1 instead of d

    let _ = rns_linear_layer(&ct, &weights, &biases, d, &rot_keys, &ctx);
}

/// R13-VULN-06c: RnsNeuralNet with mismatched layer counts.
/// Forward pass should work even with uneven activations.
#[test]
fn r13_neural_net_forward_correctness() {
    let mut rng = test_rng_seed(13603);
    let ctx = RnsCkksContext::new(4);
    let d = 4;

    // Identity weights, zero biases, no activation
    let net = RnsNeuralNet {
        dim: d,
        weights: vec![vec![
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0,
        ]],
        biases: vec![vec![0.0; d]],
        activations: vec![Activation::None],
    };

    let input = vec![1.0, 2.0, 3.0, 4.0];
    let expected = rns_plaintext_forward(&input, &net);

    let keys = rns_neural_net_keygen(&net, &ctx, &mut rng);
    let ct_result = rns_forward(&input, &net, &keys, &ctx, &mut rng);
    let dec = rns_decrypt_simd(&ct_result, &keys.secret, &ctx, d);

    for i in 0..d {
        assert!(
            (dec[i] - expected[i]).abs() < 1.0,
            "identity net slot {}: expected {}, got {}", i, expected[i], dec[i]
        );
    }
}

/// R13-VULN-06d: rns_forward with mismatched input length should panic.
#[test]
#[should_panic(expected = "input length must match network dimension")]
fn r13_forward_wrong_input_length_panics() {
    let mut rng = test_rng_seed(13604);
    let ctx = RnsCkksContext::new(4);
    let d = 4;

    let net = RnsNeuralNet {
        dim: d,
        weights: vec![vec![0.0; d * d]],
        biases: vec![vec![0.0; d]],
        activations: vec![Activation::None],
    };

    let keys = rns_neural_net_keygen(&net, &ctx, &mut rng);
    // Wrong input length: 3 instead of 4
    let _ = rns_forward(&[1.0, 2.0, 3.0], &net, &keys, &ctx, &mut rng);
}

// =============================================================================
// SECTION 7: Encrypt with zero/trivial public key (R13-VULN-07)
// =============================================================================

/// R13-VULN-07a: Encrypting with an all-zero public key (pk_b=0, pk_a=0)
/// produces a ciphertext where c0 ≈ m (message barely hidden).
/// This is not a code bug per se, but verifies that normal keygen
/// produces keys that aren't all-zero.
#[test]
fn r13_zero_public_key_leaks_message() {
    let mut rng = test_rng_seed(13701);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    // Normal keys should not be zero
    let is_zero = |p: &RnsPoly| -> bool {
        p.residues.iter().all(|ch| ch.iter().all(|&c| c == 0))
    };
    assert!(!is_zero(&pk_b), "public key b should not be all-zero");
    assert!(!is_zero(&pk_a), "public key a should not be all-zero");

    // Verify that the secret key is ternary (in {-1, 0, 1})
    let s_coeffs = s.to_coeffs();
    for &c in &s_coeffs {
        assert!(
            c >= -1 && c <= 1,
            "secret key coefficient {} is not ternary", c
        );
    }
}

/// R13-VULN-07b: Encrypting with a zero public key a=0 makes c1 ≈ e2 (just noise).
/// The ciphertext is technically valid but c1*s ≈ 0, so c0+c1*s ≈ c0 ≈ m+e1.
/// This means decryption works but the "encryption" provides no security.
#[test]
fn r13_zero_pk_a_trivial_encryption() {
    let mut rng = test_rng_seed(13702);
    let ctx = RnsCkksContext::new(3);
    let (s, _, _) = rns_keygen(&ctx, &mut rng);

    // Craft pk_a = 0, pk_b = 0
    let pk_a_zero = RnsPoly::zero(ctx.num_primes);
    let pk_b_zero = RnsPoly::zero(ctx.num_primes);

    let val = 42.0;
    let ct = rns_encrypt_f64(val, &pk_b_zero, &pk_a_zero, &ctx, &mut rng);

    // This SHOULD decrypt correctly (c0 + c1*s ≈ m + e1 + e2*s ≈ m)
    let dec = rns_decrypt_f64(&ct, &s, &ctx);
    // With zero keys, c0 = e1 + m, c1 = e2, so c0 + c1*s = m + e1 + e2*s
    // This is still approximately m (noise is small relative to delta)
    assert!(
        (dec - val).abs() < 1.0,
        "zero-key encryption should still decrypt (insecurely): expected {}, got {}",
        val, dec
    );
}

// =============================================================================
// SECTION 8: RNS reconstruction boundary values (R13-VULN-08)
// =============================================================================

/// R13-VULN-08a: RNS roundtrip for value 0 (all residues zero).
#[test]
fn r13_rns_reconstruction_zero() {
    let p = RnsPoly::from_coeffs(&[0], 3);
    let coeffs = p.to_coeffs();
    assert_eq!(coeffs[0], 0, "zero should reconstruct as zero");
}

/// R13-VULN-08b: RNS roundtrip for value -1 (centered representation).
/// -1 mod q_i = q_i - 1 for each prime.
#[test]
fn r13_rns_reconstruction_minus_one() {
    let p = RnsPoly::from_coeffs(&[-1], 3);
    let coeffs = p.to_coeffs();
    assert_eq!(coeffs[0], -1, "(-1) should reconstruct correctly");
}

/// R13-VULN-08c: RNS roundtrip for large positive value near half-modulus.
/// This tests the centering logic in Garner's algorithm.
#[test]
fn r13_rns_reconstruction_large_positive() {
    // Use a value that is well within the centered range for 3 primes
    // Q/2 ≈ (68e9)^3 / 2 ≈ 1.6e32, so any i64 value is safely in range
    let val = i64::MAX / 2; // ~4.6e18
    let p = RnsPoly::from_coeffs(&[val], 3);
    let coeffs = p.to_coeffs();
    assert_eq!(coeffs[0], val, "large positive should reconstruct correctly");
}

/// R13-VULN-08d: RNS roundtrip for large negative value.
#[test]
fn r13_rns_reconstruction_large_negative() {
    let val = i64::MIN / 2 + 1; // ~-4.6e18
    let p = RnsPoly::from_coeffs(&[val], 3);
    let coeffs = p.to_coeffs();
    assert_eq!(coeffs[0], val, "large negative should reconstruct correctly");
}

/// R13-VULN-08e: RNS roundtrip with 4+ primes (wide arithmetic path).
#[test]
fn r13_rns_reconstruction_wide_path() {
    let val = 123456789i64;
    let p = RnsPoly::from_coeffs(&[val], 5);
    let coeffs = p.to_coeffs();
    assert_eq!(coeffs[0], val, "wide-path reconstruction should be correct");
}

/// R13-VULN-08f: RNS validate_residue_ranges catches negative coefficients.
#[test]
fn r13_rns_validate_rejects_negative_residue() {
    let mut p = RnsPoly::from_coeffs(&[42], 2);
    p.residues[0][0] = -1; // inject negative value
    assert!(!p.validate_residue_ranges(), "negative residue should fail validation");
}

/// R13-VULN-08g: RNS validate_residue_ranges catches coeff >= q.
#[test]
fn r13_rns_validate_rejects_too_large_residue() {
    let mut p = RnsPoly::from_coeffs(&[42], 2);
    p.residues[0][0] = NTT_PRIMES[0]; // exactly q, which is out of [0, q)
    assert!(!p.validate_residue_ranges(), "residue == q should fail validation");
}

/// R13-VULN-08h: RNS validate catches num_primes/residues length mismatch.
#[test]
fn r13_rns_validate_rejects_residue_count_mismatch() {
    let mut p = RnsPoly::from_coeffs(&[42], 3);
    p.residues.pop(); // remove one channel, now residues.len()=2 but num_primes=3
    assert!(!p.validate_residue_ranges(), "residue count mismatch should fail");
}

// =============================================================================
// SECTION 9: Compression side-channel and edge cases (R13-VULN-09)
// =============================================================================

/// R13-VULN-09a: Entropy check distinguishes real ciphertexts from synthetic ones.
/// Real ciphertexts (NTT-domain pseudo-random) should have low compressibility.
#[test]
fn r13_entropy_real_ciphertext_passes() {
    let mut rng = test_rng_seed(13901);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(3.14, &pk_b, &pk_a, &ctx, &mut rng);
    let check = compress::entropy_check(&ct);
    assert!(
        check.pass,
        "real ciphertext should pass entropy check: ratio={:.2}x, threshold={:.1}x",
        check.ratio, check.threshold
    );
}

/// R13-VULN-09b: A ciphertext with all-zero c0 and c1 should FAIL entropy check
/// (highly structured = compressible = potential IND-CPA violation).
#[test]
fn r13_entropy_zero_ciphertext_fails() {
    let ct = RnsCiphertext {
        c0: RnsPoly::zero(3),
        c1: RnsPoly::zero(3),
        scale: (1u64 << 36) as f64,
        level: 0,
        auth_tag: None,
    };
    let check = compress::entropy_check(&ct);
    assert!(
        !check.pass,
        "all-zero ciphertext should FAIL entropy check: ratio={:.2}x",
        check.ratio
    );
}

/// R13-VULN-09c: Compression round-trip preserves ciphertext exactly.
#[test]
fn r13_compress_roundtrip_ciphertext() {
    let mut rng = test_rng_seed(13903);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(2.71, &pk_b, &pk_a, &ctx, &mut rng);

    for level in [CompressionLevel::Lossless, CompressionLevel::Compact, CompressionLevel::Max] {
        let compressed = compress::compress_with(&ct, level).unwrap();
        let decompressed: RnsCiphertext = compress::decompress(&compressed).unwrap();

        assert_eq!(ct.c0.num_primes, decompressed.c0.num_primes, "{:?}: num_primes mismatch", level);
        assert_eq!(ct.scale, decompressed.scale, "{:?}: scale mismatch", level);
        assert_eq!(ct.level, decompressed.level, "{:?}: level mismatch", level);

        for ch in 0..ct.c0.num_primes {
            assert_eq!(ct.c0.residues[ch], decompressed.c0.residues[ch],
                "{:?}: c0 channel {} mismatch", level, ch);
            assert_eq!(ct.c1.residues[ch], decompressed.c1.residues[ch],
                "{:?}: c1 channel {} mismatch", level, ch);
        }
    }
}

/// R13-VULN-09d: Compression of evaluation key roundtrips correctly.
#[test]
fn r13_compress_roundtrip_eval_key() {
    let mut rng = test_rng_seed(13904);
    let ctx = RnsCkksContext::new(3);
    let (s, _pk_b, _pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let compressed = compress::compress_with(&evk, CompressionLevel::Compact).unwrap();
    let decompressed: RnsEvalKey = compress::decompress(&compressed).unwrap();

    assert_eq!(evk.keys.len(), decompressed.keys.len(), "eval key digit count mismatch");
}

// =============================================================================
// SECTION 10: Level/prime desync after operation chains (R13-VULN-10)
// =============================================================================

/// R13-VULN-10a: After rescale, level increments and num_primes decrements.
/// Verify these are synchronized correctly through a chain of operations.
#[test]
fn r13_level_prime_sync_through_chain() {
    let mut rng = test_rng_seed(131001);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct = rns_encrypt_f64(2.0, &pk_b, &pk_a, &ctx, &mut rng);
    assert_eq!(ct.level, 0);
    assert_eq!(ct.c0.num_primes, 5);

    // Multiply + rescale: level 0->1, primes 5->4
    let ct2 = rns_ct_mul_relin(&ct, &ct, &evk, &ctx);
    let ct2r = rns_rescale(&ct2);
    assert_eq!(ct2r.level, 1, "after 1st rescale: level should be 1");
    assert_eq!(ct2r.c0.num_primes, 4, "after 1st rescale: primes should be 4");

    // Another multiply + rescale: level 1->2, primes 4->3
    let ct3 = rns_ct_mul_relin(&ct2r, &ct2r, &evk, &ctx);
    let ct3r = rns_rescale(&ct3);
    assert_eq!(ct3r.level, 2, "after 2nd rescale: level should be 2");
    assert_eq!(ct3r.c0.num_primes, 3, "after 2nd rescale: primes should be 3");

    // level + num_primes should always equal the initial num_primes
    assert_eq!(
        ct3r.level + ct3r.c0.num_primes, 5,
        "level + num_primes should equal initial num_primes"
    );
}

/// R13-VULN-10b: Mod-switch updates level correctly.
#[test]
fn r13_mod_switch_level_update() {
    let mut rng = test_rng_seed(131002);
    let ctx = RnsCkksContext::new(5);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    assert_eq!(ct.level, 0);
    assert_eq!(ct.c0.num_primes, 5);

    let ct_switched = rns_ct_mod_switch_to(&ct, 3);
    assert_eq!(ct_switched.level, 2, "mod-switch 5->3 should set level to 2");
    assert_eq!(ct_switched.c0.num_primes, 3, "mod-switch 5->3 should set primes to 3");
    assert_eq!(ct_switched.c1.num_primes, 3, "c1 should also have 3 primes");
}

/// R13-VULN-10c: Rescale with only 1 prime remaining should panic.
#[test]
#[should_panic(expected = "cannot rescale: only 1 prime remaining")]
fn r13_rescale_single_prime_panics() {
    let mut rng = test_rng_seed(131003);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct = rns_encrypt_f64(1.1, &pk_b, &pk_a, &ctx, &mut rng);

    // Two multiplies + rescales: 3->2->1 prime
    let ct2 = rns_ct_mul_relin(&ct, &ct, &evk, &ctx);
    let ct2r = rns_rescale(&ct2); // 3->2
    let ct3 = rns_ct_mul_relin(&ct2r, &ct2r, &evk, &ctx);
    let ct3r = rns_rescale(&ct3); // 2->1

    assert_eq!(ct3r.c0.num_primes, 1);
    // This should panic: cannot rescale from 1 prime
    let _ = rns_rescale(&ct3r);
}

// =============================================================================
// SECTION 11: Key-switching noise audit (R13-VULN-11)
// =============================================================================

/// R13-VULN-11a: Multiple sequential rotations should accumulate noise
/// but still produce correct results within tolerance.
#[test]
fn r13_sequential_rotations_noise_bounded() {
    let mut rng = test_rng_seed(131101);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let d = 4;
    let values = vec![10.0, 20.0, 30.0, 40.0];
    let x_rep = replicate_vector(&values, d);
    let ct = rns_encrypt_simd(&x_rep, &pk_b, &pk_a, &ctx, &mut rng);

    let rot_keys = rns_gen_rotation_keys(&s, &[1, 2, 3], &ctx, &mut rng);

    // Rotate by 1, then by 2 (total: 3 positions)
    let ct_r1 = rns_rotate(&ct, 1, &rot_keys, &ctx);
    let ct_r3 = rns_rotate(&ct_r1, 2, &rot_keys, &ctx);

    let dec = rns_decrypt_simd(&ct_r3, &s, &ctx, d);

    // Rotating by 3 positions in a pattern of period 4:
    // [10, 20, 30, 40] -> [40, 10, 20, 30]
    let expected = vec![40.0, 10.0, 20.0, 30.0];
    for i in 0..d {
        assert!(
            (dec[i] - expected[i]).abs() < 3.0,
            "sequential rotation slot {}: expected {}, got {} (noise may be too high)",
            i, expected[i], dec[i]
        );
    }
}

/// R13-VULN-11b: Rotation by 0 should be identity (no noise added).
#[test]
fn r13_rotation_by_zero_is_identity() {
    let mut rng = test_rng_seed(131102);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let values = vec![1.0, 2.0, 3.0, 4.0];
    let ct = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);

    let rot_keys = rns_gen_rotation_keys(&s, &[1], &ctx, &mut rng);

    // rotation=0 should clone without any key-switching
    let ct_r0 = rns_rotate(&ct, 0, &rot_keys, &ctx);
    let dec = rns_decrypt_simd(&ct_r0, &s, &ctx, 4);

    for i in 0..4 {
        let dec_orig = rns_decrypt_simd(&ct, &s, &ctx, 4);
        assert!(
            (dec[i] - dec_orig[i]).abs() < 1e-10,
            "rotation by 0 should be exact identity at slot {}", i
        );
    }
}

// =============================================================================
// SECTION 12: Auth tag replay / nonce binding for RNS ciphertexts (R13-VULN-12)
// =============================================================================

/// R13-VULN-12a: Auth tag should change when scale is modified.
#[test]
fn r13_auth_tag_scale_binding() {
    let mut rng = test_rng_seed(131201);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x13u8; 32];

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    assert!(ct.verify_auth(&mac_key));

    // Tamper: change scale
    let mut tampered = ct.clone();
    tampered.scale *= 2.0;
    assert!(
        !tampered.verify_auth(&mac_key),
        "scale modification should invalidate auth tag"
    );
}

/// R13-VULN-12b: Auth tag should change when level is modified.
#[test]
fn r13_auth_tag_level_binding() {
    let mut rng = test_rng_seed(131202);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x13u8; 32];

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);

    let mut tampered = ct.clone();
    tampered.level = 99;
    assert!(
        !tampered.verify_auth(&mac_key),
        "level modification should invalidate auth tag"
    );
}

/// R13-VULN-12c: Same ciphertext data but different MAC key should not verify.
#[test]
fn r13_auth_tag_wrong_mac_key() {
    let mut rng = test_rng_seed(131203);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mac_key_1 = [0x01u8; 32];
    let mac_key_2 = [0x02u8; 32];

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key_1);

    assert!(ct.verify_auth(&mac_key_1), "correct key should verify");
    assert!(!ct.verify_auth(&mac_key_2), "wrong key should not verify");
}

/// R13-VULN-12d: Unauthenticated ciphertext (auth_tag = None) should fail verify.
#[test]
fn r13_auth_tag_none_fails_verify() {
    let mut rng = test_rng_seed(131204);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    assert!(ct.auth_tag.is_none(), "fresh ciphertext should have no auth tag");

    let mac_key = [0x42u8; 32];
    assert!(!ct.verify_auth(&mac_key), "no auth tag => verify should return false");
}

/// R13-VULN-12e: Auth tag should bind to coefficient data — flipping a single
/// bit in c0 should invalidate the tag.
#[test]
fn r13_auth_tag_single_bit_flip_detected() {
    let mut rng = test_rng_seed(131205);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x55u8; 32];

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);

    let mut tampered = ct.clone();
    tampered.c0.residues[0][0] ^= 1; // flip LSB of first coefficient
    assert!(
        !tampered.verify_auth(&mac_key),
        "single bit flip in c0 should invalidate auth tag"
    );
}

// =============================================================================
// SECTION 13: Garner CRT edge cases (R13-VULN-13)
// =============================================================================

/// R13-VULN-13a: RNS with single prime — degenerate case, Garner not needed.
#[test]
fn r13_rns_single_prime_roundtrip() {
    let values = vec![42i64, -100, 0, 1000, -1];
    for &val in &values {
        let p = RnsPoly::from_coeffs(&[val], 1);
        let back = p.to_coeffs();
        assert_eq!(back[0], val, "single-prime roundtrip failed for {}", val);
    }
}

/// R13-VULN-13b: RNS with exactly 3 primes (i128 fast path).
#[test]
fn r13_rns_three_primes_fast_path() {
    let values = vec![0i64, 1, -1, 999999999, -999999999];
    for &val in &values {
        let p = RnsPoly::from_coeffs(&[val], 3);
        let back = p.to_coeffs();
        assert_eq!(back[0], val, "3-prime fast-path roundtrip failed for {}", val);
    }
}

/// R13-VULN-13c: RNS with exactly 4 primes (wide path boundary).
#[test]
fn r13_rns_four_primes_wide_path_boundary() {
    let values = vec![0i64, 1, -1, 123456789, -987654321];
    for &val in &values {
        let p = RnsPoly::from_coeffs(&[val], 4);
        let back = p.to_coeffs();
        assert_eq!(back[0], val, "4-prime wide-path roundtrip failed for {}", val);
    }
}

/// R13-VULN-13d: Full polynomial roundtrip with many primes.
#[test]
fn r13_rns_full_poly_roundtrip_10_primes() {
    let coeffs: Vec<i64> = (0..32).map(|i| i * 1000 - 15000).collect();
    let p = RnsPoly::from_coeffs(&coeffs, 10);
    let back = p.to_coeffs();
    for i in 0..32 {
        assert_eq!(back[i], coeffs[i], "10-prime poly roundtrip failed at index {}", i);
    }
    for i in 32..N {
        assert_eq!(back[i], 0, "10-prime poly should be zero-padded at index {}", i);
    }
}

// =============================================================================
// SECTION 14: SIMD encoding/decoding edge cases (R13-VULN-14)
// =============================================================================

/// R13-VULN-14a: Encoding empty slice should produce all-zero coefficients.
#[test]
fn r13_simd_encode_empty() {
    let delta = (1u64 << 30) as f64;
    let coeffs = simd::encode_simd(&[], delta);
    assert_eq!(coeffs.len(), N, "encoded poly should have N coefficients");
    // All coefficients should be zero (or very close after FFT rounding)
    let max_abs = coeffs.iter().map(|&c| c.abs()).max().unwrap_or(0);
    assert!(
        max_abs <= 1,
        "encoding empty values should produce near-zero coefficients, got max {}",
        max_abs
    );
}

/// R13-VULN-14b: Encoding too many values (> NUM_SLOTS) should panic.
#[test]
#[should_panic(expected = "too many values")]
fn r13_simd_encode_too_many_values() {
    let delta = (1u64 << 30) as f64;
    let values = vec![1.0; simd::NUM_SLOTS + 1]; // 2049 > 2048
    let _ = simd::encode_simd(&values, delta);
}

/// R13-VULN-14c: Decoding with count=0 should return empty vec.
#[test]
fn r13_simd_decode_zero_count() {
    let delta = (1u64 << 30) as f64;
    let coeffs = vec![0i64; N];
    let decoded = simd::decode_simd(&coeffs, delta, 0);
    assert!(decoded.is_empty(), "decode with count=0 should return empty vec");
}

/// R13-VULN-14d: SIMD roundtrip with exactly NUM_SLOTS values.
#[test]
fn r13_simd_roundtrip_full_slots() {
    let delta = (1u64 << 36) as f64;
    let values: Vec<f64> = (0..simd::NUM_SLOTS).map(|i| (i as f64 * 0.01).sin()).collect();

    let coeffs = simd::encode_simd(&values, delta);
    let decoded = simd::decode_simd(&coeffs, delta, simd::NUM_SLOTS);

    let max_err = values.iter().zip(decoded.iter())
        .map(|(a, b)| (a - b).abs())
        .fold(0.0f64, f64::max);

    assert!(
        max_err < 0.01,
        "full-slot SIMD roundtrip max error {} too large", max_err
    );
}

/// R13-VULN-14e: SIMD encode with very small delta truncates to near-zero.
#[test]
fn r13_simd_encode_small_delta_precision_loss() {
    // delta = 1.0 means each coefficient is just round(value * 1.0) = value
    let delta = 1.0;
    let values = vec![0.5, 0.3]; // fractional parts lost when delta=1

    let coeffs = simd::encode_simd(&values, delta);
    let decoded = simd::decode_simd(&coeffs, delta, 2);

    // With delta=1, precision is ~1.0, so decoded values should be near
    // the rounded inputs but with significant loss
    for i in 0..2 {
        // Tolerant check — we just verify it doesn't crash
        assert!(
            decoded[i].is_finite(),
            "small delta should still produce finite results"
        );
    }
}

// =============================================================================
// SECTION 15: Mod inverse edge cases (R13-VULN-15)
// =============================================================================

/// R13-VULN-15a: mod_inv(0, p) should panic (zero has no inverse).
#[test]
#[should_panic(expected = "mod_inv: a")]
fn r13_mod_inv_zero_panics() {
    let _ = mod_inv(0, NTT_PRIMES[0]);
}

/// R13-VULN-15b: mod_inv(p, p) should panic (p ≡ 0 mod p).
#[test]
#[should_panic(expected = "mod_inv: a")]
fn r13_mod_inv_p_mod_p_panics() {
    let p = NTT_PRIMES[0];
    let _ = mod_inv(p, p);
}

/// R13-VULN-15c: mod_inv(-p, p) should panic (-p ≡ 0 mod p).
#[test]
#[should_panic(expected = "mod_inv: a")]
fn r13_mod_inv_neg_p_panics() {
    let p = NTT_PRIMES[0];
    let _ = mod_inv(-p, p);
}

/// R13-VULN-15d: mod_inv(1, p) should return 1 (trivial case).
#[test]
fn r13_mod_inv_one() {
    let p = NTT_PRIMES[0];
    let inv = mod_inv(1, p);
    assert_eq!(inv, 1, "mod_inv(1, p) should be 1");
}

/// R13-VULN-15e: mod_inv(p-1, p) should return p-1 (since (p-1)^2 = p^2-2p+1 ≡ 1 mod p).
#[test]
fn r13_mod_inv_p_minus_one() {
    let p = NTT_PRIMES[0];
    let inv = mod_inv(p - 1, p);
    assert_eq!(inv, p - 1, "mod_inv(p-1, p) should be p-1");
}

/// R13-VULN-15f: mod_pow with exponent 0 should return 1.
#[test]
fn r13_mod_pow_zero_exponent() {
    let p = NTT_PRIMES[0];
    assert_eq!(mod_pow(42, 0, p), 1, "x^0 should be 1");
    assert_eq!(mod_pow(0, 0, p), 1, "0^0 should be 1 (by convention)");
}

// =============================================================================
// SECTION 16: Decrypt validation (R13-VULN-16)
// =============================================================================

/// R13-VULN-16a: rns_decrypt_simd with count > NUM_SLOTS should panic.
#[test]
#[should_panic(expected = "rns_decrypt_simd: count")]
fn r13_decrypt_count_exceeds_slots() {
    let mut rng = test_rng_seed(131601);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let _ = rns_decrypt_simd(&ct, &s, &ctx, simd::NUM_SLOTS + 1);
}

/// R13-VULN-16b: Decrypt with mismatched c0/c1 prime counts should panic.
#[test]
#[should_panic(expected = "rns_decrypt_simd: c0 has")]
fn r13_decrypt_c0_c1_mismatch() {
    let mut rng = test_rng_seed(131602);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    // Tamper: remove one channel from c1
    ct.c1 = RnsPoly {
        residues: ct.c1.residues[..2].to_vec(),
        num_primes: 2,
    };

    let _ = rns_decrypt_simd(&ct, &s, &ctx, 1);
}

/// R13-VULN-16c: Decrypt checked should reject tampered ciphertext.
#[test]
#[should_panic(expected = "integrity check failed")]
fn r13_decrypt_checked_rejects_tampered() {
    let mut rng = test_rng_seed(131603);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x33u8; 32];

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);

    // Tamper with coefficient
    ct.c0.residues[0][0] = (ct.c0.residues[0][0] + 1) % NTT_PRIMES[0];

    // decrypt_checked should reject (auth tag mismatch)
    let _ = rns_decrypt_simd_checked(&ct, &s, &mac_key, &ctx, 1);
}

// =============================================================================
// SECTION 17: Scale validation gaps (R13-VULN-17)
// =============================================================================

/// R13-VULN-17a: Crafted ciphertext with scale=0 should be rejected at decrypt.
#[test]
#[should_panic(expected = "invalid ciphertext scale")]
fn r13_decrypt_zero_scale_panics() {
    let mut rng = test_rng_seed(131701);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.scale = 0.0; // inject invalid scale

    let _ = rns_decrypt_simd(&ct, &s, &ctx, 1);
}

/// R13-VULN-17b: Crafted ciphertext with negative scale should be rejected.
#[test]
#[should_panic(expected = "invalid ciphertext scale")]
fn r13_decrypt_negative_scale_panics() {
    let mut rng = test_rng_seed(131702);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.scale = -1.0;

    let _ = rns_decrypt_simd(&ct, &s, &ctx, 1);
}

/// R13-VULN-17c: rns_ct_add with NaN scale should be rejected.
#[test]
#[should_panic(expected = "rns_ct_add: a.scale")]
fn r13_ct_add_nan_scale_panics() {
    let mut rng = test_rng_seed(131703);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.scale = f64::NAN;

    let ct2 = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let _ = rns_ct_add(&ct, &ct2);
}

// =============================================================================
// SECTION 18: replicate_vector edge cases (R13-VULN-18)
// =============================================================================

/// R13-VULN-18a: replicate_vector with values.len() < d should zero-pad.
/// PRE-FIX: replicate_vector used `values[i % d]` which panics with index
/// out-of-bounds when values.len() < d (e.g., values=[1.0, 2.0] with d=4
/// tries values[2] which doesn't exist). The R11 assertion only checks
/// values.len() <= d, which allows the smaller case.
///
/// POST-FIX (R13): Use bounds-checked indexing that treats missing values
/// as zero, producing [1.0, 2.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0, ...].
#[test]
fn r13_replicate_pads_short_input() {
    let d = 4;
    let values = vec![1.0, 2.0]; // only 2 values for d=4

    // After R13 fix: this should NOT panic. Positions 2,3 within each
    // d-block are zero-padded since values.len()=2 < d=4.
    let rep = replicate_vector(&values, d);

    assert_eq!(rep.len(), simd::NUM_SLOTS);
    // Pattern: [1.0, 2.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0, ...]
    assert_eq!(rep[0], 1.0);
    assert_eq!(rep[1], 2.0);
    assert_eq!(rep[2], 0.0); // zero-padded
    assert_eq!(rep[3], 0.0); // zero-padded
    assert_eq!(rep[4], 1.0); // next period
    assert_eq!(rep[5], 2.0);
    assert_eq!(rep[6], 0.0);
    assert_eq!(rep[7], 0.0);
}

/// R13-VULN-18b: replicate_vector with values.len() > d should panic per R11 fix.
#[test]
#[should_panic(expected = "replicate_vector: values.len()")]
fn r13_replicate_values_too_long_panics() {
    let _ = replicate_vector(&[1.0, 2.0, 3.0], 2);
}

/// R13-VULN-18c: replicate_vector with d=0 should panic.
#[test]
#[should_panic(expected = "replicate_vector: dimension d must be > 0")]
fn r13_replicate_dimension_zero_panics() {
    let _ = replicate_vector(&[1.0], 0);
}

/// R13-VULN-18d: replicate_vector with empty values should panic.
#[test]
#[should_panic(expected = "replicate_vector: values must be non-empty")]
fn r13_replicate_empty_values_panics() {
    let _ = replicate_vector(&[], 4);
}

// =============================================================================
// SECTION 19: Ciphertext construction from deserialized data (R13-VULN-19)
// =============================================================================

/// R13-VULN-19a: Manually crafted ciphertext with out-of-range residues
/// should be caught by decrypt's residue validation.
#[test]
#[should_panic(expected = "out of range")]
fn r13_crafted_ciphertext_oob_residue_detected() {
    let mut rng = test_rng_seed(131901);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    // Inject a coefficient >= q into c0 channel 0
    ct.c0.residues[0][0] = NTT_PRIMES[0]; // exactly q, out of [0, q)

    let _ = rns_decrypt_simd(&ct, &s, &ctx, 1);
}

/// R13-VULN-19b: Negative coefficient in c1 should be caught.
#[test]
#[should_panic(expected = "out of range")]
fn r13_crafted_ciphertext_negative_c1_residue() {
    let mut rng = test_rng_seed(131902);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.c1.residues[1][42] = -1; // negative in channel 1

    let _ = rns_decrypt_simd(&ct, &s, &ctx, 1);
}

// =============================================================================
// SECTION 20: Compression header edge cases (R13-VULN-20)
// =============================================================================

/// R13-VULN-20a: Truncated PFHE header (too short) should fail.
#[test]
fn r13_compress_truncated_header_fails() {
    let data = b"PFHE"; // only 4 bytes, header needs >= 9
    let result: Result<Vec<u8>, _> = compress::decompress(data);
    assert!(result.is_err(), "truncated header should fail");
}

/// R13-VULN-20b: Valid magic but invalid version should fail.
#[test]
fn r13_compress_invalid_version_fails() {
    let mut data = vec![0u8; 20];
    data[..4].copy_from_slice(b"PFHE");
    data[4] = 3; // version 3 doesn't exist
    let result: Result<Vec<u8>, _> = compress::decompress(&data);
    assert!(result.is_err(), "invalid version should fail");
}

/// R13-VULN-20c: is_compressed correctly identifies non-PFHE data.
#[test]
fn r13_compress_is_compressed_negative() {
    assert!(!compress::is_compressed(b""), "empty should not be compressed");
    assert!(!compress::is_compressed(b"PFHX01234"), "wrong magic should not be compressed");
    assert!(!compress::is_compressed(b"PF"), "too short should not be compressed");
}

/// R13-VULN-20d: detect_level for unknown version returns None.
#[test]
fn r13_compress_detect_level_unknown() {
    let mut data = vec![0u8; 20];
    data[..4].copy_from_slice(b"PFHE");
    data[4] = 99; // unknown version
    assert_eq!(compress::detect_level(&data), None);
}

/// R13-VULN-20e: v2 with non-zero reserved byte should be rejected.
#[test]
fn r13_compress_v2_nonzero_reserved_fails() {
    let data: Vec<i64> = (0..100).collect();
    let mut compressed = compress::compress_with(&data, CompressionLevel::Compact).unwrap();
    // Byte 6 is the reserved byte in v2 format
    compressed[6] = 1; // should be 0
    let result: Result<Vec<i64>, _> = compress::decompress(&compressed);
    assert!(result.is_err(), "non-zero reserved byte should fail: {:?}", result.err());
}

/// R13-VULN-20f: v2 with wrong shuffle element size should be rejected.
#[test]
fn r13_compress_v2_wrong_element_size_fails() {
    let data: Vec<i64> = (0..100).collect();
    let mut compressed = compress::compress_with(&data, CompressionLevel::Compact).unwrap();
    // Byte 7 is the shuffle element size
    compressed[7] = 4; // should be 8
    let result: Result<Vec<i64>, _> = compress::decompress(&compressed);
    assert!(result.is_err(), "wrong element size should fail");
}
