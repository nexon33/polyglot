//! Round 6 Pentest Attack Tests
//!
//! Tests for vulnerabilities discovered in the R6 security audit:
//! 1. wide_add carry drop (CRITICAL) — rns.rs and rns_ckks.rs WideInt
//! 2. rns_ct_add_plain NaN/Inf bypass (HIGH) — scale check evasion
//! 3. rns_ct_scalar_mul zero scalar (HIGH) — silent ciphertext destruction
//! 4. replicate_vector d=0 panic (HIGH) — division by zero
//! 5. mod_inv(0, p) silent wrong result (MEDIUM) — now panics
//! 6. rns_ct_add_leveled NaN scale propagation (HIGH) — silent corruption
//! 7. rns_ct_add_scalar_broadcast NaN (HIGH) — silent corruption
//! 8. rns_encrypt_simd NaN/Inf input (HIGH) — garbage ciphertexts

#![cfg(feature = "ckks")]

use poly_client::ckks::ntt::{mod_inv, NTT_PRIMES};
use poly_client::ckks::rns::RnsPoly;
use poly_client::ckks::rns_ckks::*;
use poly_client::ckks::simd;
use rand::rngs::StdRng;
use rand::SeedableRng;

fn test_rng() -> StdRng {
    StdRng::seed_from_u64(0x0600_DEAD)
}

/// Helper: create a keyset with the given number of primes.
fn setup(num_primes: usize) -> (RnsCkksContext, RnsPoly, RnsPoly, RnsPoly) {
    let ctx = RnsCkksContext::new(num_primes);
    let mut rng = test_rng();
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    (ctx, s, pk_b, pk_a)
}

// ═══════════════════════════════════════════════════════════════════════
// 1. WIDE_ADD CARRY DROP (CRITICAL) — Fixed in R6
// ═══════════════════════════════════════════════════════════════════════

/// Test that wide_add in the CRT reconstruction path works correctly
/// with many primes (where carry propagation across extended limbs matters).
/// Before R6: wide_add used a.len() ignoring extended limbs from wide_mul_u64,
/// causing silent CRT corruption with 4+ primes.
#[test]
fn r6_wide_add_carry_correctness_many_primes() {
    // Use 10 primes — enough to force wide integer carry propagation
    let (ctx, s, pk_b, pk_a) = setup(10);
    let mut rng = test_rng();

    // Encrypt a known large value — CRT reconstruction exercises wide_add
    let values: Vec<f64> = (0..16).map(|i| (i as f64) * 1000.0).collect();
    let ct = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);
    let dec = rns_decrypt_simd(&ct, &s, &ctx, 16);

    for i in 0..16 {
        let expected = values[i];
        let err = (dec[i] - expected).abs();
        assert!(
            err < 1.0,
            "CRT reconstruction corruption: slot {} expected {}, got {} (err={})",
            i, expected, dec[i], err
        );
    }
}

/// Test wide_add with maximum prime count (20 primes, ~720-bit modulus).
/// This maximally stresses carry propagation in CRT reconstruction.
#[test]
fn r6_wide_add_20_primes_stress() {
    let (ctx, s, pk_b, pk_a) = setup(20);
    let mut rng = test_rng();

    let values = vec![42.0, -17.5, 999.99, 0.001];
    let ct = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);
    let dec = rns_decrypt_simd(&ct, &s, &ctx, 4);

    for i in 0..4 {
        let err = (dec[i] - values[i]).abs();
        assert!(
            err < 1.0,
            "20-prime CRT: slot {} expected {}, got {} (err={})",
            i, values[i], dec[i], err
        );
    }
}

/// Test that multiply + relinearize + rescale works with many primes.
/// This exercises wide_add through the full CRT-decomposition-recomposition path.
#[test]
fn r6_wide_add_mul_relin_rescale_path() {
    let (ctx, s, pk_b, pk_a) = setup(8);
    let mut rng = test_rng();
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let a_vals = vec![3.0; simd::NUM_SLOTS];
    let b_vals = vec![7.0; simd::NUM_SLOTS];
    let ct_a = rns_encrypt_simd(&a_vals, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_b = rns_encrypt_simd(&b_vals, &pk_b, &pk_a, &ctx, &mut rng);

    // Multiply -> relin -> rescale
    let triple = rns_ct_mul(&ct_a, &ct_b, &ctx);
    let ct_mul = rns_relinearize(triple, &evk, &ctx);
    let ct_res = rns_rescale(&ct_mul);

    let dec = rns_decrypt_simd(&ct_res, &s, &ctx, 4);
    for i in 0..4 {
        let err = (dec[i] - 21.0).abs();
        assert!(
            err < 1.0,
            "mul+relin+rescale: slot {} expected 21.0, got {} (err={})",
            i, dec[i], err
        );
    }
}

// ═══════════════════════════════════════════════════════════════════════
// 2. rns_ct_add_plain NaN/Inf BYPASS (HIGH) — Fixed in R6
// ═══════════════════════════════════════════════════════════════════════

/// Attack: Pass NaN as plain_val to rns_ct_add_plain.
/// Before R6: NaN bypassed the scale tolerance check (NaN comparisons return false),
/// silently corrupting the ciphertext. Now panics.
#[test]
#[should_panic(expected = "plain_val must be finite")]
fn r6_attack_add_plain_nan_value() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let _corrupted = rns_ct_add_plain(&ct, f64::NAN, ct.scale);
}

/// Attack: Pass Infinity as plain_val.
#[test]
#[should_panic(expected = "plain_val must be finite")]
fn r6_attack_add_plain_infinity_value() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let _corrupted = rns_ct_add_plain(&ct, f64::INFINITY, ct.scale);
}

/// Attack: Pass NaN as delta to rns_ct_add_plain.
/// Before R6: NaN delta made the tolerance check pass (NaN < 0.01 is false,
/// but the assert condition evaluated to false → didn't panic → corrupted).
/// Actually, the assert was: ct.scale > 0.0 && (NaN).abs() / ct.scale < 0.01
/// NaN.abs() = NaN, NaN / anything = NaN, NaN < 0.01 = false, so the overall
/// assertion is 0 && false = false → would panic. But negative infinity delta:
/// (-inf - scale).abs() = inf, inf / scale = inf, inf < 0.01 = false → panics.
/// The real issue was plain_val=NaN going through silently.
#[test]
#[should_panic(expected = "delta must be finite")]
fn r6_attack_add_plain_nan_delta() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let _corrupted = rns_ct_add_plain(&ct, 1.0, f64::NAN);
}

/// Attack: Pass negative delta.
#[test]
#[should_panic(expected = "delta must be finite and positive")]
fn r6_attack_add_plain_negative_delta() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let _corrupted = rns_ct_add_plain(&ct, 1.0, -1.0);
}

// ═══════════════════════════════════════════════════════════════════════
// 3. rns_ct_scalar_mul ZERO SCALAR (HIGH) — Fixed in R6
// ═══════════════════════════════════════════════════════════════════════

/// Attack: Multiply ciphertext by 0 to destroy the encrypted message.
/// Before R6: Silently returned an all-zero ciphertext, effectively erasing
/// the encrypted data. An active attacker could use this in a chosen-ciphertext
/// attack.
#[test]
#[should_panic(expected = "scalar must be non-zero")]
fn r6_attack_scalar_mul_zero() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct = rns_encrypt_f64(42.0, &pk_b, &pk_a, &ctx, &mut rng);
    let _zeroed = rns_ct_scalar_mul(&ct, 0);
}

/// Verify that non-zero scalar multiplication still works correctly.
#[test]
fn r6_scalar_mul_nonzero_correct() {
    let (ctx, s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct = rns_encrypt_f64(10.0, &pk_b, &pk_a, &ctx, &mut rng);
    let ct2 = rns_ct_scalar_mul(&ct, 3);
    let dec = rns_decrypt_f64(&ct2, &s, &ctx);
    let err = (dec - 30.0).abs();
    assert!(
        err < 1.0,
        "scalar_mul(3) should give ~30.0, got {} (err={})",
        dec, err
    );
}

// ═══════════════════════════════════════════════════════════════════════
// 4. replicate_vector d=0 PANIC (HIGH) — Fixed in R6
// ═══════════════════════════════════════════════════════════════════════

/// Attack: Call replicate_vector with d=0 to trigger division by zero.
/// Before R6: Panicked with an unhelpful "attempt to calculate remainder with divisor of 0".
/// Now panics with a descriptive assertion message.
#[test]
#[should_panic(expected = "dimension d must be > 0")]
fn r6_attack_replicate_vector_d_zero() {
    let _v = replicate_vector(&[1.0, 2.0, 3.0], 0);
}

/// Attack: Call replicate_vector with empty values.
#[test]
#[should_panic(expected = "values must be non-empty")]
fn r6_attack_replicate_vector_empty_values() {
    let _v = replicate_vector(&[], 3);
}

/// Verify replicate_vector works correctly for valid inputs.
#[test]
fn r6_replicate_vector_correct() {
    let v = replicate_vector(&[10.0, 20.0, 30.0], 3);
    assert_eq!(v.len(), simd::NUM_SLOTS);
    for i in 0..simd::NUM_SLOTS {
        let expected = [10.0, 20.0, 30.0][i % 3];
        assert_eq!(v[i], expected, "slot {} mismatch", i);
    }
}

// ═══════════════════════════════════════════════════════════════════════
// 5. mod_inv(0, p) SILENT WRONG RESULT (MEDIUM) — Fixed in R6
// ═══════════════════════════════════════════════════════════════════════

/// Attack: Call mod_inv(0, p) — zero has no modular inverse.
/// Before R6: Silently returned 0 (which is wrong: 0 * 0 = 0 != 1 mod p).
/// This could cause subtle CRT reconstruction bugs.
#[test]
#[should_panic(expected = "has no inverse")]
fn r6_attack_mod_inv_zero() {
    let p = NTT_PRIMES[0];
    let _bad = mod_inv(0, p);
}

/// mod_inv(p, p) should also panic — p ≡ 0 (mod p).
#[test]
#[should_panic(expected = "has no inverse")]
fn r6_attack_mod_inv_multiple_of_p() {
    let p = NTT_PRIMES[0];
    let _bad = mod_inv(p, p);
}

/// Verify mod_inv works for valid inputs.
#[test]
fn r6_mod_inv_valid() {
    let p = NTT_PRIMES[0];
    let a = 42i64;
    let inv = mod_inv(a, p);
    // Verify: a * inv ≡ 1 (mod p)
    let product = ((a as i128 * inv as i128) % p as i128) as i64;
    assert_eq!(
        product, 1,
        "mod_inv({}, {}) = {} but {} * {} mod {} = {} (expected 1)",
        a, p, inv, a, inv, p, product
    );
}

// ═══════════════════════════════════════════════════════════════════════
// 6. rns_ct_add_leveled NaN SCALE PROPAGATION (HIGH) — Fixed in R6
// ═══════════════════════════════════════════════════════════════════════

/// Attack: Craft a ciphertext with NaN scale and add it with rns_ct_add_leveled.
/// Before R6: The NaN scale propagated through averaging into the result,
/// silently corrupting all downstream operations.
#[test]
#[should_panic(expected = "scale must be finite and positive")]
fn r6_attack_add_leveled_nan_scale() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct_good = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Craft a ciphertext with NaN scale
    let ct_nan = RnsCiphertext {
        c0: ct_good.c0.clone(),
        c1: ct_good.c1.clone(),
        scale: f64::NAN,
        level: ct_good.level,
        auth_tag: None,
    };

    let _corrupted = rns_ct_add_leveled(&ct_good, &ct_nan);
}

/// Attack: Ciphertext with negative scale.
#[test]
#[should_panic(expected = "scale must be finite and positive")]
fn r6_attack_add_leveled_negative_scale() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct_good = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    let ct_neg = RnsCiphertext {
        c0: ct_good.c0.clone(),
        c1: ct_good.c1.clone(),
        scale: -1.0,
        level: ct_good.level,
        auth_tag: None,
    };

    let _corrupted = rns_ct_add_leveled(&ct_neg, &ct_good);
}

/// Attack: Ciphertext with Infinity scale.
#[test]
#[should_panic(expected = "scale must be finite and positive")]
fn r6_attack_add_leveled_inf_scale() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct_good = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    let ct_inf = RnsCiphertext {
        c0: ct_good.c0.clone(),
        c1: ct_good.c1.clone(),
        scale: f64::INFINITY,
        level: ct_good.level,
        auth_tag: None,
    };

    let _corrupted = rns_ct_add_leveled(&ct_good, &ct_inf);
}

// ═══════════════════════════════════════════════════════════════════════
// 7. rns_ct_add_scalar_broadcast NaN (HIGH) — Fixed in R6
// ═══════════════════════════════════════════════════════════════════════

/// Attack: Broadcast NaN to all SIMD slots.
/// Before R6: NaN passed through simd::encode_simd and corrupted the ciphertext.
#[test]
#[should_panic(expected = "scalar must be finite")]
fn r6_attack_scalar_broadcast_nan() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let _corrupted = rns_ct_add_scalar_broadcast(&ct, f64::NAN);
}

/// Attack: Broadcast negative infinity.
#[test]
#[should_panic(expected = "scalar must be finite")]
fn r6_attack_scalar_broadcast_neg_inf() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let _corrupted = rns_ct_add_scalar_broadcast(&ct, f64::NEG_INFINITY);
}

/// Verify broadcast with valid scalar works.
#[test]
fn r6_scalar_broadcast_valid() {
    let (ctx, s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let ct = rns_encrypt_simd(&[10.0, 20.0, 30.0], &pk_b, &pk_a, &ctx, &mut rng);
    let ct2 = rns_ct_add_scalar_broadcast(&ct, 5.0);
    let dec = rns_decrypt_simd(&ct2, &s, &ctx, 3);
    for (i, expected) in [15.0, 25.0, 35.0].iter().enumerate() {
        let err = (dec[i] - expected).abs();
        assert!(
            err < 1.0,
            "broadcast add: slot {} expected {}, got {} (err={})",
            i, expected, dec[i], err
        );
    }
}

// ═══════════════════════════════════════════════════════════════════════
// 8. rns_encrypt_simd NaN/Inf INPUT (HIGH) — Fixed in R6
// ═══════════════════════════════════════════════════════════════════════

/// Attack: Encrypt NaN values — produces garbage ciphertext that appears valid.
/// Before R6: NaN passed through encode_simd and created a ciphertext where
/// decrypt would return unpredictable values, potentially leaking key info.
#[test]
#[should_panic(expected = "value must be finite")]
fn r6_attack_encrypt_nan_value() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let _ct = rns_encrypt_simd(&[1.0, f64::NAN, 3.0], &pk_b, &pk_a, &ctx, &mut rng);
}

/// Attack: Encrypt Infinity.
#[test]
#[should_panic(expected = "value must be finite")]
fn r6_attack_encrypt_infinity() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let _ct = rns_encrypt_simd(&[f64::INFINITY], &pk_b, &pk_a, &ctx, &mut rng);
}

/// Attack: Encrypt negative infinity.
#[test]
#[should_panic(expected = "value must be finite")]
fn r6_attack_encrypt_neg_infinity() {
    let (ctx, _s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let _ct = rns_encrypt_simd(&[f64::NEG_INFINITY], &pk_b, &pk_a, &ctx, &mut rng);
}

/// Verify encryption/decryption works for valid values.
#[test]
fn r6_encrypt_decrypt_valid_roundtrip() {
    let (ctx, s, pk_b, pk_a) = setup(3);
    let mut rng = test_rng();
    let values = vec![1.5, -2.7, 0.0, 100.0, -0.001];
    let ct = rns_encrypt_simd(&values, &pk_b, &pk_a, &ctx, &mut rng);
    let dec = rns_decrypt_simd(&ct, &s, &ctx, 5);
    for i in 0..5 {
        let err = (dec[i] - values[i]).abs();
        assert!(
            err < 1.0,
            "roundtrip: slot {} expected {}, got {} (err={})",
            i, values[i], dec[i], err
        );
    }
}

// ═══════════════════════════════════════════════════════════════════════
// 9. COMBINED ATTACK SCENARIOS
// ═══════════════════════════════════════════════════════════════════════

/// Attack: Chain multiple operations after fixing carry bugs.
/// Encrypt -> multiply -> relinearize -> rescale -> add_plain -> decrypt.
/// Verifies the full pipeline produces correct results with fixed wide_add.
#[test]
fn r6_full_pipeline_correctness_after_carry_fix() {
    let (ctx, s, pk_b, pk_a) = setup(6);
    let mut rng = test_rng();
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let a_vals = vec![5.0; simd::NUM_SLOTS];
    let b_vals = vec![4.0; simd::NUM_SLOTS];

    let ct_a = rns_encrypt_simd(&a_vals, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_b = rns_encrypt_simd(&b_vals, &pk_b, &pk_a, &ctx, &mut rng);

    // 5 * 4 = 20
    let triple = rns_ct_mul(&ct_a, &ct_b, &ctx);
    let ct_mul = rns_relinearize(triple, &evk, &ctx);
    let ct_resc = rns_rescale(&ct_mul);

    // 20 + 3.0 = 23.0 (with noise accumulation from mul+relin+rescale+add_plain)
    let ct_final = rns_ct_add_plain(&ct_resc, 3.0, ct_resc.scale);
    let dec = rns_decrypt_simd(&ct_final, &s, &ctx, 4);

    for i in 0..4 {
        let err = (dec[i] - 23.0).abs();
        assert!(
            err < 5.0,
            "full pipeline: slot {} expected 23.0, got {} (err={})",
            i, dec[i], err
        );
    }
}

/// Attack: Deep circuit (multiple multiplications) to stress wide_add carry.
/// Each multiplication followed by rescale drops a prime and exercises CRT.
#[test]
fn r6_deep_circuit_carry_stress() {
    let (ctx, s, pk_b, pk_a) = setup(10);
    let mut rng = test_rng();
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let vals = vec![2.0; simd::NUM_SLOTS];
    let mut ct = rns_encrypt_simd(&vals, &pk_b, &pk_a, &ctx, &mut rng);

    // Square 3 times: 2 -> 4 -> 16 -> 256
    for _round in 0..3 {
        let triple = rns_ct_mul(&ct, &ct, &ctx);
        ct = rns_relinearize(triple, &evk, &ctx);
        ct = rns_rescale(&ct);
    }

    let dec = rns_decrypt_simd(&ct, &s, &ctx, 4);
    for i in 0..4 {
        let err = (dec[i] - 256.0).abs();
        assert!(
            err < 5.0,
            "deep circuit: slot {} expected 256.0, got {} (err={})",
            i, dec[i], err
        );
    }
}
