//! Round 10 Penetration Test — Attack Tests for poly-client
//!
//! Focus areas:
//! - rns_ct_mul_plain_simd missing ct.scale validation (R10-VULN-01)
//! - rns_decrypt_simd count > NUM_SLOTS and c0/c1 prime mismatch (R10-VULN-02)
//! - rns_ct_mul missing num_primes mismatch check (R10-VULN-03)
//! - rns_relinearize missing triple.scale validation (R10-VULN-04)
//! - compute_auth_tag missing c1.num_primes binding (R10-VULN-05)
//! - rns_matvec / rns_ct_add_plain_simd dim=0 division by zero (R10-VULN-06)
//! - trivial_ciphertext_broadcast missing scale validation (R10-VULN-07)
//! - Auth tag c1.num_primes forgery (R10-VULN-08)

#![cfg(feature = "ckks")]
#![allow(unused_variables)]

use poly_client::ckks::rns::RnsPoly;
use poly_client::ckks::rns_ckks::*;
use poly_client::ckks::rns_fhe_layer;
use poly_client::ckks::simd;

use rand::rngs::StdRng;
use rand::SeedableRng;

fn test_rng_seed(seed: u64) -> StdRng {
    StdRng::seed_from_u64(seed)
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 1: rns_ct_mul_plain_simd missing ct.scale validation (HIGH)
// ═══════════════════════════════════════════════════════════════════════════

/// R10-VULN-01: rns_ct_mul_plain_simd did not validate ct.scale.
/// Every other multiply path (rns_ct_mul, rns_ct_mul_leveled) validated
/// input scales in R6-R8, but plaintext multiply was missed. A NaN scale
/// would produce NaN * ctx.delta = NaN result scale, propagating through
/// all downstream operations (rescale, add, decrypt).
#[test]
#[should_panic(expected = "rns_ct_mul_plain_simd: ct.scale must be finite and positive")]
fn r10_mul_plain_simd_nan_scale_rejected() {
    let mut rng = test_rng_seed(10001);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.scale = f64::NAN;

    let values = vec![1.0; simd::NUM_SLOTS];
    // Pre-R10: NaN scale would silently propagate
    let _ = rns_ct_mul_plain_simd(&ct, &values, &ctx);
}

#[test]
#[should_panic(expected = "rns_ct_mul_plain_simd: ct.scale must be finite and positive")]
fn r10_mul_plain_simd_inf_scale_rejected() {
    let mut rng = test_rng_seed(10002);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(2.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.scale = f64::INFINITY;

    let values = vec![1.0; simd::NUM_SLOTS];
    let _ = rns_ct_mul_plain_simd(&ct, &values, &ctx);
}

#[test]
#[should_panic(expected = "rns_ct_mul_plain_simd: ct.scale must be finite and positive")]
fn r10_mul_plain_simd_neg_inf_scale_rejected() {
    let mut rng = test_rng_seed(10003);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(3.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.scale = f64::NEG_INFINITY;

    let values = vec![2.0; simd::NUM_SLOTS];
    let _ = rns_ct_mul_plain_simd(&ct, &values, &ctx);
}

#[test]
#[should_panic(expected = "rns_ct_mul_plain_simd: ct.scale must be finite and positive")]
fn r10_mul_plain_simd_zero_scale_rejected() {
    let mut rng = test_rng_seed(10004);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.scale = 0.0;

    let values = vec![1.0; simd::NUM_SLOTS];
    let _ = rns_ct_mul_plain_simd(&ct, &values, &ctx);
}

#[test]
#[should_panic(expected = "rns_ct_mul_plain_simd: ct.scale must be finite and positive")]
fn r10_mul_plain_simd_negative_scale_rejected() {
    let mut rng = test_rng_seed(10005);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.scale = -1.0;

    let values = vec![1.0; simd::NUM_SLOTS];
    let _ = rns_ct_mul_plain_simd(&ct, &values, &ctx);
}

/// Verify that a valid plaintext multiply still works after the fix.
#[test]
fn r10_mul_plain_simd_valid_roundtrip() {
    let mut rng = test_rng_seed(10006);
    let ctx = RnsCkksContext::new(4);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let input = vec![2.0; simd::NUM_SLOTS];
    let ct = rns_encrypt_simd(&input, &pk_b, &pk_a, &ctx, &mut rng);

    let multiplier = vec![3.0; simd::NUM_SLOTS];
    let ct_mul = rns_ct_mul_plain_simd(&ct, &multiplier, &ctx);
    let ct_rescaled = rns_rescale(&ct_mul);

    let result = rns_decrypt_simd(&ct_rescaled, &s, &ctx, 4);
    for &v in &result[..4] {
        assert!((v - 6.0).abs() < 0.1, "expected ~6.0, got {}", v);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 2: rns_decrypt_simd count and c0/c1 consistency (CRITICAL)
// ═══════════════════════════════════════════════════════════════════════════

/// R10-VULN-02a: rns_decrypt_simd_unchecked did not validate count <= NUM_SLOTS.
/// An attacker providing count > 2048 causes simd::decode_simd to read from
/// FFT positions beyond the valid slot range. The slot_to_fft lookup table
/// has only NUM_SLOTS entries, so index > 2047 panics or returns garbage.
#[test]
#[should_panic(expected = "rns_decrypt_simd: count")]
fn r10_decrypt_simd_count_exceeds_num_slots() {
    let mut rng = test_rng_seed(10010);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Pre-R10: this would read beyond the slot permutation table
    let _ = rns_decrypt_simd(&ct, &s, &ctx, simd::NUM_SLOTS + 1);
}

#[test]
#[should_panic(expected = "rns_decrypt_simd: count")]
fn r10_decrypt_simd_count_usize_max() {
    let mut rng = test_rng_seed(10011);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Extreme case: usize::MAX
    let _ = rns_decrypt_simd(&ct, &s, &ctx, usize::MAX);
}

/// R10-VULN-02b: c0 and c1 had no consistency check on num_primes.
/// A crafted ciphertext with c0.num_primes=3 but c1.num_primes=2 would
/// cause the polynomial multiply (c1 * s_at_level) to use the wrong
/// modulus chain, producing silent decryption errors.
#[test]
#[should_panic(expected = "rns_decrypt_simd: c0 has")]
fn r10_decrypt_simd_c0_c1_prime_mismatch() {
    let mut rng = test_rng_seed(10012);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Tamper: truncate c1 to fewer primes
    ct.c1 = RnsPoly {
        residues: ct.c1.residues[..2].to_vec(),
        num_primes: 2,
    };

    // Pre-R10: c1*s would silently use wrong modulus chain
    let _ = rns_decrypt_simd(&ct, &s, &ctx, 1);
}

/// Count = 0 should work fine (return empty vec).
#[test]
fn r10_decrypt_simd_count_zero_ok() {
    let mut rng = test_rng_seed(10013);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let result = rns_decrypt_simd(&ct, &s, &ctx, 0);
    assert_eq!(result.len(), 0);
}

/// Count = NUM_SLOTS (exactly at limit) should work.
#[test]
fn r10_decrypt_simd_count_at_limit_ok() {
    let mut rng = test_rng_seed(10014);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let result = rns_decrypt_simd(&ct, &s, &ctx, simd::NUM_SLOTS);
    assert_eq!(result.len(), simd::NUM_SLOTS);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 3: rns_ct_mul missing num_primes check (HIGH)
// ═══════════════════════════════════════════════════════════════════════════

/// R10-VULN-03: rns_ct_mul had no num_primes check.
/// R9 added num_primes checks to rns_ct_add and rns_ct_sub but missed
/// rns_ct_mul. A deserialized ciphertext with matching scale/level but
/// mismatched prime counts would cause ctx.poly_mul → RnsPoly::add to
/// panic with an unhelpful "assertion failed" message deep in the call stack.
#[test]
#[should_panic(expected = "rns_ct_mul: num_primes mismatch")]
fn r10_ct_mul_num_primes_mismatch_rejected() {
    let mut rng = test_rng_seed(10020);
    let ctx = RnsCkksContext::new(5);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let mut b = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Tamper: mod-switch b down to 3 primes (but keep same scale/level)
    b.c0 = RnsPoly {
        residues: b.c0.residues[..3].to_vec(),
        num_primes: 3,
    };
    b.c1 = RnsPoly {
        residues: b.c1.residues[..3].to_vec(),
        num_primes: 3,
    };

    // Pre-R10: would panic deep in poly_mul with unhelpful message
    let _ = rns_ct_mul(&a, &b, &ctx);
}

/// Verify the error message is descriptive (mentions use of leveled variant).
#[test]
#[should_panic(expected = "use rns_ct_mul_leveled")]
fn r10_ct_mul_num_primes_mismatch_suggests_leveled() {
    let mut rng = test_rng_seed(10021);
    let ctx = RnsCkksContext::new(5);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let mut b = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    b.c0 = RnsPoly {
        residues: b.c0.residues[..4].to_vec(),
        num_primes: 4,
    };
    b.c1 = RnsPoly {
        residues: b.c1.residues[..4].to_vec(),
        num_primes: 4,
    };

    let _ = rns_ct_mul(&a, &b, &ctx);
}

/// Matching prime counts should still work (regression test).
#[test]
fn r10_ct_mul_matching_primes_still_works() {
    let mut rng = test_rng_seed(10022);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let a = rns_encrypt_f64(3.0, &pk_b, &pk_a, &ctx, &mut rng);
    let b = rns_encrypt_f64(4.0, &pk_b, &pk_a, &ctx, &mut rng);

    let triple = rns_ct_mul(&a, &b, &ctx);
    let ct_prod = rns_relinearize(triple, &evk, &ctx);
    let ct_rescaled = rns_rescale(&ct_prod);
    let result = rns_decrypt_f64(&ct_rescaled, &s, &ctx);
    assert!((result - 12.0).abs() < 0.5, "expected ~12.0, got {}", result);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 4: rns_relinearize missing triple.scale validation (HIGH)
// ═══════════════════════════════════════════════════════════════════════════

/// R10-VULN-04: rns_relinearize did not validate triple.scale.
/// While rns_ct_mul validates its input scales, the RnsCiphertextTriple
/// struct is public. A manually constructed triple (from deserialization
/// or testing) with NaN/Inf/zero scale would propagate through the
/// relinearize output, bypassing all validation in the multiply path.
#[test]
#[should_panic(expected = "rns_relinearize: triple.scale must be finite and positive")]
fn r10_relinearize_nan_scale_rejected() {
    let mut rng = test_rng_seed(10030);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let b = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    let mut triple = rns_ct_mul(&a, &b, &ctx);
    triple.scale = f64::NAN; // Tamper with scale

    // Pre-R10: NaN scale would silently propagate into result ciphertext
    let _ = rns_relinearize(triple, &evk, &ctx);
}

#[test]
#[should_panic(expected = "rns_relinearize: triple.scale must be finite and positive")]
fn r10_relinearize_inf_scale_rejected() {
    let mut rng = test_rng_seed(10031);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let b = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    let mut triple = rns_ct_mul(&a, &b, &ctx);
    triple.scale = f64::INFINITY;

    let _ = rns_relinearize(triple, &evk, &ctx);
}

#[test]
#[should_panic(expected = "rns_relinearize: triple.scale must be finite and positive")]
fn r10_relinearize_zero_scale_rejected() {
    let mut rng = test_rng_seed(10032);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let b = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    let mut triple = rns_ct_mul(&a, &b, &ctx);
    triple.scale = 0.0;

    let _ = rns_relinearize(triple, &evk, &ctx);
}

#[test]
#[should_panic(expected = "rns_relinearize: triple.scale must be finite and positive")]
fn r10_relinearize_negative_scale_rejected() {
    let mut rng = test_rng_seed(10033);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let b = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    let mut triple = rns_ct_mul(&a, &b, &ctx);
    triple.scale = -1e10;

    let _ = rns_relinearize(triple, &evk, &ctx);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 5: compute_auth_tag missing c1.num_primes binding (HIGH)
// ═══════════════════════════════════════════════════════════════════════════

/// R10-VULN-05: compute_auth_tag only included c0.num_primes in the HMAC.
/// An attacker could forge a ciphertext where c0.num_primes is authentic
/// but c1.num_primes is tampered (truncated or extended). The auth tag
/// would verify successfully because only c0's prime count was bound.
/// Decryption computes c1 * s, so wrong c1 primes → wrong modulus chain
/// → garbage output that the victim trusts.
#[test]
fn r10_auth_tag_c1_num_primes_binding() {
    let mut rng = test_rng_seed(10040);
    let ctx = RnsCkksContext::new(4);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mac_key = [42u8; 32];
    let mut ct = rns_encrypt_f64(7.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);

    // Pre-R10: This tag was computed with only c0.num_primes.
    // Tamper c1 by truncating to fewer primes — the auth tag should
    // now fail because R10 includes c1.num_primes in the HMAC.
    let original_tag = ct.auth_tag.unwrap();
    ct.c1 = RnsPoly {
        residues: ct.c1.residues[..3].to_vec(),
        num_primes: 3,
    };

    // The tag should NOT verify after c1 tampering
    assert!(
        !ct.verify_auth(&mac_key),
        "Auth tag should fail after c1.num_primes tampering — \
         pre-R10 only bound c0.num_primes"
    );
}

/// Verify that a legitimately authenticated ciphertext still verifies.
#[test]
fn r10_auth_tag_legitimate_still_verifies() {
    let mut rng = test_rng_seed(10041);
    let ctx = RnsCkksContext::new(4);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mac_key = [99u8; 32];
    let mut ct = rns_encrypt_f64(3.14, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);

    assert!(ct.verify_auth(&mac_key), "Legitimate auth tag should verify");
}

/// Verify auth tag detects c1 coefficient tampering (regression).
#[test]
fn r10_auth_tag_c1_coefficient_tamper_detected() {
    let mut rng = test_rng_seed(10042);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mac_key = [77u8; 32];
    let mut ct = rns_encrypt_f64(5.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);

    // Flip one coefficient in c1
    ct.c1.residues[0][0] ^= 1;

    assert!(!ct.verify_auth(&mac_key), "Coefficient tamper should fail");
}

/// Demonstrate the attack: pre-R10, truncating c1 would have passed auth.
/// Post-R10, both c0.num_primes AND c1.num_primes are bound in the HMAC.
#[test]
fn r10_auth_tag_c1_extension_attack_blocked() {
    let mut rng = test_rng_seed(10043);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mac_key = [55u8; 32];
    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);

    // "Extend" c1 by adding a fake 4th prime channel
    let fake_channel = vec![0i64; 4096]; // zeros
    let mut new_residues = ct.c1.residues.clone();
    new_residues.push(fake_channel);
    ct.c1 = RnsPoly {
        residues: new_residues,
        num_primes: 4,
    };

    assert!(
        !ct.verify_auth(&mac_key),
        "c1 extension attack should fail (c1.num_primes changed from 3 to 4)"
    );
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 6: rns_matvec dim=0 division by zero (HIGH)
// ═══════════════════════════════════════════════════════════════════════════

/// R10-VULN-06a: rns_matvec with d=0 caused `i % 0` → division-by-zero panic.
/// The matrix size check `matrix.len() == d * d` passes for d=0 (0 == 0),
/// but the diagonal tiling `matrix[(i % d) * d + (i % d)]` panics.
#[test]
#[should_panic(expected = "rns_matvec: dimension d must be > 0")]
fn r10_matvec_dim_zero_rejected() {
    let mut rng = test_rng_seed(10050);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let rot_keys = rns_gen_rotation_keys(&s, &[], &ctx, &mut rng);

    // Pre-R10: division by zero panic ("attempt to calculate the remainder
    // with a divisor of zero")
    let _ = rns_matvec(&ct, &[], 0, &rot_keys, &ctx);
}

/// R10-VULN-06b: rns_ct_add_plain_simd with dim=0 caused the same panic.
#[test]
#[should_panic(expected = "rns_ct_add_plain_simd: dim must be > 0")]
fn r10_add_plain_simd_dim_zero_rejected() {
    let mut rng = test_rng_seed(10051);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Pre-R10: division by zero in the replication loop
    let _ = rns_fhe_layer::rns_ct_add_plain_simd(&ct, &[1.0], 0);
}

/// Verify that valid matvec still works (regression test).
#[test]
fn r10_matvec_dim_1_identity_ok() {
    let mut rng = test_rng_seed(10052);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    // 1x1 identity matrix
    let matrix = vec![1.0];
    let rot_keys = rns_gen_rotation_keys(&s, &[], &ctx, &mut rng);

    let input = replicate_vector(&[4.5], 1);
    let ct = rns_encrypt_simd(&input, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_out = rns_matvec(&ct, &matrix, 1, &rot_keys, &ctx);
    let ct_rescaled = rns_rescale(&ct_out);
    let result = rns_decrypt_simd(&ct_rescaled, &s, &ctx, 1);
    assert!(
        (result[0] - 4.5).abs() < 0.5,
        "1x1 identity matvec should preserve value, got {}",
        result[0]
    );
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 7: trivial_ciphertext_broadcast scale validation (MEDIUM)
// ═══════════════════════════════════════════════════════════════════════════

// Note: trivial_ciphertext_broadcast is a private function in poly_eval,
// so we test it indirectly through the public polynomial evaluation API.
// The R10 fix validates scale/scalar inside the function.

/// Verify that polynomial evaluation (which uses trivial_ciphertext_broadcast
/// internally for constant groups) still works correctly after the R10 fix.
#[test]
fn r10_poly_eval_with_constant_groups_ok() {
    let mut rng = test_rng_seed(10060);
    let ctx = RnsCkksContext::new(10);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    // f(x) = 1 + 2x + 3x^2  (simple quadratic)
    let coeffs = [1.0, 2.0, 3.0];
    let input_val = 0.5;
    let expected = 1.0 + 2.0 * 0.5 + 3.0 * 0.25; // = 2.75

    let ct = rns_encrypt_f64(input_val, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_result = poly_client::ckks::poly_eval::rns_poly_eval(&ct, &coeffs, &evk, &ctx);
    let result = rns_decrypt_f64(&ct_result, &s, &ctx);

    assert!(
        (result - expected).abs() < 0.5,
        "poly eval f(0.5) = {}, expected {}",
        result, expected
    );
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 8: Compound attack scenarios
// ═══════════════════════════════════════════════════════════════════════════

/// Compound attack: chain mul_plain_simd (which lacked scale check) with
/// rns_ct_add (which had scale check) to demonstrate the bypass.
/// Pre-R10, an attacker could launder a NaN-scale ciphertext through
/// mul_plain_simd (which didn't check) and then the result with NaN*delta
/// would fail at add. Post-R10, mul_plain_simd catches it first.
#[test]
#[should_panic(expected = "rns_ct_mul_plain_simd: ct.scale must be finite and positive")]
fn r10_compound_nan_scale_laundering_via_mul_plain() {
    let mut rng = test_rng_seed(10070);
    let ctx = RnsCkksContext::new(3);
    let (_s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.scale = f64::NAN;

    // Step 1: mul_plain_simd was the unvalidated entry point
    let values = vec![1.0; simd::NUM_SLOTS];
    let ct2 = rns_ct_mul_plain_simd(&ct, &values, &ctx);
    // Step 2: would try to add — but R10 catches at step 1
}

/// Compound attack: forge a ciphertext with mismatched c0/c1 primes,
/// authenticate it, then try to decrypt. Pre-R10, auth would pass (only
/// c0.num_primes was in HMAC) and decryption would silently produce wrong
/// output. Post-R10, checked decrypt catches the auth failure.
#[test]
#[should_panic(expected = "auth_tag missing or invalid")]
fn r10_compound_c1_prime_forgery_checked_decrypt() {
    let mut rng = test_rng_seed(10071);
    let ctx = RnsCkksContext::new(4);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mac_key = [88u8; 32];
    let mut ct = rns_encrypt_f64(42.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);

    // Tamper c1 num_primes (truncate to 3)
    ct.c1 = RnsPoly {
        residues: ct.c1.residues[..3].to_vec(),
        num_primes: 3,
    };

    // The checked decrypt should catch the auth failure from R10's c1 binding
    let _ = rns_decrypt_simd_checked(&ct, &s, &mac_key, &ctx, 1);
}

/// Compound attack: construct a triple with NaN scale, relinearize, then
/// try to rescale. Pre-R10, the NaN would propagate through relinearize
/// unchecked, and rescale would catch it (R7 fix). Post-R10, relinearize
/// catches it at the source.
#[test]
#[should_panic(expected = "rns_relinearize: triple.scale must be finite and positive")]
fn r10_compound_nan_triple_propagation_blocked() {
    let mut rng = test_rng_seed(10072);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let a = rns_encrypt_f64(2.0, &pk_b, &pk_a, &ctx, &mut rng);
    let b = rns_encrypt_f64(3.0, &pk_b, &pk_a, &ctx, &mut rng);

    let mut triple = rns_ct_mul(&a, &b, &ctx);
    triple.scale = f64::NAN; // Tamper after valid multiply

    // Pre-R10: NaN scale flows into result ciphertext unchecked
    let ct = rns_relinearize(triple, &evk, &ctx);
    // Would then fail at rescale, but R10 catches earlier
}

/// Compound: rns_ct_mul with mismatched primes + rns_relinearize.
/// Pre-R10: rns_ct_mul would panic deep in RnsPoly::add with unhelpful msg.
/// Post-R10: clear "num_primes mismatch" error with suggestion.
#[test]
#[should_panic(expected = "rns_ct_mul: num_primes mismatch")]
fn r10_compound_mul_then_relin_prime_mismatch() {
    let mut rng = test_rng_seed(10073);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let mut b = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Directly truncate b's polynomials to 3 primes without changing level.
    // This simulates a deserialized ciphertext with matching scale/level
    // but mismatched prime counts.
    b.c0 = RnsPoly {
        residues: b.c0.residues[..3].to_vec(),
        num_primes: 3,
    };
    b.c1 = RnsPoly {
        residues: b.c1.residues[..3].to_vec(),
        num_primes: 3,
    };

    // rns_ct_mul should catch the mismatch, not poly_mul
    let triple = rns_ct_mul(&a, &b, &ctx);
    let _ = rns_relinearize(triple, &evk, &ctx);
}
