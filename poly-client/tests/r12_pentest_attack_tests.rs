//! Round 12 Penetration Test -- Attack Tests for poly-client
//!
//! Focus areas:
//! - R12-VULN-01: Auth tag channel permutation attack (RNS channel reorder)
//! - R12-VULN-02: Residue coefficient out-of-range injection via deserialization
//! - R12-VULN-03: Scale arithmetic overflow in repeated multiply without rescale
//! - R12-VULN-04: Compression v2 reserved byte exploitation
//! - R12-VULN-05: Level field forgery (level vs num_primes inconsistency)
//! - R12-VULN-06: Auth tag domain version binding (v2 -> v3 upgrade)
//! - R12-VULN-07: RnsPoly structural invariant violations
//! - R12-VULN-08: Plaintext multiply scale overflow

#![cfg(feature = "ckks")]
#![allow(unused_variables)]

use poly_client::ckks::compress::{self, CompressionLevel};
use poly_client::ckks::ntt::NTT_PRIMES;
use poly_client::ckks::rns::RnsPoly;
use poly_client::ckks::rns_ckks::*;
use poly_client::ckks::simd;

use rand::rngs::StdRng;
use rand::SeedableRng;

fn test_rng_seed(seed: u64) -> StdRng {
    StdRng::seed_from_u64(seed)
}

// =============================================================================
// SECTION 1: Auth tag channel permutation attack (R12-VULN-01)
// =============================================================================

/// R12-VULN-01a: Permuting RNS residue channels changes the polynomial
/// (different CRT reconstruction) but previously produced the same auth tag
/// because the tag only hashed coefficient bytes without channel identifiers.
/// After R12 fix, swapping channels invalidates the tag.
#[test]
fn r12_auth_tag_channel_permutation_detected() {
    let mut rng = test_rng_seed(12001);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0xABu8; 32];

    let mut ct = rns_encrypt_f64(3.14, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    assert!(ct.verify_auth(&mac_key), "legitimate tag should verify");

    // Swap channels 0 and 1 in c0 (changes the polynomial under CRT)
    let mut tampered = ct.clone();
    tampered.c0.residues.swap(0, 1);
    // Re-authenticate the tampered ciphertext would produce a DIFFERENT tag
    // because channel indices are now bound in the tag
    assert!(
        !tampered.verify_auth(&mac_key),
        "channel permutation must invalidate the auth tag"
    );
}

/// R12-VULN-01b: Swapping c1 channels should also be detected.
#[test]
fn r12_auth_tag_c1_channel_permutation_detected() {
    let mut rng = test_rng_seed(12002);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0xCDu8; 32];

    let mut ct = rns_encrypt_f64(2.71, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    assert!(ct.verify_auth(&mac_key));

    // Swap channels 1 and 2 in c1
    let mut tampered = ct.clone();
    tampered.c1.residues.swap(1, 2);
    assert!(
        !tampered.verify_auth(&mac_key),
        "c1 channel permutation must invalidate auth tag"
    );
}

/// R12-VULN-01c: Legitimate ciphertext with proper tag still verifies.
#[test]
fn r12_auth_tag_legitimate_roundtrip() {
    let mut rng = test_rng_seed(12003);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x42u8; 32];

    let mut ct = rns_encrypt_simd(&[1.0, 2.0, 3.0, 4.0], &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    assert!(ct.verify_auth(&mac_key));

    // Decrypt should work
    let dec = rns_decrypt_simd(&ct, &s, &ctx, 4);
    for i in 0..4 {
        assert!(
            (dec[i] - (i as f64 + 1.0)).abs() < 0.1,
            "slot {} expected {}, got {}",
            i,
            i + 1,
            dec[i]
        );
    }
}

/// R12-VULN-01d: Auth tag version upgrade -- old v2 tags should not verify
/// against new v3 computation (domain separation).
#[test]
fn r12_auth_tag_version_binding() {
    let mut rng = test_rng_seed(12004);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x99u8; 32];

    let ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);

    // Manually compute what the old v2 tag would be (without channel indices)
    // and verify it does NOT match the current tag
    use hmac::{Hmac, Mac};
    use sha2::Sha256;
    let mut mac_old = Hmac::<Sha256>::new_from_slice(&mac_key).unwrap();
    mac_old.update(b"rns_ckks_auth_v2"); // old version string
    mac_old.update(&ct.scale.to_le_bytes());
    mac_old.update(&(ct.level as u64).to_le_bytes());
    mac_old.update(&(ct.c0.num_primes as u64).to_le_bytes());
    mac_old.update(&(ct.c1.num_primes as u64).to_le_bytes());
    for ch in &ct.c0.residues {
        for &coeff in ch {
            mac_old.update(&coeff.to_le_bytes());
        }
    }
    for ch in &ct.c1.residues {
        for &coeff in ch {
            mac_old.update(&coeff.to_le_bytes());
        }
    }
    let old_tag: [u8; 32] = mac_old.finalize().into_bytes().into();

    let new_tag = ct.compute_auth_tag(&mac_key);
    assert_ne!(
        old_tag, new_tag,
        "v2 and v3 auth tags must differ (domain separation)"
    );
}

// =============================================================================
// SECTION 2: Residue coefficient out-of-range injection (R12-VULN-02)
// =============================================================================

/// R12-VULN-02a: Negative residue coefficient in c0 -- decryption should reject.
#[test]
#[should_panic(expected = "out of range")]
fn r12_negative_residue_coefficient_rejected() {
    let mut rng = test_rng_seed(12010);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    // Inject negative coefficient
    ct.c0.residues[0][0] = -1;

    let _ = rns_decrypt_simd(&ct, &s, &ctx, 1);
}

/// R12-VULN-02b: Coefficient >= q_i in c0 -- decryption should reject.
#[test]
#[should_panic(expected = "out of range")]
fn r12_overlarge_residue_coefficient_rejected() {
    let mut rng = test_rng_seed(12011);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    // Inject coefficient >= q_0
    ct.c0.residues[0][0] = NTT_PRIMES[0]; // exactly q, not in [0, q)

    let _ = rns_decrypt_simd(&ct, &s, &ctx, 1);
}

/// R12-VULN-02c: Negative residue in c1 -- decryption should reject.
#[test]
#[should_panic(expected = "out of range")]
fn r12_negative_residue_c1_rejected() {
    let mut rng = test_rng_seed(12012);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.c1.residues[1][100] = -42;

    let _ = rns_decrypt_simd(&ct, &s, &ctx, 1);
}

/// R12-VULN-02d: Max i64 value in residue -- way out of range.
#[test]
#[should_panic(expected = "out of range")]
fn r12_i64_max_residue_rejected() {
    let mut rng = test_rng_seed(12013);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.c0.residues[2][0] = i64::MAX;

    let _ = rns_decrypt_simd(&ct, &s, &ctx, 1);
}

/// R12-VULN-02e: Legitimate ciphertext passes residue range validation.
#[test]
fn r12_legitimate_residues_pass_validation() {
    let mut rng = test_rng_seed(12014);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(42.0, &pk_b, &pk_a, &ctx, &mut rng);
    // Decrypt should succeed
    let dec = rns_decrypt_f64(&ct, &s, &ctx);
    assert!((dec - 42.0).abs() < 0.1, "expected ~42.0, got {}", dec);

    // Also validate via the new method
    assert!(ct.c0.validate_residue_ranges());
    assert!(ct.c1.validate_residue_ranges());
}

/// R12-VULN-02f: validate_residue_ranges catches mismatched residue length.
#[test]
fn r12_validate_residue_ranges_wrong_length() {
    let mut poly = RnsPoly::from_coeffs(&[1, 2, 3], 2);
    assert!(poly.validate_residue_ranges());

    // Truncate one channel's coefficients
    poly.residues[0].truncate(10);
    assert!(
        !poly.validate_residue_ranges(),
        "truncated residue channel should fail validation"
    );
}

/// R12-VULN-02g: validate_residue_ranges catches mismatched num_primes.
#[test]
fn r12_validate_residue_ranges_wrong_num_primes() {
    let mut poly = RnsPoly::from_coeffs(&[1, 2, 3], 3);
    assert!(poly.validate_residue_ranges());

    // Lie about num_primes
    poly.num_primes = 5;
    assert!(
        !poly.validate_residue_ranges(),
        "num_primes > residues.len() should fail"
    );
}

// =============================================================================
// SECTION 3: Scale arithmetic overflow (R12-VULN-03)
// =============================================================================

/// R12-VULN-03a: rns_ct_mul with huge scales that overflow to infinity.
#[test]
#[should_panic(expected = "product scale overflows")]
fn r12_ct_mul_scale_overflow_to_inf() {
    let mut rng = test_rng_seed(12020);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    // Craft absurdly large scale -- f64::MAX / 2 * f64::MAX / 2 = Inf
    ct.scale = f64::MAX / 2.0;

    let _ = rns_ct_mul(&ct, &ct, &ctx);
}

/// R12-VULN-03b: rns_ct_mul_leveled with overflow scale.
#[test]
#[should_panic(expected = "product scale overflows")]
fn r12_ct_mul_leveled_scale_overflow() {
    let mut rng = test_rng_seed(12021);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct_a = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let mut ct_b = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct_a.scale = 1e200;
    ct_b.scale = 1e200;

    let _ = rns_ct_mul_leveled(&ct_a, &ct_b, &ctx);
}

/// R12-VULN-03c: Normal multiply-then-rescale still works.
#[test]
fn r12_normal_multiply_rescale_works() {
    let mut rng = test_rng_seed(12022);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct = rns_encrypt_f64(3.0, &pk_b, &pk_a, &ctx, &mut rng);
    let ct_sq = rns_ct_mul_relin(&ct, &ct, &evk, &ctx);
    // Scale = delta^2, should be finite
    assert!(ct_sq.scale.is_finite());
    let ct_rescaled = rns_rescale(&ct_sq);
    let dec = rns_decrypt_f64(&ct_rescaled, &s, &ctx);
    assert!((dec - 9.0).abs() < 1.0, "3^2 expected ~9, got {}", dec);
}

/// R12-VULN-03d: Plaintext multiply scale overflow.
#[test]
#[should_panic(expected = "product scale overflows")]
fn r12_plain_mul_scale_overflow() {
    let mut rng = test_rng_seed(12023);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.scale = f64::MAX / 2.0; // near f64::MAX, delta * this = Inf

    let values = vec![1.0; simd::NUM_SLOTS];
    let _ = rns_ct_mul_plain_simd(&ct, &values, &ctx);
}

// =============================================================================
// SECTION 4: Compression v2 reserved byte exploitation (R12-VULN-04)
// =============================================================================

/// R12-VULN-04a: Non-zero reserved byte in v2 header should be rejected.
#[test]
fn r12_compress_v2_nonzero_reserved_byte_rejected() {
    let data: Vec<i64> = (0..100).collect();
    let mut compressed = compress::compress_with(&data, CompressionLevel::Compact).unwrap();
    // byte[6] is the reserved byte
    assert_eq!(compressed[6], 0, "reserved byte should be 0 by default");
    compressed[6] = 0xFF; // set to non-zero
    let result: Result<Vec<i64>, _> = compress::decompress(&compressed);
    assert!(
        result.is_err(),
        "non-zero reserved byte should cause decompression failure"
    );
}

/// R12-VULN-04b: Various non-zero reserved byte values all rejected.
#[test]
fn r12_compress_v2_all_reserved_byte_values_rejected() {
    let data: Vec<i64> = (0..50).collect();
    let compressed = compress::compress_with(&data, CompressionLevel::Compact).unwrap();

    for val in [1u8, 42, 128, 255] {
        let mut tampered = compressed.clone();
        tampered[6] = val;
        let result: Result<Vec<i64>, _> = compress::decompress(&tampered);
        assert!(
            result.is_err(),
            "reserved byte {} should be rejected",
            val
        );
    }
}

/// R12-VULN-04c: Zero reserved byte still works (Compact).
#[test]
fn r12_compress_v2_zero_reserved_byte_ok_compact() {
    let data: Vec<i64> = (0..200).collect();
    let compressed = compress::compress_with(&data, CompressionLevel::Compact).unwrap();
    assert_eq!(compressed[6], 0);
    let decompressed: Vec<i64> = compress::decompress(&compressed).unwrap();
    assert_eq!(data, decompressed);
}

/// R12-VULN-04d: Zero reserved byte still works (Max).
#[test]
fn r12_compress_v2_zero_reserved_byte_ok_max() {
    let data: Vec<i64> = (0..200).collect();
    let compressed = compress::compress_with(&data, CompressionLevel::Max).unwrap();
    assert_eq!(compressed[6], 0);
    let decompressed: Vec<i64> = compress::decompress(&compressed).unwrap();
    assert_eq!(data, decompressed);
}

// =============================================================================
// SECTION 5: Level field forgery (R12-VULN-05)
// =============================================================================

/// R12-VULN-05a: Level field is not cross-validated with num_primes.
/// An attacker can set level=0 on a ciphertext with only 2 primes,
/// fooling logic that uses level for budget calculations.
/// This test documents that the level field is purely advisory metadata.
#[test]
fn r12_level_field_not_bound_to_primes() {
    let mut rng = test_rng_seed(12050);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct = rns_encrypt_f64(2.0, &pk_b, &pk_a, &ctx, &mut rng);
    // Multiply and rescale: 5 -> 4 primes, level 0 -> 1
    let ct_sq = rns_ct_mul_relin(&ct, &ct, &evk, &ctx);
    let ct_rescaled = rns_rescale(&ct_sq);
    assert_eq!(ct_rescaled.c0.num_primes, 4);
    assert_eq!(ct_rescaled.level, 1);

    // Forge: set level back to 0 while keeping 4 primes
    let mut forged = ct_rescaled.clone();
    forged.level = 0;

    // This still decrypts fine -- level is metadata only
    let dec = rns_decrypt_f64(&forged, &s, &ctx);
    assert!(
        (dec - 4.0).abs() < 1.0,
        "decryption should work regardless of level field, got {}",
        dec
    );
}

/// R12-VULN-05b: Auth tag DOES bind the level field, so forging level
/// invalidates the tag.
#[test]
fn r12_auth_tag_binds_level_field() {
    let mut rng = test_rng_seed(12051);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x55u8; 32];

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);
    assert!(ct.verify_auth(&mac_key));

    // Forge level
    ct.level = 99;
    assert!(
        !ct.verify_auth(&mac_key),
        "level tampering must invalidate auth tag"
    );
}

/// R12-VULN-05c: Inconsistent level between operands in strict add.
#[test]
#[should_panic(expected = "level mismatch")]
fn r12_strict_add_level_mismatch() {
    let mut rng = test_rng_seed(12052);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct1 = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    let mut ct2 = rns_encrypt_f64(2.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct2.level = 1; // lie about level

    let _ = rns_ct_add(&ct1, &ct2);
}

// =============================================================================
// SECTION 6: RnsPoly structural invariant violations (R12-VULN-07)
// =============================================================================

/// R12-VULN-07a: from_coeffs with empty coefficient array creates zero poly.
#[test]
fn r12_from_coeffs_empty_is_zero() {
    let poly = RnsPoly::from_coeffs(&[], 3);
    assert_eq!(poly.num_primes, 3);
    let coeffs = poly.to_coeffs();
    assert!(coeffs.iter().all(|&c| c == 0), "empty coeffs should produce zero poly");
}

/// R12-VULN-07b: from_coeffs with N coefficients is valid.
#[test]
fn r12_from_coeffs_full_ring() {
    use poly_client::ckks::params::N;
    let input: Vec<i64> = (0..N as i64).collect();
    let poly = RnsPoly::from_coeffs(&input, 2);
    assert_eq!(poly.num_primes, 2);
    assert!(poly.validate_residue_ranges());
}

/// R12-VULN-07c: from_coeffs with more than N coefficients should panic.
#[test]
#[should_panic(expected = "coefficient count")]
fn r12_from_coeffs_too_many_coeffs() {
    use poly_client::ckks::params::N;
    let input: Vec<i64> = (0..N as i64 + 1).collect();
    let _ = RnsPoly::from_coeffs(&input, 1);
}

/// R12-VULN-07d: RnsPoly::zero(0) should panic (no primes).
/// Actually: the function allows 0 primes (creates empty residues).
/// This is safe but potentially surprising. Document the behavior.
#[test]
fn r12_zero_poly_zero_primes() {
    let poly = RnsPoly::zero(0);
    assert_eq!(poly.num_primes, 0);
    assert_eq!(poly.residues.len(), 0);
}

/// R12-VULN-07e: Requesting too many primes should panic.
#[test]
#[should_panic(expected = "only")]
fn r12_from_coeffs_too_many_primes() {
    let _ = RnsPoly::from_coeffs(&[1], 21); // only 20 primes available
}

// =============================================================================
// SECTION 7: Serialization/deserialization attack vectors (R12-VULN-08)
// =============================================================================

/// R12-VULN-08a: Deserialize a ciphertext with tampered coefficients
/// and verify auth tag rejects it.
#[test]
fn r12_serde_tampered_ct_auth_rejects() {
    let mut rng = test_rng_seed(12070);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0x77u8; 32];

    let mut ct = rns_encrypt_f64(5.0, &pk_b, &pk_a, &ctx, &mut rng);
    ct.authenticate(&mac_key);

    // Serialize
    let json = serde_json::to_string(&ct).unwrap();

    // Deserialize and verify
    let ct2: RnsCiphertext = serde_json::from_str(&json).unwrap();
    assert!(ct2.verify_auth(&mac_key));

    // Tamper with one coefficient after deserialization
    let mut ct3: RnsCiphertext = serde_json::from_str(&json).unwrap();
    ct3.c0.residues[0][0] = (ct3.c0.residues[0][0] + 1) % NTT_PRIMES[0];
    assert!(
        !ct3.verify_auth(&mac_key),
        "tampered deserialized ct must fail auth"
    );
}

/// R12-VULN-08b: Serialization roundtrip preserves all fields.
#[test]
fn r12_serde_roundtrip_preserves_fields() {
    let mut rng = test_rng_seed(12071);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(7.77, &pk_b, &pk_a, &ctx, &mut rng);
    let json = serde_json::to_string(&ct).unwrap();
    let ct2: RnsCiphertext = serde_json::from_str(&json).unwrap();

    assert_eq!(ct.c0.num_primes, ct2.c0.num_primes);
    assert_eq!(ct.c1.num_primes, ct2.c1.num_primes);
    assert_eq!(ct.scale, ct2.scale);
    assert_eq!(ct.level, ct2.level);
    assert_eq!(ct.c0.residues, ct2.c0.residues);
    assert_eq!(ct.c1.residues, ct2.c1.residues);
}

// =============================================================================
// SECTION 8: Compound/chain attacks (multi-step)
// =============================================================================

/// R12-CHAIN-01: Attacker injects out-of-range residues, authenticates with
/// their own key, then tries to pass through checked decrypt.
#[test]
#[should_panic(expected = "out of range")]
fn r12_chain_inject_authenticate_then_checked_decrypt() {
    let mut rng = test_rng_seed(12080);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let mac_key = [0xEEu8; 32];

    let mut ct = rns_encrypt_f64(1.0, &pk_b, &pk_a, &ctx, &mut rng);
    // Inject out-of-range coefficient
    ct.c0.residues[0][42] = NTT_PRIMES[0] + 100;
    // Re-authenticate (attacker has mac_key)
    ct.authenticate(&mac_key);
    // Auth tag will verify...
    assert!(ct.verify_auth(&mac_key));
    // But the residue range check in decrypt catches the injection
    let _ = rns_decrypt_simd_checked(&ct, &s, &mac_key, &ctx, 1);
}

/// R12-CHAIN-02: Scale overflow via repeated multiply without rescale.
/// The fix ensures this is caught at the multiply step.
#[test]
fn r12_chain_deep_multiply_without_rescale() {
    let mut rng = test_rng_seed(12081);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct = rns_encrypt_f64(1.5, &pk_b, &pk_a, &ctx, &mut rng);
    // First multiply without rescale: scale = delta^2
    let ct_sq = rns_ct_mul_relin(&ct, &ct, &evk, &ctx);
    assert!(ct_sq.scale.is_finite(), "first multiply scale should be finite");

    // Second multiply without rescale: scale = delta^4
    // This works because delta^4 = 2^144 is still within f64 range
    let ct_4th = rns_ct_mul_relin(&ct_sq, &ct_sq, &evk, &ctx);
    assert!(ct_4th.scale.is_finite(), "second multiply scale should still be finite");

    // Verify the scale is delta^4
    let expected_scale = ctx.delta.powi(4);
    assert!(
        (ct_4th.scale - expected_scale).abs() / expected_scale < 1e-10,
        "scale should be delta^4, got {:.2e} vs {:.2e}",
        ct_4th.scale,
        expected_scale
    );
}

/// R12-CHAIN-03: Encrypt -> mod_switch -> multiply chain with proper level tracking.
#[test]
fn r12_chain_mod_switch_then_multiply() {
    let mut rng = test_rng_seed(12082);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let ct = rns_encrypt_f64(2.0, &pk_b, &pk_a, &ctx, &mut rng);
    // Mod-switch to 3 primes
    let ct_switched = rns_ct_mod_switch_to(&ct, 3);
    assert_eq!(ct_switched.c0.num_primes, 3);
    assert_eq!(ct_switched.level, 2);

    // Multiply at reduced level
    let ct_sq = rns_ct_mul_relin(&ct_switched, &ct_switched, &evk, &ctx);
    let ct_rescaled = rns_rescale(&ct_sq);

    let dec = rns_decrypt_f64(&ct_rescaled, &s, &ctx);
    assert!((dec - 4.0).abs() < 1.0, "2^2 expected ~4, got {}", dec);
}

// =============================================================================
// SECTION 9: Edge cases in polynomial evaluation (R12-VULN-09)
// =============================================================================

/// R12-VULN-09a: Poly eval with all-zero polynomial except constant.
#[test]
fn r12_poly_eval_constant_polynomial() {
    let mut rng = test_rng_seed(12090);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let input = vec![3.0; simd::NUM_SLOTS];
    let ct_x = rns_encrypt_simd(&input, &pk_b, &pk_a, &ctx, &mut rng);

    // P(x) = 5 + 0*x (degree 1 with zero linear term)
    let coeffs = [5.0, 0.0];
    let ct_result = poly_client::ckks::poly_eval::rns_poly_eval(&ct_x, &coeffs, &evk, &ctx);
    let dec = rns_decrypt_simd(&ct_result, &s, &ctx, 4);

    for i in 0..4 {
        assert!(
            (dec[i] - 5.0).abs() < 1.0,
            "slot {} constant poly: expected 5, got {}",
            i,
            dec[i]
        );
    }
}

/// R12-VULN-09b: Poly eval with very small coefficients.
#[test]
fn r12_poly_eval_tiny_coefficients() {
    let mut rng = test_rng_seed(12091);
    let ctx = RnsCkksContext::new(5);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);
    let evk = rns_gen_eval_key(&s, &ctx, &mut rng);

    let input = vec![1.0; simd::NUM_SLOTS];
    let ct_x = rns_encrypt_simd(&input, &pk_b, &pk_a, &ctx, &mut rng);

    // P(x) = 1e-10 + 1e-10*x (very small coefficients)
    let coeffs = [1e-10, 1e-10];
    let ct_result = poly_client::ckks::poly_eval::rns_poly_eval(&ct_x, &coeffs, &evk, &ctx);
    let dec = rns_decrypt_simd(&ct_result, &s, &ctx, 4);

    let expected = 2e-10;
    for i in 0..4 {
        // Very small values have larger relative error but should be close to zero
        assert!(
            dec[i].abs() < 1.0,
            "slot {} tiny coeffs: expected ~0, got {}",
            i,
            dec[i]
        );
    }
}

// =============================================================================
// SECTION 10: NTT domain integrity attacks (R12-VULN-10)
// =============================================================================

/// R12-VULN-10a: NTT forward/inverse roundtrip preserves coefficients exactly.
/// This verifies the NTT implementation has no off-by-one or sign errors.
#[test]
fn r12_ntt_roundtrip_all_primes() {
    use poly_client::ckks::ntt::NttContext;

    for (idx, &q) in NTT_PRIMES.iter().enumerate() {
        let ctx = NttContext::new(q);
        // Test with random-looking pattern
        let a: Vec<i64> = (0..4096)
            .map(|i| ((i as i64 * 31337 + idx as i64 * 7919) % q + q) % q)
            .collect();
        let ntt_a = ctx.forward(&a);
        let back = ctx.inverse(&ntt_a);
        for j in 0..4096 {
            assert_eq!(
                back[j], a[j],
                "NTT roundtrip failed for prime[{}]={} at coeff[{}]",
                idx, q, j
            );
        }
    }
}

/// R12-VULN-10b: NTT multiply consistency across all 20 primes.
/// Verifies that poly_mul produces consistent results for all channels.
#[test]
fn r12_ntt_mul_cross_prime_consistency() {
    use poly_client::ckks::ntt::NttContext;
    use poly_client::ckks::params::N;

    // Simple polynomial: (1 + 2X) * (3 + 4X) = 3 + 10X + 8X^2
    let mut a = vec![0i64; N];
    a[0] = 1;
    a[1] = 2;
    let mut b = vec![0i64; N];
    b[0] = 3;
    b[1] = 4;

    for &q in &NTT_PRIMES {
        let ctx = NttContext::new(q);
        let a_mod: Vec<i64> = a.iter().map(|&v| ((v % q) + q) % q).collect();
        let b_mod: Vec<i64> = b.iter().map(|&v| ((v % q) + q) % q).collect();
        let c = ctx.mul(&a_mod, &b_mod);
        assert_eq!(ctx.center(c[0]), 3, "constant term wrong for q={}", q);
        assert_eq!(ctx.center(c[1]), 10, "linear term wrong for q={}", q);
        assert_eq!(ctx.center(c[2]), 8, "quadratic term wrong for q={}", q);
    }
}

// =============================================================================
// SECTION 11: SIMD encoding edge cases (R12-VULN-11)
// =============================================================================

/// R12-VULN-11a: Encoding with maximum slot count.
#[test]
fn r12_simd_encode_max_slots() {
    let values: Vec<f64> = (0..simd::NUM_SLOTS).map(|i| i as f64 * 0.001).collect();
    let delta = (1u64 << 36) as f64;
    let coeffs = simd::encode_simd(&values, delta);
    assert_eq!(coeffs.len(), 4096);
    let decoded = simd::decode_simd(&coeffs, delta, simd::NUM_SLOTS);
    let max_err = values
        .iter()
        .zip(decoded.iter())
        .map(|(a, b)| (a - b).abs())
        .fold(0.0f64, f64::max);
    assert!(max_err < 0.01, "max error {} too large for full-slot encode", max_err);
}

/// R12-VULN-11b: Encoding a single slot leaves others at zero.
#[test]
fn r12_simd_encode_single_slot() {
    let delta = (1u64 << 30) as f64;
    let coeffs = simd::encode_simd(&[42.0], delta);
    let decoded = simd::decode_simd(&coeffs, delta, 4);
    assert!((decoded[0] - 42.0).abs() < 0.01);
    for i in 1..4 {
        assert!(
            decoded[i].abs() < 0.01,
            "slot {} should be ~0, got {}",
            i,
            decoded[i]
        );
    }
}

/// R12-VULN-11c: Encoding with very large values near SIMD wrap-around.
#[test]
fn r12_simd_encode_large_values() {
    let delta = (1u64 << 36) as f64;
    let values = vec![1e6, -1e6, 1e5, -1e5];
    let coeffs = simd::encode_simd(&values, delta);
    let decoded = simd::decode_simd(&coeffs, delta, 4);
    for i in 0..4 {
        let err = (decoded[i] - values[i]).abs();
        assert!(
            err < 1.0,
            "slot {} large value: expected {}, got {}, err={}",
            i, values[i], decoded[i], err
        );
    }
}

// =============================================================================
// SECTION 12: Compression integrity chain (R12-VULN-12)
// =============================================================================

/// R12-VULN-12a: Compressed ciphertext roundtrip preserves decryptable value.
#[test]
fn r12_compress_ciphertext_functional_roundtrip() {
    let mut rng = test_rng_seed(12120);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(99.9, &pk_b, &pk_a, &ctx, &mut rng);
    let compressed = compress::compress(&ct).unwrap();
    let ct2: RnsCiphertext = compress::decompress(&compressed).unwrap();

    let dec = rns_decrypt_f64(&ct2, &s, &ctx);
    assert!((dec - 99.9).abs() < 0.1, "compressed roundtrip: expected 99.9, got {}", dec);
}

/// R12-VULN-12b: Compression level detection consistency.
#[test]
fn r12_compress_level_detection_consistency() {
    let data: Vec<i64> = (0..200).collect();

    let v1 = compress::compress(&data).unwrap();
    assert_eq!(compress::detect_level(&v1), Some(CompressionLevel::Lossless));

    let v2c = compress::compress_with(&data, CompressionLevel::Compact).unwrap();
    assert_eq!(compress::detect_level(&v2c), Some(CompressionLevel::Compact));

    let v2m = compress::compress_with(&data, CompressionLevel::Max).unwrap();
    assert_eq!(compress::detect_level(&v2m), Some(CompressionLevel::Max));
}

/// R12-VULN-12c: Entropy check on legitimate ciphertext passes.
#[test]
fn r12_entropy_check_real_ciphertext() {
    let mut rng = test_rng_seed(12122);
    let ctx = RnsCkksContext::new(3);
    let (s, pk_b, pk_a) = rns_keygen(&ctx, &mut rng);

    let ct = rns_encrypt_f64(42.0, &pk_b, &pk_a, &ctx, &mut rng);
    let check = compress::entropy_check(&ct);
    assert!(
        check.pass,
        "real ciphertext should pass entropy check: ratio={:.2}",
        check.ratio
    );
}

// =============================================================================
// SECTION 13: Galois automorphism edge cases (R12-VULN-13)
// =============================================================================

/// R12-VULN-13a: Automorphism with identity element (m=1) is identity.
#[test]
fn r12_automorphism_identity_preserves_poly() {
    let coeffs: Vec<i64> = (0..100).map(|i| i * 3 - 50).collect();
    let p = RnsPoly::from_coeffs(&coeffs, 3);
    let q = p.apply_automorphism(1);
    let result = q.to_coeffs();
    for i in 0..100 {
        assert_eq!(result[i], coeffs[i], "identity auto failed at {}", i);
    }
}

/// R12-VULN-13b: Automorphism with largest valid element (2N-1).
#[test]
fn r12_automorphism_max_element() {
    let two_n = 2 * 4096;
    let m = two_n - 1; // 8191, which is odd
    let poly = RnsPoly::from_coeffs(&[1, 2, 3], 2);
    let result = poly.apply_automorphism(m);
    // Should not panic and produce a valid polynomial
    assert!(result.validate_residue_ranges());
    assert_eq!(result.num_primes, 2);
}

/// R12-VULN-13c: Even automorphism index should be rejected.
#[test]
#[should_panic(expected = "odd")]
fn r12_automorphism_even_index_rejected() {
    let poly = RnsPoly::from_coeffs(&[1], 1);
    let _ = poly.apply_automorphism(4); // even, not valid
}

// =============================================================================
// SECTION 14: FHE layer edge cases (R12-VULN-14)
// =============================================================================

/// R12-VULN-14a: Neural net with dim=1 (scalar case).
#[test]
fn r12_fhe_layer_dim_1() {
    use poly_client::ckks::rns_fhe_layer::*;

    let mut rng = test_rng_seed(12140);
    let ctx = RnsCkksContext::new(4);
    let d = 1;
    let net = RnsNeuralNet {
        dim: d,
        weights: vec![vec![2.0]], // 2x
        biases: vec![vec![1.0]],  // +1
        activations: vec![Activation::Square],
    };

    let keys = rns_neural_net_keygen(&net, &ctx, &mut rng);

    let input = vec![3.0]; // 2*3 + 1 = 7, 7^2 = 49
    let expected = rns_plaintext_forward(&input, &net);
    assert!((expected[0] - 49.0).abs() < 0.01);

    let ct_result = rns_forward(&input, &net, &keys, &ctx, &mut rng);
    let dec = rns_decrypt_simd(&ct_result, &keys.secret, &ctx, d);

    assert!(
        (dec[0] - 49.0).abs() < 5.0,
        "dim=1 FHE: expected 49, got {}",
        dec[0]
    );
}

/// R12-VULN-14b: Neural net with all-zero weights produces bias-only output.
#[test]
fn r12_fhe_layer_zero_weights() {
    use poly_client::ckks::rns_fhe_layer::*;

    let rng = test_rng_seed(12141);
    let d = 4;
    let net = RnsNeuralNet {
        dim: d,
        weights: vec![vec![0.0; d * d]],
        biases: vec![vec![10.0, 20.0, 30.0, 40.0]],
        activations: vec![Activation::None],
    };

    let input = vec![99.0, 88.0, 77.0, 66.0];
    let expected = rns_plaintext_forward(&input, &net);
    // W*x = 0, so output = bias
    for i in 0..d {
        assert!(
            (expected[i] - (10.0 * (i as f64 + 1.0))).abs() < 0.01,
            "zero weights: expected bias, got {}",
            expected[i]
        );
    }
}

/// R12-VULN-14c: Neural net with identity + large bias, no activation.
#[test]
fn r12_fhe_layer_identity_large_bias() {
    use poly_client::ckks::rns_fhe_layer::*;

    let mut rng = test_rng_seed(12142);
    let ctx = RnsCkksContext::new(3);
    let d = 4;

    let mut identity = vec![0.0; d * d];
    for i in 0..d {
        identity[i * d + i] = 1.0;
    }
    let biases = vec![1000.0, 2000.0, 3000.0, 4000.0];

    let net = RnsNeuralNet {
        dim: d,
        weights: vec![identity],
        biases: vec![biases.clone()],
        activations: vec![Activation::None],
    };

    let input = vec![1.0, 2.0, 3.0, 4.0];
    let expected = rns_plaintext_forward(&input, &net);

    let keys = rns_neural_net_keygen(&net, &ctx, &mut rng);
    let ct_result = rns_forward(&input, &net, &keys, &ctx, &mut rng);
    let dec = rns_decrypt_simd(&ct_result, &keys.secret, &ctx, d);

    for i in 0..d {
        assert!(
            (dec[i] - expected[i]).abs() < 5.0,
            "slot {} large bias: expected {}, got {}",
            i, expected[i], dec[i]
        );
    }
}

// =============================================================================
// SECTION 15: Wide integer arithmetic edge cases (R12-VULN-15)
// =============================================================================

/// R12-VULN-15a: CRT reconstruction with many primes (10+) should work.
#[test]
fn r12_crt_many_primes_reconstruction() {
    for num_primes in [5, 10, 15, 20] {
        let val = 12345i64;
        let poly = RnsPoly::from_coeffs(&[val], num_primes);
        let coeffs = poly.to_coeffs();
        assert_eq!(
            coeffs[0], val,
            "CRT reconstruction failed for {} primes",
            num_primes
        );
    }
}

/// R12-VULN-15b: CRT reconstruction of negative values with many primes.
#[test]
fn r12_crt_negative_many_primes() {
    for num_primes in [4, 8, 12, 16, 20] {
        let val = -99999i64;
        let poly = RnsPoly::from_coeffs(&[val], num_primes);
        let coeffs = poly.to_coeffs();
        assert_eq!(
            coeffs[0], val,
            "CRT negative reconstruction failed for {} primes",
            num_primes
        );
    }
}

/// R12-VULN-15c: CRT reconstruction of zero with many primes.
#[test]
fn r12_crt_zero_many_primes() {
    for num_primes in [1, 5, 10, 20] {
        let poly = RnsPoly::from_coeffs(&[0], num_primes);
        let coeffs = poly.to_coeffs();
        assert_eq!(
            coeffs[0], 0,
            "CRT zero reconstruction failed for {} primes",
            num_primes
        );
    }
}
