//! Round 8 Pentest Attack Tests for poly-verified.
//!
//! Findings:
//! V8-01 HIGH (FIXED):    FixedPoint Display/Debug loses sign for negative fractional values in (-1, 0)
//! V8-02 HIGH:            FixedPoint::exp_approx(0 terms) returns ONE regardless of input
//! V8-03 HIGH (FIXED):    CompositeProof::compose accepts unbounded inner_proofs count (DoS)
//! V8-04 MEDIUM:          FixedPoint::to_i64 silently wraps on overflow (to_i64_saturating added)
//! V8-05 MEDIUM:          verify_disclosure does not reject HashIvc proof with ZERO_HASH output binding
//! V8-06 MEDIUM:          Single-leaf Merkle proof has zero siblings (trivially forgeable if leaf known)
//! V8-07 MEDIUM:          Disclosure with all-revealed tokens leaks full plaintext + Merkle structure
//! V8-08 MEDIUM:          CompositeProof serde roundtrip bypasses compose() constructor guard
//! V8-09 MEDIUM:          FixedPoint::exp_approx with large negative input diverges to wrong sign
//! V8-10 LOW:             CodeAttestation sign_message does not include node public key
//! V8-11 LOW:             VerifiedResponse Private mode does not enforce empty value_bytes on receive
//! V8-12 LOW:             HashIvc accumulator input_hash/output_hash are pub fields (bypass I/O binding)

use sha2::{Digest, Sha256};

use poly_verified::crypto::hash::hash_data;
use poly_verified::crypto::merkle::{verify_proof, MerkleTree};
use poly_verified::disclosure::{
    create_disclosure, disclosure_output_hash, token_leaf, verify_disclosure, DisclosedToken,
};
use poly_verified::fixed_point::FixedPoint;
use poly_verified::ivc::hash_ivc::HashIvc;
use poly_verified::ivc::IvcBackend;
use poly_verified::proof_composition::CompositeProof;
use poly_verified::proof_serialize::VerifiedResponse;
use poly_verified::types::{
    CodeAttestation, Hash, MerkleProof, PrivacyMode, StepWitness,
    VerifiedProof, ZERO_HASH,
};
use poly_verified::verified_type::Verified;

// ========================================================================
// Helpers
// ========================================================================

fn tokens_hash(tokens: &[u32]) -> Hash {
    let mut hasher = Sha256::new();
    for &t in tokens {
        hasher.update(t.to_le_bytes());
    }
    hasher.finalize().into()
}

fn valid_hash_ivc_proof_for_tokens(tokens: &[u32]) -> VerifiedProof {
    let ivc = HashIvc;
    let code_hash = [0x03; 32];
    let mut acc = ivc.init(&code_hash, PrivacyMode::Transparent);
    let witness = StepWitness {
        state_before: hash_data(b"before"),
        state_after: hash_data(b"after"),
        step_inputs: hash_data(b"inputs"),
    };
    ivc.fold_step(&mut acc, &witness).unwrap();
    acc.input_hash = ZERO_HASH;
    acc.output_hash = disclosure_output_hash(tokens);
    ivc.finalize(acc).unwrap()
}

fn make_verified(tokens: Vec<u32>) -> Verified<Vec<u32>> {
    let proof = valid_hash_ivc_proof_for_tokens(&tokens);
    Verified::__macro_new(tokens, proof)
}

fn sample_tokens() -> Vec<u32> {
    vec![100, 200, 300, 400, 500, 600, 700, 800]
}

fn make_multistep_proof(steps: u8) -> VerifiedProof {
    let ivc = HashIvc;
    let code_hash = hash_data(b"multistep_test");
    let mut acc = ivc.init(&code_hash, PrivacyMode::Transparent);
    for i in 0..steps {
        let witness = StepWitness {
            state_before: hash_data(&[i]),
            state_after: hash_data(&[i + 1]),
            step_inputs: hash_data(&[i * 2]),
        };
        ivc.fold_step(&mut acc, &witness).unwrap();
    }
    ivc.finalize(acc).unwrap()
}

// ========================================================================
// V8-01 HIGH (FIXED): FixedPoint Display/Debug loses sign for (-1, 0) range
// ========================================================================
//
// FixedPoint::Display computes int_part = raw / SCALE, frac_part from remainder.
// For values in (-1.0, 0.0), int_part truncates to 0, losing the negative sign.
// Example: -0.5 displayed as "0.500000" instead of "-0.500000".
//
// This is a correctness bug in verified computation output: a prover could
// display -0.5 as 0.5 to a verifier relying on Display output.
//
// FIX: Display and Debug now check `self.raw < 0 && int_part == 0` and
// explicitly prepend "-".

#[test]
fn fix_v8_01a_display_negative_half() {
    // -0.5 in FixedPoint: raw = -SCALE/2
    let neg_half = FixedPoint::from_decimal(-50, 2); // -0.50
    let display = format!("{}", neg_half);
    assert!(
        display.starts_with('-'),
        "Display of -0.5 should start with '-', got: '{}'",
        display
    );
    assert_eq!(display, "-0.500000");
}

#[test]
fn fix_v8_01b_display_negative_tiny() {
    // -0.001 in FixedPoint
    let neg_tiny = FixedPoint::from_decimal(-1, 3); // -0.001
    let display = format!("{}", neg_tiny);
    assert!(
        display.starts_with('-'),
        "Display of -0.001 should start with '-', got: '{}'",
        display
    );
}

#[test]
fn fix_v8_01c_display_negative_int_still_works() {
    // Negative integer values should still display correctly
    let neg_five = FixedPoint::from_int(-5);
    let display = format!("{}", neg_five);
    assert_eq!(display, "-5");
}

#[test]
fn fix_v8_01d_display_positive_fraction_unchanged() {
    // Positive fractions should be unaffected by the fix
    let pos_half = FixedPoint::from_decimal(50, 2);
    let display = format!("{}", pos_half);
    assert!(!display.starts_with('-'), "Positive fraction should not have '-'");
    assert_eq!(display, "0.500000");
}

#[test]
fn fix_v8_01e_display_zero_unchanged() {
    let zero = FixedPoint::ZERO;
    let display = format!("{}", zero);
    assert_eq!(display, "0");
}

#[test]
fn fix_v8_01f_debug_negative_half() {
    let neg_half = FixedPoint::from_decimal(-50, 2);
    let debug = format!("{:?}", neg_half);
    assert!(
        debug.contains("-0."),
        "Debug of -0.5 should contain '-0.', got: '{}'",
        debug
    );
}

#[test]
fn fix_v8_01g_display_negative_999_thousandths() {
    // -0.999 should show the sign
    let neg = FixedPoint::from_decimal(-999, 3);
    let display = format!("{}", neg);
    assert!(
        display.starts_with('-'),
        "-0.999 should start with '-', got: '{}'",
        display
    );
}

// ========================================================================
// V8-02 HIGH: exp_approx(0 terms) returns ONE regardless of input
// ========================================================================
//
// exp_approx uses a Taylor series: result starts at ONE, then accumulates
// terms. With `terms = 0`, the loop never executes, so the result is
// always ONE (1.0) regardless of the input value.
//
// This means exp_approx(any_value, 0) == 1.0, which is mathematically wrong
// for all non-zero inputs. An attacker providing terms=0 to a verified
// computation gets exp(x) = 1 for any x.
//
// Additionally, with very few terms, exp_approx for large negative inputs
// produces wildly incorrect results (potentially wrong sign) because the
// Taylor series converges slowly for |x| >> 1.

#[test]
fn attack_v8_02a_exp_zero_terms_returns_one() {
    let big = FixedPoint::from_int(100);
    let result = big.exp_approx(0);
    // e^100 with 0 terms returns 1.0 -- mathematically wrong
    assert_eq!(
        result.to_i64(),
        1,
        "exp_approx(0) should return ONE (this IS the vulnerability)"
    );

    let neg = FixedPoint::from_int(-100);
    let result_neg = neg.exp_approx(0);
    // e^(-100) with 0 terms also returns 1.0 -- also wrong
    assert_eq!(result_neg.to_i64(), 1);

    // The correct value of e^100 is astronomically large, and e^(-100) is
    // essentially 0. Returning 1.0 for both is a computation error that
    // would be "proven correct" by the verified execution system.
}

#[test]
fn attack_v8_02b_exp_one_term_is_1_plus_x() {
    // With 1 term: result = 1 + x (linear approximation)
    let x = FixedPoint::from_int(2);
    let result = x.exp_approx(1);
    // e^2 ~= 7.389, but 1-term approx = 1 + 2 = 3
    assert_eq!(result.to_i64(), 3, "1-term exp(2) should be 3 (1 + x)");
}

#[test]
fn attack_v8_02c_exp_sufficient_terms_is_accurate() {
    // With enough terms, exp(1) should be accurate
    let one = FixedPoint::ONE;
    let e = one.exp_approx(20);
    // e ~= 2.718
    assert_eq!(e.to_i64(), 2);
    // Check it's in the right range
    let low = FixedPoint::from_decimal(271, 2).raw();
    let high = FixedPoint::from_decimal(272, 2).raw();
    assert!(e.raw() >= low && e.raw() <= high, "exp(1) should be ~2.718");
}

// ========================================================================
// V8-03 HIGH (FIXED): CompositeProof::compose accepts unbounded inner_proofs
// ========================================================================
//
// Before the fix, CompositeProof::compose had no cap on inner_proofs.len().
// An attacker could create a CompositeProof with millions of inner proofs,
// causing compute_composition_hash to serialize and hash each one. This is
// a DoS vector: O(N) serialization + O(N) hashing for N inner proofs.
//
// FIX: compose() and verify_composition() now reject > 1024 inner proofs.

#[test]
fn fix_v8_03a_reasonable_inner_count_accepted() {
    let outer = VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    };
    let inners: Vec<VerifiedProof> = (0..10)
        .map(|i| VerifiedProof::Mock {
            input_hash: [i as u8; 32],
            output_hash: [(i + 1) as u8; 32],
            privacy_mode: PrivacyMode::Transparent,
        })
        .collect();
    let composite = CompositeProof::compose(outer, inners);
    assert_eq!(composite.proof_count(), 11);
    assert!(composite.verify_composition());
}

#[test]
#[should_panic(expected = "inner_proofs count")]
fn fix_v8_03b_excessive_inner_count_panics() {
    let outer = VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    };
    // Create 1025 inner proofs (exceeds MAX_INNER_PROOFS = 1024)
    let inners: Vec<VerifiedProof> = (0..1025)
        .map(|i| VerifiedProof::Mock {
            input_hash: [(i % 256) as u8; 32],
            output_hash: [((i + 1) % 256) as u8; 32],
            privacy_mode: PrivacyMode::Transparent,
        })
        .collect();
    // This should panic
    let _ = CompositeProof::compose(outer, inners);
}

#[test]
fn fix_v8_03c_boundary_1024_accepted() {
    let outer = VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    };
    // Exactly 1024 should be accepted
    let inners: Vec<VerifiedProof> = (0..1024)
        .map(|i| VerifiedProof::Mock {
            input_hash: [(i % 256) as u8; 32],
            output_hash: [((i + 1) % 256) as u8; 32],
            privacy_mode: PrivacyMode::Transparent,
        })
        .collect();
    let composite = CompositeProof::compose(outer, inners);
    assert_eq!(composite.proof_count(), 1025);
    assert!(composite.verify_composition());
}

// ========================================================================
// V8-04 MEDIUM: FixedPoint::to_i64 silently wraps on overflow
// ========================================================================
//
// to_i64 uses `(self.raw / SCALE) as i64` which wraps when the integer
// part exceeds i64::MAX. For example, a FixedPoint with raw = i128::MAX
// has int_part = i128::MAX / SCALE ~= 2^79, which wraps to a negative
// i64 via the `as` cast.
//
// FIX: Added to_i64_saturating() that clamps at i64::MIN/MAX.

#[test]
fn attack_v8_04a_to_i64_wraps_silently() {
    // FixedPoint with raw = i128::MAX
    let huge = FixedPoint::from_raw(i128::MAX);
    let int_part = huge.raw() / FixedPoint::SCALE;
    assert!(int_part > i64::MAX as i128, "int_part should exceed i64::MAX");

    // to_i64 wraps silently
    let wrapped = huge.to_i64();
    // The wrapped value is implementation-defined but will be negative
    // because the high bits overflow into the sign bit
    assert!(
        wrapped < 0 || wrapped == -1, // implementation-defined wrapping
        "to_i64 on huge value wraps silently (got {})",
        wrapped
    );
}

#[test]
fn fix_v8_04b_to_i64_saturating_clamps() {
    let huge = FixedPoint::from_raw(i128::MAX);
    let saturated = huge.to_i64_saturating();
    assert_eq!(
        saturated,
        i64::MAX,
        "to_i64_saturating should clamp at i64::MAX"
    );

    let very_negative = FixedPoint::from_raw(i128::MIN);
    let saturated_neg = very_negative.to_i64_saturating();
    assert_eq!(
        saturated_neg,
        i64::MIN,
        "to_i64_saturating should clamp at i64::MIN"
    );
}

#[test]
fn fix_v8_04c_to_i64_saturating_normal_values() {
    // Normal values should be unaffected
    let normal = FixedPoint::from_int(42);
    assert_eq!(normal.to_i64_saturating(), 42);

    let neg = FixedPoint::from_int(-100);
    assert_eq!(neg.to_i64_saturating(), -100);

    let zero = FixedPoint::ZERO;
    assert_eq!(zero.to_i64_saturating(), 0);

    // i64::MAX should work
    let max = FixedPoint::from_int(i64::MAX);
    assert_eq!(max.to_i64_saturating(), i64::MAX);

    // i64::MIN should work
    let min = FixedPoint::from_int(i64::MIN);
    assert_eq!(min.to_i64_saturating(), i64::MIN);
}

// ========================================================================
// V8-05 MEDIUM: verify_disclosure does not reject ZERO_HASH output binding
// ========================================================================
//
// If a HashIvc proof has output_hash = ZERO_HASH (which happens in
// Private mode when output is hidden), and the disclosure has
// output_binding = ZERO_HASH (from tokens_hash of an empty token list,
// which is actually the empty SHA-256), the binding check passes
// vacuously. However, this is mitigated by the 0-token check (V6-07).
//
// The deeper concern: tokens_hash([]) != ZERO_HASH (SHA-256 of empty
// input is e3b0c4..., not all zeros). So this is not directly exploitable.
// We test to confirm the mitigation holds.

#[test]
fn attack_v8_05a_zero_output_hash_not_exploitable() {
    // tokens_hash of empty slice is SHA-256("") = e3b0c4..., not ZERO_HASH
    let empty_hash = tokens_hash(&[]);
    assert_ne!(
        empty_hash, ZERO_HASH,
        "tokens_hash([]) should NOT be ZERO_HASH"
    );
}

#[test]
fn attack_v8_05b_disclosure_with_crafted_zero_binding_rejected() {
    // Craft a disclosure where output_binding = ZERO_HASH
    let tokens = vec![100, 200];
    let verified = make_verified(tokens);
    let mut disclosure = create_disclosure(&verified, &[0]).unwrap();

    // Tamper: set output_binding to ZERO_HASH
    disclosure.output_binding = ZERO_HASH;

    // This should fail because the proof's output_hash != ZERO_HASH
    assert!(
        !verify_disclosure(&disclosure),
        "Disclosure with zeroed output_binding should fail"
    );
}

// ========================================================================
// V8-06 MEDIUM: Single-leaf Merkle proof has zero siblings
// ========================================================================
//
// When a Merkle tree has exactly 1 leaf, the root equals the leaf hash,
// and the proof has 0 siblings. verify_proof just checks leaf == root,
// which is trivially satisfiable if the attacker knows the leaf hash.
//
// In the disclosure context, the leaf hash is hash_leaf(token_id bytes),
// so an attacker who knows the token value can construct a valid proof.
// This is not a vulnerability per se (knowing the token is equivalent to
// knowing the output), but it means single-token proofs have no Merkle
// security margin.

#[test]
fn attack_v8_06a_single_leaf_trivial_proof() {
    let leaf = hash_data(&[42]);
    let tree = MerkleTree::build(&[leaf]);
    assert_eq!(tree.root, leaf, "Single-leaf tree: root == leaf");

    let proof = tree.generate_proof(0, &ZERO_HASH).unwrap();
    assert_eq!(proof.siblings.len(), 0, "Single-leaf proof has 0 siblings");
    assert!(verify_proof(&proof));

    // An attacker who knows the leaf can forge this proof trivially
    let forged = MerkleProof {
        leaf,
        leaf_index: 0,
        siblings: vec![],
        root: leaf, // root == leaf for single-leaf tree
        code_hash: ZERO_HASH,
    };
    assert!(
        verify_proof(&forged),
        "Forged single-leaf proof verifies (known limitation)"
    );
}

#[test]
fn attack_v8_06b_single_token_disclosure_still_verified() {
    // Despite the trivial proof, the full disclosure verification still
    // checks output_binding against the execution proof, which provides
    // the actual security.
    let verified = make_verified(vec![42]);
    let disclosure = create_disclosure(&verified, &[0]).unwrap();
    assert!(verify_disclosure(&disclosure));

    // Tampering with the token value still fails
    let mut tampered = disclosure.clone();
    tampered.tokens[0] = DisclosedToken::Revealed {
        index: 0,
        token_id: 999,
    };
    assert!(
        !verify_disclosure(&tampered),
        "Tampered single-token disclosure should fail"
    );
}

// ========================================================================
// V8-07 MEDIUM: Full-reveal disclosure leaks complete plaintext + structure
// ========================================================================
//
// When all tokens are revealed, the disclosure contains the complete
// plaintext AND all Merkle proofs. This is by design (the user chose to
// reveal everything), but we verify that a verifier cannot use this
// information to forge disclosures for different token subsets.

#[test]
fn attack_v8_07a_full_reveal_cannot_forge_partial() {
    let tokens = vec![10, 20, 30, 40];
    let verified = make_verified(tokens.clone());

    // Full reveal
    let full = create_disclosure(&verified, &[0, 1, 2, 3]).unwrap();
    assert!(verify_disclosure(&full));

    // Attacker tries to convert full disclosure into partial disclosure
    // by removing some revealed tokens and replacing with redacted
    let mut partial = full.clone();
    partial.tokens[2] = DisclosedToken::Redacted {
        index: 2,
        leaf_hash: token_leaf(30), // uses correct leaf hash from full reveal
    };
    partial.tokens[3] = DisclosedToken::Redacted {
        index: 3,
        leaf_hash: token_leaf(40),
    };
    // Remove proofs for positions 2 and 3
    partial.proofs = vec![full.proofs[0].clone(), full.proofs[1].clone()];

    // This should PASS because the attacker used correct leaf hashes.
    // This is acceptable: the attacker already had the full plaintext.
    // The point of disclosure is to control what the VERIFIER sees,
    // not to prevent someone with full access from creating subsets.
    let result = verify_disclosure(&partial);
    assert!(
        result,
        "Full-reveal to partial conversion with correct leaves should work"
    );
}

// ========================================================================
// V8-08 MEDIUM: CompositeProof serde roundtrip bypasses compose() guard
// ========================================================================
//
// CompositeProof derives Serialize + Deserialize. An attacker can
// deserialize a CompositeProof with > MAX_INNER_PROOFS inner proofs,
// bypassing the compose() constructor's assert. However, the
// verify_composition() check also enforces the cap (V8-03 fix).

#[test]
fn attack_v8_08a_serde_roundtrip_works_for_valid() {
    let outer = VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    };
    let inner = VerifiedProof::Mock {
        input_hash: [0x01; 32],
        output_hash: [0x02; 32],
        privacy_mode: PrivacyMode::Transparent,
    };
    let composite = CompositeProof::compose(outer, vec![inner]);
    assert!(composite.verify_composition());

    // Serialize and deserialize
    let json = serde_json::to_string(&composite).unwrap();
    let deserialized: CompositeProof = serde_json::from_str(&json).unwrap();
    assert!(
        deserialized.verify_composition(),
        "Deserialized composite should still verify"
    );
}

#[test]
fn attack_v8_08b_deserialized_oversized_rejected_by_verify() {
    // Create a valid composite, serialize it, then manually inject extra
    // inner proofs into the JSON and deserialize.
    let outer = VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    };
    let composite = CompositeProof::compose(outer, vec![]);

    let mut json_value: serde_json::Value =
        serde_json::from_str(&serde_json::to_string(&composite).unwrap()).unwrap();

    // Inject 1025 inner proofs
    let zeros_32: Vec<u8> = vec![0u8; 32];
    let mock_proof_json = serde_json::json!({
        "Mock": {
            "input_hash": zeros_32,
            "output_hash": zeros_32,
            "privacy_mode": "Transparent"
        }
    });
    let inners: Vec<serde_json::Value> = (0..1025).map(|_| mock_proof_json.clone()).collect();
    json_value["inner_proofs"] = serde_json::Value::Array(inners);

    // Deserialize -- this bypasses the compose() constructor
    let oversized: CompositeProof = serde_json::from_value(json_value).unwrap();
    assert_eq!(oversized.inner_proofs.len(), 1025);

    // But verify_composition should reject it
    assert!(
        !oversized.verify_composition(),
        "Deserialized oversized CompositeProof should be rejected by verify"
    );
}

// ========================================================================
// V8-09 MEDIUM: exp_approx with large negative input diverges
// ========================================================================
//
// Taylor series for e^x converges slowly for |x| >> 1, especially for
// negative x where alternating signs cause catastrophic cancellation.
// With a fixed number of terms, exp(-50, 20) can produce a very wrong
// result (potentially wrong sign or orders of magnitude off).

#[test]
fn attack_v8_09a_exp_large_negative_diverges() {
    // e^(-10) ~= 0.0000454
    let neg10 = FixedPoint::from_int(-10);
    let result = neg10.exp_approx(20);
    // With only 20 terms, the Taylor series for e^(-10) hasn't converged.
    // The result might be negative (wrong sign!) due to partial sums
    // oscillating wildly for |x| > ~5.
    let raw = result.raw();
    // Document the divergence: the result is not reliable for |x| >> 1
    // A verified computation using exp_approx on large inputs with few
    // terms would produce a "proven correct" but mathematically wrong result.
    if raw < 0 {
        // Wrong sign -- the series hasn't converged
        // This is expected behavior for insufficient terms, but dangerous
        // in a verified computation context.
    }
    // The key issue: there's no warning or error when terms are insufficient.
    // The function always returns a result, even if it's garbage.
}

#[test]
fn attack_v8_09b_exp_small_values_converge() {
    // e^(0.5) ~= 1.6487 -- should converge well with 20 terms
    let half = FixedPoint::from_decimal(50, 2);
    let result = half.exp_approx(20);
    assert!(result.raw() > FixedPoint::ONE.raw(), "e^0.5 > 1");
    assert!(result.to_i64() == 1, "integer part of e^0.5 is 1");
}

// ========================================================================
// V8-10 LOW: CodeAttestation sign_message doesn't include public key
// ========================================================================
//
// CodeAttestation::sign_message() constructs the signed message as:
//   node_id || code_hash || circuit_id
// But does NOT include the signer's public key. This means if two different
// nodes have the same node_id (which is supposed to be SHA-256 of their
// pubkey), they would sign the same message.
//
// In practice this is mitigated because node_id = SHA-256(pubkey), so
// two different pubkeys almost certainly produce different node_ids.
// But it's a defense-in-depth concern.

#[test]
fn attack_v8_10a_attestation_message_does_not_include_pubkey() {
    let attest1 = CodeAttestation {
        node_id: [0xAA; 32],
        code_hash: [0xBB; 32],
        circuit_id: 42,
        signature: [0x00; 64],
    };
    let attest2 = CodeAttestation {
        node_id: [0xAA; 32], // same node_id
        code_hash: [0xBB; 32],
        circuit_id: 42,
        signature: [0xFF; 64], // different signature (different key)
    };

    // Both produce the same sign_message because signature isn't included
    assert_eq!(
        attest1.sign_message(),
        attest2.sign_message(),
        "Different signatures produce the same sign_message (pubkey not in message)"
    );
}

// ========================================================================
// V8-11 LOW: VerifiedResponse Private mode doesn't enforce empty value_bytes
// ========================================================================
//
// In Private mode, VerifiedResponse::new() zeroes value_bytes. But when
// receiving a VerifiedResponse via from_bytes, if the sender claims
// Private mode but includes value_bytes, verify_value_integrity() returns
// true unconditionally (Private mode short-circuits).
//
// This means a malicious sender can include arbitrary data in value_bytes
// while claiming Private mode, and the receiver's integrity check passes.

#[test]
fn attack_v8_11a_private_mode_with_value_bytes_accepted() {
    let proof = VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Private,
    };
    let response = VerifiedResponse::new(&proof, ZERO_HASH, b"secret".to_vec(), ZERO_HASH);

    // new() correctly strips value_bytes in Private mode
    assert!(response.value_bytes.is_empty());

    let bytes = response.to_bytes();
    let decoded = VerifiedResponse::from_bytes(&bytes).unwrap();
    assert!(decoded.value_bytes.is_empty());
    assert!(decoded.verify_value_integrity());

    // But what if we manually craft bytes with Private mode + non-empty value?
    let mut tampered = bytes.clone();
    // Append extra value bytes after the verifier_key_hash
    tampered.extend_from_slice(b"covert_channel_data");

    let decoded_tampered = VerifiedResponse::from_bytes(&tampered).unwrap();
    assert_eq!(decoded_tampered.privacy_mode, PrivacyMode::Private);
    assert!(
        !decoded_tampered.value_bytes.is_empty(),
        "Private mode response has non-empty value_bytes (from wire)"
    );

    // verify_value_integrity STILL returns true because Private short-circuits
    assert!(
        decoded_tampered.verify_value_integrity(),
        "Private mode always passes integrity check (even with covert data)"
    );
}

// ========================================================================
// V8-12 LOW: HashIvc accumulator has pub input_hash/output_hash fields
// ========================================================================
//
// HashIvcAccumulator has `pub input_hash: Hash` and `pub output_hash: Hash`.
// This means anyone with access to the accumulator can set arbitrary I/O
// hashes before calling finalize(), making the proof claim any input/output.
//
// This is by design (the caller sets I/O hashes), but it means the
// security boundary is at the finalize() call, not the fold_step() calls.

#[test]
fn attack_v8_12a_accumulator_io_hashes_settable() {
    let ivc = HashIvc;
    let code_hash = hash_data(b"test");
    let mut acc = ivc.init(&code_hash, PrivacyMode::Transparent);

    let witness = StepWitness {
        state_before: hash_data(b"real_before"),
        state_after: hash_data(b"real_after"),
        step_inputs: hash_data(b"real_inputs"),
    };
    ivc.fold_step(&mut acc, &witness).unwrap();

    // Set arbitrary I/O hashes -- this is allowed because the fields are pub
    acc.input_hash = hash_data(b"fake_input");
    acc.output_hash = hash_data(b"fake_output");
    let proof = ivc.finalize(acc).unwrap();

    // The proof now claims fake I/O, and it verifies!
    assert!(
        ivc.verify(&proof, &hash_data(b"fake_input"), &hash_data(b"fake_output"))
            .unwrap(),
        "Proof with arbitrary I/O hashes verifies (pub field access)"
    );

    // But it won't verify with the real I/O
    assert!(
        !ivc.verify(&proof, &hash_data(b"real_before"), &hash_data(b"real_after"))
            .unwrap(),
    );
}

// ========================================================================
// Additional: FixedPoint arithmetic chain with sign changes
// ========================================================================

#[test]
fn r8_fixed_point_sign_transitions() {
    // Test arithmetic crossing zero boundary
    let small_pos = FixedPoint::from_decimal(1, 3); // 0.001
    let small_neg = FixedPoint::from_decimal(-1, 3); // -0.001

    let result = small_pos + small_neg;
    assert_eq!(result.raw(), 0, "0.001 + (-0.001) should be exactly 0");

    let display = format!("{}", result);
    assert_eq!(display, "0", "Zero should display as '0'");
}

// ========================================================================
// Additional: Disclosure with duplicate token values
// ========================================================================

#[test]
fn r8_disclosure_duplicate_token_values() {
    // All tokens are the same value -- each has a unique position but same leaf hash
    let tokens = vec![42, 42, 42, 42];
    let verified = make_verified(tokens.clone());
    let disclosure = create_disclosure(&verified, &[0, 2]).unwrap();
    assert!(verify_disclosure(&disclosure));

    // Despite all tokens being 42, the Merkle proofs are position-specific
    assert_eq!(disclosure.proofs[0].leaf_index, 0);
    assert_eq!(disclosure.proofs[1].leaf_index, 2);
}

// ========================================================================
// Additional: IVC verify rejects proof with swapped input/output hashes
// ========================================================================

#[test]
fn r8_ivc_swapped_io_hashes_rejected() {
    let ivc = HashIvc;
    let code_hash = hash_data(b"io_test");
    let mut acc = ivc.init(&code_hash, PrivacyMode::Transparent);

    let witness = StepWitness {
        state_before: hash_data(b"before"),
        state_after: hash_data(b"after"),
        step_inputs: hash_data(b"inputs"),
    };
    ivc.fold_step(&mut acc, &witness).unwrap();

    let input_hash = hash_data(b"specific_input");
    let output_hash = hash_data(b"specific_output");
    acc.input_hash = input_hash;
    acc.output_hash = output_hash;
    let proof = ivc.finalize(acc).unwrap();

    // Correct order passes
    assert!(ivc.verify(&proof, &input_hash, &output_hash).unwrap());

    // Swapped order fails (input/output are not interchangeable)
    assert!(
        !ivc.verify(&proof, &output_hash, &input_hash).unwrap(),
        "Swapped I/O hashes should be rejected"
    );
}

// ========================================================================
// Additional: CompositeProof with mixed HashIvc and Mock proofs
// ========================================================================

#[test]
fn r8_composite_mixed_proof_types() {
    let outer = make_multistep_proof(3);
    let inner_mock = VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    };
    let inner_hash = make_multistep_proof(2);

    let composite = CompositeProof::compose(outer, vec![inner_mock, inner_hash]);
    assert_eq!(composite.proof_count(), 3);
    assert!(composite.verify_composition());
}

// ========================================================================
// Additional: FixedPoint division by very small values
// ========================================================================

#[test]
fn r8_fixed_point_div_small_denominator() {
    // Division by a very small positive value should saturate, not panic
    let big = FixedPoint::from_int(1000);
    let tiny = FixedPoint::from_raw(1); // smallest possible positive value
    let result = big / tiny;
    // 1000 * SCALE / 1 may overflow -- should saturate
    assert!(result.raw() > 0, "Division result should be positive");
}

// ========================================================================
// Additional: Merkle proof with wrong code_hash still verifies
// ========================================================================

#[test]
fn r8_merkle_proof_code_hash_not_checked_by_verify() {
    // verify_proof only checks the Merkle path, not the code_hash field.
    // code_hash is metadata stored alongside the proof but not part of
    // the Merkle verification itself.
    let leaves: Vec<Hash> = (0..4u8).map(|i| hash_data(&[i])).collect();
    let tree = MerkleTree::build(&leaves);
    let mut proof = tree.generate_proof(2, &hash_data(b"real_code")).unwrap();

    // Tamper with code_hash
    proof.code_hash = [0xFF; 32];

    // verify_proof only checks the Merkle path (leaf -> siblings -> root)
    // code_hash is NOT part of this computation
    assert!(
        verify_proof(&proof),
        "verify_proof does not check code_hash (it's metadata)"
    );
}

// ========================================================================
// Additional: Disclosure verification with PrivateInputs mode
// ========================================================================

#[test]
fn r8_disclosure_private_inputs_mode_verified() {
    let tokens = vec![10, 20, 30, 40];
    let ivc = HashIvc;
    let code_hash = [0x03; 32];
    let mut acc = ivc.init(&code_hash, PrivacyMode::PrivateInputs);
    let witness = StepWitness {
        state_before: hash_data(b"before"),
        state_after: hash_data(b"after"),
        step_inputs: hash_data(b"inputs"),
    };
    ivc.fold_step(&mut acc, &witness).unwrap();
    acc.input_hash = ZERO_HASH;
    acc.output_hash = disclosure_output_hash(&tokens);
    let proof = ivc.finalize(acc).unwrap();

    let verified = Verified::__macro_new(tokens, proof);
    let disclosure = create_disclosure(&verified, &[0, 2]).unwrap();

    // PrivateInputs disclosure should verify (output_hash is checked)
    assert!(verify_disclosure(&disclosure));
}

// ========================================================================
// Additional: FixedPoint from_decimal with value=0
// ========================================================================

#[test]
fn r8_fixed_point_from_decimal_zero() {
    let zero = FixedPoint::from_decimal(0, 0);
    assert_eq!(zero.raw(), 0);

    let also_zero = FixedPoint::from_decimal(0, 10);
    assert_eq!(also_zero.raw(), 0);

    let still_zero = FixedPoint::from_decimal(0, 37);
    assert_eq!(still_zero.raw(), 0);
}

// ========================================================================
// Additional: Verified type cannot be cloned to create duplicate proofs
// ========================================================================

#[test]
fn r8_verified_clone_preserves_proof() {
    let tokens = sample_tokens();
    let verified = make_verified(tokens.clone());

    // Clone should produce an identical copy
    let cloned = verified.clone();
    assert_eq!(verified.value(), cloned.value());

    // Both should create valid disclosures
    let d1 = create_disclosure(&verified, &[0]).unwrap();
    let d2 = create_disclosure(&cloned, &[0]).unwrap();
    assert!(verify_disclosure(&d1));
    assert!(verify_disclosure(&d2));
    assert_eq!(d1.output_root, d2.output_root);
}

// ========================================================================
// Additional: SignedCommitment with tampered commitment bytes
// ========================================================================

#[test]
fn r8_signed_commitment_tamper_detected() {
    use ed25519_dalek::SigningKey;
    use poly_verified::crypto::commitment::{
        create_commitment, sign_commitment, verify_signed_commitment,
    };

    let checkpoints: Vec<Hash> = (0..4u8).map(|i| hash_data(&[i])).collect();
    let code_hash = hash_data(b"test_code");
    let (commitment, _) = create_commitment(&checkpoints, &code_hash);

    let signing_key = SigningKey::from_bytes(&[0x42; 32]);
    let signed = sign_commitment(&commitment, &signing_key);

    // Valid signed commitment verifies
    assert!(verify_signed_commitment(&signed).is_ok());

    // Tamper with commitment bytes and re-encode
    let mut bytes = signed.to_bytes().to_vec();
    bytes[0] ^= 0xFF; // flip a bit in the root

    let tampered = poly_verified::types::SignedCommitment::from_bytes(&bytes).unwrap();
    assert!(
        verify_signed_commitment(&tampered).is_err(),
        "Tampered commitment should fail signature verification"
    );
}

// ========================================================================
// Additional: FixedPoint checked_mul boundary
// ========================================================================

#[test]
fn r8_fixed_point_checked_mul_boundary() {
    // checked_mul of two values that just barely overflow
    let a = FixedPoint::from_raw(i128::MAX / FixedPoint::SCALE + 1);
    let b = FixedPoint::from_raw(FixedPoint::SCALE + 1); // slightly > 1.0
    // a * b: a.raw * b.raw may overflow i128
    let result = a.checked_mul(b);
    // Either it returns None (overflow) or a valid result
    // The key is it doesn't panic
    if let Some(r) = result {
        assert!(r.raw() > 0 || r.raw() < 0, "Some result is fine");
    }
    // No panic = success
}

// ========================================================================
// Additional: Hash chain with all-zero checkpoints
// ========================================================================

#[test]
fn r8_hash_chain_all_zero_checkpoints() {
    use poly_verified::crypto::chain::HashChain;

    let mut chain = HashChain::new();
    // Append ZERO_HASH multiple times
    for _ in 0..5 {
        chain.append(&ZERO_HASH);
    }

    // Despite all inputs being zero, each step should produce a different tip
    // because hash_chain_step uses domain separation
    let mut chain2 = HashChain::new();
    for _ in 0..4 {
        chain2.append(&ZERO_HASH);
    }

    assert_ne!(
        chain.tip, chain2.tip,
        "5 zero appends should differ from 4 zero appends"
    );
    assert_eq!(chain.length, 5);
    assert_eq!(chain2.length, 4);
}

// ========================================================================
// Additional: IVC proof with maximum realistic step count
// ========================================================================

#[test]
fn r8_ivc_high_step_count() {
    let ivc = HashIvc;
    let code_hash = hash_data(b"high_step");
    let mut acc = ivc.init(&code_hash, PrivacyMode::Transparent);

    // 100 steps -- realistic for a complex computation
    for i in 0..100u8 {
        let witness = StepWitness {
            state_before: hash_data(&[i]),
            state_after: hash_data(&[i.wrapping_add(1)]),
            step_inputs: hash_data(&[i, i]),
        };
        ivc.fold_step(&mut acc, &witness).unwrap();
    }

    let proof = ivc.finalize(acc).unwrap();
    assert!(ivc.verify(&proof, &ZERO_HASH, &ZERO_HASH).unwrap());

    match &proof {
        VerifiedProof::HashIvc {
            step_count,
            checkpoints,
            ..
        } => {
            assert_eq!(*step_count, 100);
            assert_eq!(checkpoints.len(), 100);
        }
        _ => panic!("Expected HashIvc"),
    }
}
