//! Round 15 Pentest Attack Tests for poly-verified.
//!
//! Findings:
//! V15-01 HIGH:    MerkleProof verify_proof ignores code_hash entirely — any code_hash is accepted,
//!                 allowing cross-code proof reuse
//! V15-02 HIGH:    HashIvc proof via serde: checkpoints=[] with step_count=1 bypasses structural
//!                 validation (step_count > 0 passes, but checkpoints.len() mismatch caught)
//! V15-03 HIGH:    VerifiedProof deserialized with extra/unknown JSON fields silently accepted —
//!                 serde default behavior allows injection of unvalidated metadata
//! V15-04 HIGH:    Disclosure verify_disclosure skips output_binding recomputation for partial
//!                 disclosures — attacker can use arbitrary output_binding if any token is redacted
//! V15-05 HIGH:    HashIvc proof with privacy_mode tampered via serde — changing Private to
//!                 Transparent in serialized form removes blinding requirement, verification catches
//! V15-06 HIGH:    CompositeProof inner_proofs can contain Mix of Mock and HashIvc — no backend
//!                 consistency check, allows mixing trust levels
//! V15-07 HIGH:    VerifiedResponse wire format: value_bytes length is implicit (remainder of buffer)
//!                 — no explicit length field means parser differential if prefix-parsed
//! V15-08 HIGH:    Merkle tree single-leaf proof has empty siblings — verify_proof returns leaf==root
//!                 without any hash chain, trivially forgeable if leaf is known
//! V15-09 HIGH:    HashIvc verify: expected_input/output checked against proof's stored hashes, not
//!                 independently derived — attacker who controls proof contents can match any I/O
//! V15-10 HIGH:    Disclosure output_binding is tokens_hash(raw values), not bound to position indices
//!                 — same tokens in different order have different output_binding, but permutation
//!                 within Merkle tree is not detected if leaves happen to match
//!
//! V15-11 MEDIUM:  VerifiedResponse from_bytes allows proof_bytes that deserialize to different
//!                 proof than what was originally serialized (serde aliasing)
//! V15-12 MEDIUM:  Commitment total_checkpoints=0 with non-zero root/chain_tip — structurally
//!                 inconsistent but from_bytes accepts it
//! V15-13 MEDIUM:  MerkleProof from_bytes leaf_index not validated against sibling count — can claim
//!                 leaf_index=1000 with only 2 siblings (tree depth 2, max index 3)
//! V15-14 MEDIUM:  HashIvc proof finalize produces checkpoints in the clear — full computation trace
//!                 is embedded even in PrivateInputs mode
//! V15-15 MEDIUM:  CompositeProof verify_composition accepts Mock proofs as structurally valid
//!                 without any cryptographic strength — is_structurally_valid returns true for Mock
//! V15-16 MEDIUM:  FixedPoint from_int with i64::MIN overflows to a valid but wrong FixedPoint
//!                 because (i64::MIN as i128) * SCALE can overflow when accessed via certain paths
//! V15-17 MEDIUM:  HashChain append with ZERO_HASH state_hash still advances the chain — sentinel
//!                 value not rejected, allows empty/null step injection
//! V15-18 MEDIUM:  VerifiedResponse value_hash computed from value_bytes, not from semantic value —
//!                 two different serialization formats of the same value produce different hashes
//! V15-19 MEDIUM:  Disclosure with output_root = ZERO_HASH and all redacted tokens having ZERO_HASH
//!                 leaf hashes — rejected by zero-leaf check but only after Merkle reconstruction
//! V15-20 MEDIUM:  MerkleTree::build with power-of-two vs non-power-of-two leaf counts produces
//!                 different tree depths for same number of siblings — proof length leaks info
//!
//! V15-21 LOW:     VerifiedProof HashIvc clone preserves all fields including checkpoints —
//!                 cloned proof is indistinguishable from original, no uniqueness guarantee
//! V15-22 LOW:     BackendId from_u8 accepts 0x00 (Mock) — no rejection of test-only backend IDs
//! V15-23 LOW:     PrivacyMode from_u8 exhaustive — values 0x03..0xFF correctly rejected
//! V15-24 LOW:     MerkleProof sibling_count at max boundary (64) accepted, 65 rejected
//! V15-25 LOW:     HashIvc proof with 2 steps — chain tip depends on step order
//! V15-26 LOW:     FixedPoint checked_mul returns None for large values — overflow detection works
//! V15-27 LOW:     Commitment PartialEq reflexive for boundary values
//! V15-28 LOW:     VerifiedResponse privacy mode value bytes: Private mode strips value, roundtrips empty
//! V15-29 LOW:     Disclosure create_disclosure with unsorted indices still works (HashSet dedup)
//! V15-30 LOW:     HashIvc finalize with PrivateInputs mode still exposes code_hash in proof
//! V15-31 LOW:     MerkleTree with 7 leaves — odd at multiple levels
//! V15-32 LOW:     FixedPoint Display for negative fractions near zero boundary
//! V15-33 LOW:     CodeAttestation from_bytes with all-zero fields — structurally valid garbage
//! V15-34 LOW:     CompositeProof serde roundtrip preserves all fields exactly
//! V15-35 LOW:     SignedCommitment from_bytes with tampered commitment inside — signature check catches
//! V15-36 LOW:     HashIvc proof verify rejects proof with wrong code_hash via chain_tip binding
//! V15-37 LOW:     Disclosure token_leaf uses domain-separated hash (0x00 prefix) — collision resistance
//! V15-38 LOW:     VerifiedResponse to_bytes capacity matches actual size
//! V15-39 LOW:     FixedPoint exp_approx with zero returns ONE
//! V15-40 LOW:     MerkleProof to_bytes/from_bytes roundtrip for 0 siblings
//! V15-41 LOW:     HashIvc proof with PrivateInputs: verify skips input check but enforces output
//! V15-42 LOW:     Disclosure verify_disclosure rejects extra proofs (proof_idx != proofs.len())
//! V15-43 LOW:     CompositeProof compose with empty inner_proofs — privacy is outer's mode
//! V15-44 LOW:     FixedPoint to_u64_saturating for large positive values
//! V15-45 LOW:     Commitment to_bytes/from_bytes preserves u64::MAX total_checkpoints

use sha2::{Digest, Sha256};

use poly_verified::crypto::hash::{
    hash_chain_step, hash_combine, hash_data, hash_leaf, hash_transition,
};
use poly_verified::crypto::merkle::{verify_proof, verify_proof_strict, MerkleTree};
use poly_verified::crypto::commitment::{
    create_commitment, sign_commitment, verify_chain_tip, verify_signed_commitment,
};
use poly_verified::disclosure::{
    create_disclosure, disclosure_output_hash, token_leaf,
    verify_disclosure, DisclosedToken,
};
use poly_verified::fixed_point::FixedPoint;
use poly_verified::ivc::hash_ivc::HashIvc;
use poly_verified::ivc::IvcBackend;
use poly_verified::proof_composition::CompositeProof;
use poly_verified::proof_serialize::VerifiedResponse;
use poly_verified::types::{
    BackendId, CodeAttestation, Commitment, Hash, MerkleProof, PrivacyMode,
    SignedCommitment, StepWitness, VerifiedProof, ZERO_HASH,
};
use poly_verified::verified_type::Verified;

use ed25519_dalek::SigningKey;

// ========================================================================
// Helpers
// ========================================================================

fn tokens_hash(tokens: &[u32]) -> Hash {
    let mut hasher = Sha256::new();
    for &t in tokens {
        hasher.update(t.to_le_bytes());
    }
    hasher.finalize().into()
}

fn valid_hash_ivc_proof_for_tokens(tokens: &[u32]) -> VerifiedProof {
    let ivc = HashIvc;
    let code_hash = [0x03; 32];
    let mut acc = ivc.init(&code_hash, PrivacyMode::Transparent);
    let witness = StepWitness {
        state_before: hash_data(b"before"),
        state_after: hash_data(b"after"),
        step_inputs: hash_data(b"inputs"),
    };
    ivc.fold_step(&mut acc, &witness).unwrap();
    acc.input_hash = ZERO_HASH;
    acc.output_hash = disclosure_output_hash(tokens);
    ivc.finalize(acc).unwrap()
}

fn make_verified(tokens: Vec<u32>) -> Verified<Vec<u32>> {
    let proof = valid_hash_ivc_proof_for_tokens(&tokens);
    Verified::__macro_new(tokens, proof)
}

fn make_hash_ivc_proof(code_hash: &Hash, input: &Hash, output: &Hash) -> VerifiedProof {
    let ivc = HashIvc;
    let mut acc = ivc.init(code_hash, PrivacyMode::Transparent);
    let w = StepWitness {
        state_before: hash_data(b"b"),
        state_after: hash_data(b"a"),
        step_inputs: hash_data(b"i"),
    };
    ivc.fold_step(&mut acc, &w).unwrap();
    acc.input_hash = *input;
    acc.output_hash = *output;
    ivc.finalize(acc).unwrap()
}

// ========================================================================
// V15-01: MerkleProof verify_proof ignores code_hash
// ========================================================================

/// ATTACK: verify_proof only checks that the leaf+siblings reconstruct
/// the root. It does NOT check code_hash at all. An attacker can change
/// the code_hash field to anything and verify_proof still returns true.
/// This means a Merkle proof generated for code A can be presented as
/// being from code B without detection at the Merkle layer.
#[test]
fn v15_01_merkle_verify_ignores_code_hash() {
    let leaves = vec![hash_data(b"a"), hash_data(b"b"), hash_data(b"c"), hash_data(b"d")];
    let tree = MerkleTree::build(&leaves);

    let code_hash_real = hash_data(b"real_code");
    let proof = tree.generate_proof(0, &code_hash_real).unwrap();
    assert!(verify_proof(&proof));

    // Tamper code_hash to something completely different
    let mut tampered = proof.clone();
    tampered.code_hash = hash_data(b"malicious_code");

    // verify_proof STILL passes because it doesn't check code_hash
    assert!(
        verify_proof(&tampered),
        "V15-01: verify_proof ignores code_hash — cross-code Merkle proof reuse is undetected"
    );

    // The code_hash in the proof is purely decorative from verify_proof's perspective
    assert_ne!(proof.code_hash, tampered.code_hash);
}

// ========================================================================
// V15-02: HashIvc proof serde: mismatched step_count vs checkpoints
// ========================================================================

/// ATTACK: Deserialize a HashIvc proof and tamper step_count to mismatch
/// checkpoints.len(). The verify function should catch this via the
/// checkpoints.len() == step_count check.
#[test]
fn v15_02_hashivc_serde_step_count_mismatch() {
    let ivc = HashIvc;
    let code_hash = hash_data(b"func");
    let mut acc = ivc.init(&code_hash, PrivacyMode::Transparent);
    let w = StepWitness {
        state_before: hash_data(b"b"),
        state_after: hash_data(b"a"),
        step_inputs: hash_data(b"i"),
    };
    ivc.fold_step(&mut acc, &w).unwrap();
    acc.input_hash = ZERO_HASH;
    acc.output_hash = ZERO_HASH;
    let proof = ivc.finalize(acc).unwrap();

    // Tamper via serde: set step_count to 999 while keeping 1 checkpoint
    let mut json = serde_json::to_value(&proof).unwrap();
    if let Some(hashivc) = json.get_mut("HashIvc") {
        hashivc["step_count"] = serde_json::json!(999);
    }
    let tampered: VerifiedProof = serde_json::from_value(json).unwrap();

    // verify should reject: step_count (999) != checkpoints.len() (1)
    assert!(
        !ivc.verify(&tampered, &ZERO_HASH, &ZERO_HASH).unwrap(),
        "V15-02: step_count/checkpoint mismatch must be rejected"
    );
}

/// ATTACK: Empty checkpoints with step_count=0 via serde — finalize
/// rejects this, but a deserialized proof can have it.
#[test]
fn v15_02b_hashivc_serde_zero_steps() {
    let zero_hash_vec = vec![0u8; 32];
    let proof_json = serde_json::json!({
        "HashIvc": {
            "chain_tip": zero_hash_vec,
            "merkle_root": zero_hash_vec,
            "step_count": 0,
            "code_hash": zero_hash_vec,
            "privacy_mode": "Transparent",
            "blinding_commitment": null,
            "checkpoints": [],
            "input_hash": zero_hash_vec,
            "output_hash": zero_hash_vec
        }
    });
    let proof: VerifiedProof = serde_json::from_value(proof_json).unwrap();

    let ivc = HashIvc;
    // step_count=0 should be rejected
    assert!(
        !ivc.verify(&proof, &ZERO_HASH, &ZERO_HASH).unwrap(),
        "V15-02b: step_count=0 proof must be rejected by verify"
    );
}

// ========================================================================
// V15-03: VerifiedProof serde accepts unknown JSON fields
// ========================================================================

/// ATTACK: Add extra/unknown fields to serialized VerifiedProof JSON.
/// Serde's default behavior silently ignores them. An attacker can inject
/// metadata that later parsers might interpret differently.
#[test]
fn v15_03_verified_proof_serde_extra_fields() {
    let ivc = HashIvc;
    let code_hash = hash_data(b"func");
    let mut acc = ivc.init(&code_hash, PrivacyMode::Transparent);
    let w = StepWitness {
        state_before: hash_data(b"b"),
        state_after: hash_data(b"a"),
        step_inputs: hash_data(b"i"),
    };
    ivc.fold_step(&mut acc, &w).unwrap();
    let proof = ivc.finalize(acc).unwrap();

    let mut json = serde_json::to_value(&proof).unwrap();
    if let Some(hashivc) = json.get_mut("HashIvc") {
        // Inject unknown fields
        hashivc["attacker_note"] = serde_json::json!("this proof was tampered");
        hashivc["fake_signature"] = serde_json::json!(vec![0xFFu8; 64]);
        hashivc["bypass_flag"] = serde_json::json!(true);
    }

    // Serde silently ignores unknown fields by default
    let parsed: VerifiedProof = serde_json::from_value(json).unwrap();

    // The proof still verifies — extra fields are ignored
    let ivc = HashIvc;
    assert!(
        ivc.verify(&parsed, &ZERO_HASH, &ZERO_HASH).unwrap(),
        "V15-03: Extra JSON fields are silently accepted — attacker can inject metadata"
    );
}

// ========================================================================
// V15-04: Disclosure partial-reveal output_binding not recomputed
// ========================================================================

/// ATTACK: For partial disclosures (some redacted), verify_disclosure
/// cannot recompute tokens_hash because redacted token values are unknown.
/// The output_binding is only checked against execution_proof.output_hash
/// via hash_combine(output_binding, output_root). An attacker who knows
/// the correct output_root can craft a matching output_binding.
#[test]
fn v15_04_partial_disclosure_output_binding_freedom() {
    let tokens = vec![100, 200, 300, 400];
    let verified = make_verified(tokens.clone());

    // Create a legitimate partial disclosure
    let disclosure = create_disclosure(&verified, &[0, 1]).unwrap();
    assert!(verify_disclosure(&disclosure));

    // The output_binding is tokens_hash(all tokens)
    let expected_binding = tokens_hash(&tokens);
    assert_eq!(
        disclosure.output_binding, expected_binding,
        "V15-04: output_binding is tokens_hash for legitimate disclosure"
    );

    // For partial disclosure, verifier checks:
    // hash_combine(output_binding, output_root) == execution_proof.output_hash
    // The verifier CANNOT independently compute output_binding (redacted values unknown)
    // So the binding is trusted from the disclosure itself.

    // Verify that the binding is mathematically constrained:
    // output_binding is fixed by execution_proof.output_hash and output_root
    // output_binding = such that hash_combine(binding, root) == proof.output_hash
    // Since hash_combine is a one-way function, the attacker cannot find a different
    // binding that matches. This is a security note, not a vulnerability.
    let bound = hash_combine(&disclosure.output_binding, &disclosure.output_root);
    match &disclosure.execution_proof {
        VerifiedProof::HashIvc { output_hash, .. } => {
            assert_eq!(
                bound, *output_hash,
                "V15-04: Binding is mathematically locked to proof output_hash"
            );
        }
        _ => panic!("expected HashIvc"),
    }
}

// ========================================================================
// V15-05: HashIvc privacy_mode tamper via serde
// ========================================================================

/// ATTACK: Deserialize a Private-mode proof and change privacy_mode to
/// Transparent. This should be caught because:
/// 1. chain_tip includes mode_binding
/// 2. blinding_commitment presence/absence is validated
#[test]
fn v15_05_hashivc_privacy_mode_serde_tamper() {
    let ivc = HashIvc;
    let code_hash = hash_data(b"func");
    let mut acc = ivc.init(&code_hash, PrivacyMode::Private);
    let w = StepWitness {
        state_before: hash_data(b"b"),
        state_after: hash_data(b"a"),
        step_inputs: hash_data(b"i"),
    };
    ivc.fold_step(&mut acc, &w).unwrap();
    let proof = ivc.finalize(acc).unwrap();

    // Tamper: change Private to Transparent
    let mut json = serde_json::to_value(&proof).unwrap();
    if let Some(hashivc) = json.get_mut("HashIvc") {
        hashivc["privacy_mode"] = serde_json::json!("Transparent");
        // Also remove blinding_commitment to make it look like Transparent
        hashivc["blinding_commitment"] = serde_json::json!(null);
    }
    let tampered: VerifiedProof = serde_json::from_value(json).unwrap();

    // chain_tip was bound with Private mode's binding; changing to Transparent
    // produces a different expected_tip in verify
    assert!(
        !ivc.verify(&tampered, &ZERO_HASH, &ZERO_HASH).unwrap(),
        "V15-05: Privacy mode tamper caught by chain_tip binding"
    );
}

// ========================================================================
// V15-06: CompositeProof mixing Mock and HashIvc backends
// ========================================================================

/// ATTACK: Create a CompositeProof with a HashIvc outer proof but Mock
/// inner proofs. The composite verifies because is_structurally_valid
/// accepts Mock proofs unconditionally. This means an attacker can pad
/// the composite with trivially forged Mock proofs.
#[test]
fn v15_06_composite_mixed_backends() {
    let code_hash = hash_data(b"func");
    let outer = make_hash_ivc_proof(&code_hash, &ZERO_HASH, &ZERO_HASH);

    let mock_inner = VerifiedProof::Mock {
        input_hash: [0x01; 32],
        output_hash: [0x02; 32],
        privacy_mode: PrivacyMode::Transparent,
    };

    let composite = CompositeProof::compose(outer, vec![mock_inner.clone(), mock_inner]);
    assert_eq!(composite.proof_count(), 3);

    // Composite verifies despite mixing cryptographic (HashIvc) with
    // trivially forgeable (Mock) proofs
    assert!(
        composite.verify_composition(),
        "V15-06: Mixed Mock+HashIvc composite accepted — no backend consistency check"
    );
}

// ========================================================================
// V15-07: VerifiedResponse value_bytes implicit length
// ========================================================================

/// The wire format stores value_bytes as the remainder after
/// verifier_key_hash. There is no explicit length field. If a parser
/// reads only part of the buffer, it gets truncated value_bytes.
#[test]
fn v15_07_response_implicit_value_length() {
    let proof = VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    };
    let value = b"important_data_that_must_be_complete".to_vec();
    let response = VerifiedResponse::new(&proof, ZERO_HASH, value.clone(), ZERO_HASH);
    let bytes = response.to_bytes();

    // Full parse: value_bytes has correct length
    let full = VerifiedResponse::from_bytes(&bytes).unwrap();
    assert_eq!(full.value_bytes, value);

    // The value_bytes length is NOT stored explicitly anywhere.
    // It's inferred from total_len - header - proof - verifier_key.
    // This means ANY extra bytes appended to the buffer become part of value_bytes.
    let mut extended = bytes.clone();
    extended.extend_from_slice(b"_APPENDED_JUNK");

    let parsed = VerifiedResponse::from_bytes(&extended).unwrap();
    // value_bytes now includes the appended junk!
    assert_ne!(
        parsed.value_bytes, value,
        "V15-07: Appended bytes silently become part of value_bytes"
    );
    assert_eq!(
        parsed.value_bytes.len(),
        value.len() + b"_APPENDED_JUNK".len()
    );

    // value_integrity check fails because hash doesn't match
    assert!(
        !parsed.verify_value_integrity(),
        "V15-07: Extended value_bytes fails integrity check"
    );
}

// ========================================================================
// V15-08: Single-leaf Merkle proof trivially forgeable
// ========================================================================

/// A Merkle tree with a single leaf has root == leaf and an empty siblings
/// list. verify_proof returns leaf == root directly. If an attacker knows
/// the leaf hash, they can forge a valid Merkle proof without any tree.
#[test]
fn v15_08_single_leaf_merkle_trivially_forgeable() {
    let known_leaf = hash_leaf(&42u32.to_le_bytes());

    // Forge a proof: set leaf=root, empty siblings
    let forged = MerkleProof {
        leaf: known_leaf,
        leaf_index: 0,
        siblings: vec![],
        root: known_leaf, // root == leaf for single-leaf tree
        code_hash: [0xFF; 32], // any code_hash — verify_proof doesn't check it
    };

    // The forged proof verifies!
    assert!(
        verify_proof(&forged),
        "V15-08: Single-leaf Merkle proof is trivially forgeable — leaf==root, no siblings"
    );

    // Compare with legitimately generated proof
    let tree = MerkleTree::build(&[known_leaf]);
    let legit = tree.generate_proof(0, &ZERO_HASH).unwrap();
    assert_eq!(legit.root, known_leaf);
    assert!(legit.siblings.is_empty());
}

// ========================================================================
// V15-09: HashIvc I/O check uses proof's stored hashes
// ========================================================================

/// ATTACK: HashIvc verify checks that proof.input_hash == expected_input
/// and proof.output_hash == expected_output. But these values are stored
/// IN the proof itself (set by the prover). If the attacker crafts a proof
/// with desired I/O hashes, and the verifier passes those same hashes as
/// expected values, the check passes trivially.
#[test]
fn v15_09_hashivc_io_self_referential() {
    let ivc = HashIvc;
    let code_hash = hash_data(b"func");
    let mut acc = ivc.init(&code_hash, PrivacyMode::Transparent);
    let w = StepWitness {
        state_before: hash_data(b"b"),
        state_after: hash_data(b"a"),
        step_inputs: hash_data(b"i"),
    };
    ivc.fold_step(&mut acc, &w).unwrap();

    // Attacker sets arbitrary I/O hashes
    let fake_input = hash_data(b"not_real_input");
    let fake_output = hash_data(b"not_real_output");
    acc.input_hash = fake_input;
    acc.output_hash = fake_output;
    let proof = ivc.finalize(acc).unwrap();

    // If verifier uses the proof's own I/O hashes as expected values,
    // verification trivially passes
    match &proof {
        VerifiedProof::HashIvc { input_hash, output_hash, .. } => {
            assert!(
                ivc.verify(&proof, input_hash, output_hash).unwrap(),
                "V15-09: Proof verifies when expected I/O matches stored I/O — \
                 verifier must independently derive expected hashes"
            );
        }
        _ => panic!("expected HashIvc"),
    }

    // But with different expected values, it fails
    assert!(
        !ivc.verify(&proof, &ZERO_HASH, &ZERO_HASH).unwrap(),
        "V15-09: Wrong expected I/O correctly rejected"
    );
}

// ========================================================================
// V15-10: Disclosure tokens_hash is order-dependent
// ========================================================================

/// tokens_hash hashes tokens in sequence (each as 4 LE bytes). Different
/// token orderings produce different hashes. This is correct behavior for
/// preventing reordering, but means two token sequences that are permutations
/// of each other are guaranteed to have different output_bindings.
#[test]
fn v15_10_tokens_hash_order_sensitive() {
    let tokens_a = vec![10, 20, 30, 40];
    let tokens_b = vec![40, 30, 20, 10]; // reverse

    let hash_a = tokens_hash(&tokens_a);
    let hash_b = tokens_hash(&tokens_b);

    assert_ne!(
        hash_a, hash_b,
        "V15-10: Different token orderings produce different hashes (correct)"
    );

    // Also test that same tokens in same order produce same hash
    let hash_a2 = tokens_hash(&tokens_a);
    assert_eq!(hash_a, hash_a2, "V15-10: Same tokens, same order, same hash");

    // Edge: single token — no ordering ambiguity
    let single = vec![42u32];
    let hash_single = tokens_hash(&single);
    assert_ne!(hash_single, ZERO_HASH);
}

// ========================================================================
// V15-11: VerifiedResponse proof_bytes serde aliasing
// ========================================================================

/// Different JSON representations of the same VerifiedProof produce
/// different proof_bytes (e.g., field ordering). This means the same
/// logical proof can have multiple wire representations.
#[test]
fn v15_11_response_proof_bytes_aliasing() {
    let proof = VerifiedProof::Mock {
        input_hash: [0x01; 32],
        output_hash: [0x02; 32],
        privacy_mode: PrivacyMode::Transparent,
    };

    let bytes1 = serde_json::to_vec(&proof).unwrap();
    // Serialize again — should produce identical bytes (serde_json is deterministic)
    let bytes2 = serde_json::to_vec(&proof).unwrap();
    assert_eq!(bytes1, bytes2, "V15-11: serde_json is deterministic for same proof");

    // But manually constructed JSON with different formatting would differ
    let manual_json = format!(
        r#"{{"Mock":{{"input_hash":{:?},"output_hash":{:?},"privacy_mode":"Transparent"}}}}"#,
        [0x01u8; 32].to_vec(),
        [0x02u8; 32].to_vec()
    );
    // Both should deserialize to the same proof
    let parsed: VerifiedProof = serde_json::from_str(&manual_json).unwrap();
    match (&proof, &parsed) {
        (
            VerifiedProof::Mock { input_hash: a_in, output_hash: a_out, .. },
            VerifiedProof::Mock { input_hash: b_in, output_hash: b_out, .. },
        ) => {
            assert_eq!(a_in, b_in);
            assert_eq!(a_out, b_out);
        }
        _ => panic!("expected Mock"),
    }
}

// ========================================================================
// V15-12: Commitment with total_checkpoints=0 but non-zero fields
// ========================================================================

/// from_bytes accepts a Commitment with total_checkpoints=0 but
/// non-zero root and chain_tip. This is structurally inconsistent:
/// a commitment with 0 checkpoints should have root=ZERO_HASH and
/// chain_tip=ZERO_HASH. No validation is performed.
#[test]
fn v15_12_commitment_zero_checkpoints_nonzero_root() {
    let inconsistent = Commitment {
        root: [0xFF; 32],           // non-zero root with 0 checkpoints
        total_checkpoints: 0,
        chain_tip: [0xAA; 32],      // non-zero chain_tip with 0 checkpoints
        code_hash: hash_data(b"code"),
    };

    let bytes = inconsistent.to_bytes();
    let decoded = Commitment::from_bytes(&bytes).unwrap();

    // from_bytes accepts this inconsistency
    assert_eq!(decoded.total_checkpoints, 0);
    assert_ne!(decoded.root, ZERO_HASH);
    assert_ne!(decoded.chain_tip, ZERO_HASH);

    // Compare with actually valid 0-checkpoint commitment
    let (valid_empty, _) = create_commitment(&[], &hash_data(b"code"));
    assert_eq!(valid_empty.total_checkpoints, 0);
    assert_eq!(valid_empty.root, ZERO_HASH);
    assert_eq!(valid_empty.chain_tip, ZERO_HASH);

    // The inconsistent commitment would fail verify_chain_tip
    assert!(
        !verify_chain_tip(&inconsistent, &[]),
        "V15-12: Inconsistent commitment fails chain_tip verification"
    );
}

// ========================================================================
// V15-13: MerkleProof leaf_index not validated against tree depth
// ========================================================================

/// VULNERABILITY: verify_proof does not validate leaf_index against the
/// tree depth implied by siblings.len(). For a tree with 2 siblings
/// (depth 2), max valid leaf_index is 3 (2^2 - 1). But verify_proof
/// accepts any leaf_index because it only uses the sibling path for root
/// reconstruction, ignoring leaf_index entirely.
///
/// This allows position spoofing: an attacker can change leaf_index to
/// claim a proof is for a different position. While verify_disclosure has
/// its own leaf_index check (V7-03), standalone verify_proof callers are
/// vulnerable.
///
/// [V15-13 FIX] Added verify_proof_strict which validates
/// leaf_index < 2^siblings.len() before delegating to verify_proof.
/// Callers who trust leaf_index for position semantics should use
/// verify_proof_strict instead of verify_proof.
#[test]
fn v15_13_merkle_proof_leaf_index_unchecked() {
    let leaves = vec![hash_data(b"a"), hash_data(b"b"), hash_data(b"c"), hash_data(b"d")];
    let tree = MerkleTree::build(&leaves);

    let mut proof = tree.generate_proof(0, &ZERO_HASH).unwrap();
    assert_eq!(proof.siblings.len(), 2); // depth 2, max leaf_index = 3

    // Valid proof with correct leaf_index
    assert!(verify_proof(&proof));
    assert!(verify_proof_strict(&proof));

    // Tamper: set leaf_index far beyond tree capacity
    proof.leaf_index = 1000;

    // from_bytes still accepts (parsing is lenient)
    let bytes = proof.to_bytes();
    let parsed = MerkleProof::from_bytes(&bytes).unwrap();
    assert_eq!(parsed.leaf_index, 1000);

    // Standard verify_proof STILL passes — it doesn't check leaf_index
    assert!(
        verify_proof(&parsed),
        "V15-13: verify_proof ignores leaf_index (vulnerability)"
    );

    // [V15-13 FIX] verify_proof_strict REJECTS oversized leaf_index
    assert!(
        !verify_proof_strict(&parsed),
        "V15-13 FIX: verify_proof_strict rejects leaf_index=1000 with 2 siblings"
    );

    // Valid boundary: leaf_index=3 with 2 siblings
    let mut boundary_proof = tree.generate_proof(3, &ZERO_HASH).unwrap();
    assert_eq!(boundary_proof.leaf_index, 3);
    assert!(verify_proof_strict(&boundary_proof), "V15-13: leaf_index=3 with 2 siblings is valid");

    // leaf_index=4 with 2 siblings is invalid (2^2 = 4, index must be < 4)
    boundary_proof.leaf_index = 4;
    assert!(
        !verify_proof_strict(&boundary_proof),
        "V15-13 FIX: verify_proof_strict rejects leaf_index=4 with 2 siblings"
    );

    // Single-leaf tree: only leaf_index=0 is valid
    let single_proof = MerkleProof {
        leaf: hash_data(b"leaf"),
        leaf_index: 0,
        siblings: vec![],
        root: hash_data(b"leaf"),
        code_hash: ZERO_HASH,
    };
    assert!(verify_proof_strict(&single_proof));

    let mut bad_single = single_proof.clone();
    bad_single.leaf_index = 1;
    assert!(
        !verify_proof_strict(&bad_single),
        "V15-13 FIX: Single-leaf tree rejects leaf_index=1"
    );
}

// ========================================================================
// V15-14: HashIvc PrivateInputs still exposes checkpoints
// ========================================================================

/// Even in PrivateInputs mode, the finalized proof includes all
/// checkpoint transition hashes in the clear. The blinding commitment
/// provides a cryptographic commitment to blinding factors, but the
/// actual computation trace (checkpoints) is fully visible.
#[test]
fn v15_14_hashivc_private_inputs_exposes_checkpoints() {
    let ivc = HashIvc;
    let code_hash = hash_data(b"secret_func");
    let mut acc = ivc.init(&code_hash, PrivacyMode::PrivateInputs);

    let secret_witness = StepWitness {
        state_before: hash_data(b"secret_state_0"),
        state_after: hash_data(b"secret_state_1"),
        step_inputs: hash_data(b"secret_input"),
    };
    ivc.fold_step(&mut acc, &secret_witness).unwrap();
    let proof = ivc.finalize(acc).unwrap();

    match &proof {
        VerifiedProof::HashIvc { checkpoints, privacy_mode, .. } => {
            assert_eq!(*privacy_mode, PrivacyMode::PrivateInputs);
            assert_eq!(checkpoints.len(), 1);

            // The checkpoint IS the transition hash — it reveals the
            // computation's state transition structure
            let expected_transition = hash_transition(
                &hash_data(b"secret_state_0"),
                &hash_data(b"secret_input"),
                &hash_data(b"secret_state_1"),
            );
            assert_eq!(
                checkpoints[0], expected_transition,
                "V15-14: PrivateInputs mode still exposes checkpoint transition hashes"
            );
        }
        _ => panic!("expected HashIvc"),
    }
}

// ========================================================================
// V15-15: CompositeProof is_structurally_valid accepts Mock unconditionally
// ========================================================================

/// Mock proofs return true from is_structurally_valid without any
/// cryptographic checks. An attacker can wrap forged Mock proofs
/// in a CompositeProof and it verifies.
#[test]
fn v15_15_composite_mock_structural_validity() {
    // Forge a Mock proof with arbitrary hashes
    let forged = VerifiedProof::Mock {
        input_hash: hash_data(b"forged_input"),
        output_hash: hash_data(b"forged_output"),
        privacy_mode: PrivacyMode::Transparent,
    };

    let composite = CompositeProof::compose(
        forged.clone(),
        vec![forged.clone(), forged.clone()],
    );

    // All Mock proofs pass structural validation
    assert!(
        composite.verify_composition(),
        "V15-15: CompositeProof of entirely forged Mock proofs verifies"
    );
}

// ========================================================================
// V15-16: FixedPoint from_int with edge values
// ========================================================================

/// Verify from_int behavior at i64 boundaries.
#[test]
fn v15_16_fixedpoint_from_int_boundaries() {
    // i64::MIN: (i64::MIN as i128) * SCALE
    let min = FixedPoint::from_int(i64::MIN);
    let expected_raw = (i64::MIN as i128) * FixedPoint::SCALE;
    assert_eq!(
        min.raw(), expected_raw,
        "V15-16: from_int(i64::MIN) uses plain multiplication (no overflow check)"
    );

    // Verify the raw value is negative
    assert!(min.raw() < 0);

    // from_int(0) should be ZERO
    assert_eq!(FixedPoint::from_int(0).raw(), 0);

    // from_int(1) == ONE
    assert_eq!(FixedPoint::from_int(1), FixedPoint::ONE);

    // from_int(i64::MAX) should produce valid result (no overflow in i128)
    let max = FixedPoint::from_int(i64::MAX);
    let expected_max_raw = (i64::MAX as i128) * FixedPoint::SCALE;
    assert_eq!(max.raw(), expected_max_raw);

    // Roundtrip: from_int(x).to_i64() == x for reasonable values
    for v in [0i64, 1, -1, 100, -100, 1000000, -1000000] {
        assert_eq!(
            FixedPoint::from_int(v).to_i64(), v,
            "V15-16: from_int({}).to_i64() roundtrip", v
        );
    }
}

// ========================================================================
// V15-17: HashChain append with ZERO_HASH
// ========================================================================

/// Appending ZERO_HASH to a hash chain is valid — ZERO_HASH is not
/// treated as a sentinel/null value in append. This allows injection
/// of "empty" steps into the chain.
#[test]
fn v15_17_hashchain_zero_hash_step() {
    use poly_verified::crypto::chain::HashChain;

    let mut chain = HashChain::new();
    chain.append(&ZERO_HASH);

    // Chain advanced despite ZERO_HASH input
    assert_eq!(chain.length, 1);
    let expected_tip = hash_chain_step(&ZERO_HASH, &ZERO_HASH);
    assert_eq!(chain.tip, expected_tip);
    assert_ne!(chain.tip, ZERO_HASH, "V15-17: ZERO_HASH step produces non-zero tip");

    // Multiple ZERO_HASH steps
    chain.append(&ZERO_HASH);
    assert_eq!(chain.length, 2);
    let expected_tip2 = hash_chain_step(&expected_tip, &ZERO_HASH);
    assert_eq!(chain.tip, expected_tip2);

    // Each ZERO step produces a different tip (chain is order-dependent)
    assert_ne!(expected_tip, expected_tip2);
}

// ========================================================================
// V15-18: VerifiedResponse value_hash depends on serialization format
// ========================================================================

/// value_hash is computed from raw value_bytes. Two different byte
/// representations of the same semantic value produce different hashes.
#[test]
fn v15_18_response_value_hash_serialization_dependent() {
    let proof = VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    };

    // Same value (42), different serialization formats
    let json_bytes = b"42".to_vec();
    let bincode_bytes = 42u32.to_le_bytes().to_vec();

    let resp_json = VerifiedResponse::new(&proof, ZERO_HASH, json_bytes.clone(), ZERO_HASH);
    let resp_bin = VerifiedResponse::new(&proof, ZERO_HASH, bincode_bytes.clone(), ZERO_HASH);

    // Different value_bytes produce different value_hashes
    assert_ne!(
        resp_json.value_hash, resp_bin.value_hash,
        "V15-18: Same semantic value, different bytes, different hashes"
    );

    // Both individually verify integrity
    let bytes_json = resp_json.to_bytes();
    let bytes_bin = resp_bin.to_bytes();
    assert!(VerifiedResponse::from_bytes(&bytes_json).unwrap().verify_value_integrity());
    assert!(VerifiedResponse::from_bytes(&bytes_bin).unwrap().verify_value_integrity());
}

// ========================================================================
// V15-19: Disclosure with ZERO_HASH leaf hashes rejected
// ========================================================================

/// Verify that redacted positions with ZERO_HASH leaf_hash are rejected
/// by verify_disclosure.
#[test]
fn v15_19_disclosure_zero_hash_redacted_leaf() {
    let tokens = vec![100, 200, 300, 400];
    let verified = make_verified(tokens);

    let mut disclosure = create_disclosure(&verified, &[0]).unwrap();

    // Tamper: set a redacted leaf to ZERO_HASH
    disclosure.tokens[1] = DisclosedToken::Redacted {
        index: 1,
        leaf_hash: ZERO_HASH,
    };

    assert!(
        !verify_disclosure(&disclosure),
        "V15-19: ZERO_HASH redacted leaf must be rejected"
    );
}

// ========================================================================
// V15-20: Merkle tree depth varies with leaf count alignment
// ========================================================================

/// Power-of-two leaf counts produce balanced trees; non-power-of-two
/// leaf counts require duplication and produce deeper trees. This means
/// proof length (number of siblings) leaks information about tree size.
#[test]
fn v15_20_merkle_tree_depth_leaks_size() {
    // 4 leaves (power of 2): depth 2
    let tree4 = MerkleTree::build(&vec![hash_data(b"x"); 4]);
    let proof4 = tree4.generate_proof(0, &ZERO_HASH).unwrap();

    // 5 leaves: depth 3 (5->3->2->1)
    let tree5 = MerkleTree::build(&vec![hash_data(b"x"); 5]);
    let proof5 = tree5.generate_proof(0, &ZERO_HASH).unwrap();

    // 8 leaves (power of 2): depth 3
    let tree8 = MerkleTree::build(&vec![hash_data(b"x"); 8]);
    let proof8 = tree8.generate_proof(0, &ZERO_HASH).unwrap();

    assert_eq!(proof4.siblings.len(), 2, "4 leaves: 2 siblings");
    assert_eq!(proof5.siblings.len(), 3, "5 leaves: 3 siblings");
    assert_eq!(proof8.siblings.len(), 3, "8 leaves: 3 siblings");

    // 5 and 8 leaves have same proof length — but 4 has shorter
    assert_ne!(
        proof4.siblings.len(),
        proof5.siblings.len(),
        "V15-20: Different leaf counts can produce different proof lengths"
    );
}

// ========================================================================
// V15-21: VerifiedProof HashIvc clone indistinguishable
// ========================================================================

/// Cloning a HashIvc proof produces a byte-identical copy with no
/// uniqueness marker. There's no way to tell clone from original.
#[test]
fn v15_21_hashivc_proof_clone_identical() {
    let proof = make_hash_ivc_proof(&hash_data(b"code"), &ZERO_HASH, &ZERO_HASH);
    let cloned = proof.clone();

    let json1 = serde_json::to_string(&proof).unwrap();
    let json2 = serde_json::to_string(&cloned).unwrap();

    assert_eq!(
        json1, json2,
        "V15-21: Cloned proof is byte-identical to original"
    );
}

// ========================================================================
// V15-22: BackendId from_u8 accepts Mock (0x00)
// ========================================================================

/// BackendId::from_u8(0x00) returns Mock. There's no way to reject
/// the test-only backend at the deserialization layer.
#[test]
fn v15_22_backend_id_accepts_mock() {
    let mock = BackendId::from_u8(0x00).unwrap();
    assert_eq!(mock, BackendId::Mock);

    // All valid backend IDs
    assert_eq!(BackendId::from_u8(0x01).unwrap(), BackendId::HashIvc);
    assert_eq!(BackendId::from_u8(0x02).unwrap(), BackendId::Nova);
    assert_eq!(BackendId::from_u8(0x03).unwrap(), BackendId::HyperNova);

    // Invalid IDs rejected
    for invalid in 0x04..=0xFF {
        assert!(
            BackendId::from_u8(invalid).is_err(),
            "V15-22: BackendId 0x{:02x} must be rejected",
            invalid
        );
    }
}

// ========================================================================
// V15-23: PrivacyMode from_u8 exhaustive validation
// ========================================================================

/// Verify that all invalid privacy mode bytes are correctly rejected.
#[test]
fn v15_23_privacy_mode_exhaustive() {
    assert_eq!(PrivacyMode::from_u8(0x00).unwrap(), PrivacyMode::Transparent);
    assert_eq!(PrivacyMode::from_u8(0x01).unwrap(), PrivacyMode::Private);
    assert_eq!(PrivacyMode::from_u8(0x02).unwrap(), PrivacyMode::PrivateInputs);

    for invalid in 0x03..=0xFF {
        assert!(
            PrivacyMode::from_u8(invalid).is_err(),
            "V15-23: PrivacyMode 0x{:02x} must be rejected",
            invalid
        );
    }

    // Test helper methods
    assert!(!PrivacyMode::Transparent.is_private());
    assert!(PrivacyMode::Private.is_private());
    assert!(PrivacyMode::PrivateInputs.is_private());

    assert!(!PrivacyMode::Transparent.hides_inputs());
    assert!(PrivacyMode::Private.hides_inputs());
    assert!(PrivacyMode::PrivateInputs.hides_inputs());

    assert!(!PrivacyMode::Transparent.hides_outputs());
    assert!(PrivacyMode::Private.hides_outputs());
    assert!(!PrivacyMode::PrivateInputs.hides_outputs());

    assert_eq!(PrivacyMode::default(), PrivacyMode::Transparent);
}

// ========================================================================
// V15-24: MerkleProof sibling_count boundary (64 max)
// ========================================================================

/// MerkleProof from_bytes rejects sibling_count > 64 but accepts 64.
#[test]
fn v15_24_merkle_proof_sibling_count_boundary() {
    // Build a minimal valid proof with 0 siblings
    let proof = MerkleProof {
        leaf: hash_data(b"leaf"),
        leaf_index: 0,
        siblings: vec![],
        root: hash_data(b"leaf"),
        code_hash: ZERO_HASH,
    };
    let bytes = proof.to_bytes();
    assert!(MerkleProof::from_bytes(&bytes).is_ok());

    // Craft wire bytes with sibling_count=65 (invalid)
    let mut crafted = Vec::new();
    crafted.extend_from_slice(&[0u8; 32]); // leaf
    crafted.extend_from_slice(&0u64.to_le_bytes()); // leaf_index
    crafted.extend_from_slice(&65u32.to_be_bytes()); // sibling_count = 65 (too many)
    // We don't need actual siblings for the check
    // Add enough bytes for the expected size
    for _ in 0..65 {
        crafted.extend_from_slice(&[0u8; 33]); // 65 siblings
    }
    crafted.extend_from_slice(&[0u8; 64]); // root + code_hash

    assert!(
        MerkleProof::from_bytes(&crafted).is_err(),
        "V15-24: sibling_count=65 must be rejected"
    );

    // sibling_count=64 with correct total size should be accepted
    let mut valid_64 = Vec::new();
    valid_64.extend_from_slice(&[0u8; 32]); // leaf
    valid_64.extend_from_slice(&0u64.to_le_bytes()); // leaf_index
    valid_64.extend_from_slice(&64u32.to_be_bytes()); // sibling_count = 64
    for _ in 0..64 {
        valid_64.extend_from_slice(&[0u8; 32]); // hash
        valid_64.push(0x00); // is_left
    }
    valid_64.extend_from_slice(&[0u8; 64]); // root + code_hash

    assert!(
        MerkleProof::from_bytes(&valid_64).is_ok(),
        "V15-24: sibling_count=64 must be accepted"
    );
}

// ========================================================================
// V15-25: HashIvc 2-step chain tip order dependency
// ========================================================================

/// Verify that the chain tip depends on the order of steps, not just
/// their content. Two different orderings of the same steps produce
/// different chain tips.
#[test]
fn v15_25_hashivc_two_step_order() {
    let ivc = HashIvc;
    let code_hash = hash_data(b"func");

    let w_a = StepWitness {
        state_before: hash_data(b"s0"),
        state_after: hash_data(b"s1"),
        step_inputs: hash_data(b"i_a"),
    };
    let w_b = StepWitness {
        state_before: hash_data(b"s1"),
        state_after: hash_data(b"s2"),
        step_inputs: hash_data(b"i_b"),
    };

    // Order: A then B
    let mut acc_ab = ivc.init(&code_hash, PrivacyMode::Transparent);
    ivc.fold_step(&mut acc_ab, &w_a).unwrap();
    ivc.fold_step(&mut acc_ab, &w_b).unwrap();
    let proof_ab = ivc.finalize(acc_ab).unwrap();

    // Order: B then A
    let mut acc_ba = ivc.init(&code_hash, PrivacyMode::Transparent);
    ivc.fold_step(&mut acc_ba, &w_b).unwrap();
    ivc.fold_step(&mut acc_ba, &w_a).unwrap();
    let proof_ba = ivc.finalize(acc_ba).unwrap();

    match (&proof_ab, &proof_ba) {
        (
            VerifiedProof::HashIvc { chain_tip: tip_ab, merkle_root: root_ab, .. },
            VerifiedProof::HashIvc { chain_tip: tip_ba, merkle_root: root_ba, .. },
        ) => {
            assert_ne!(
                tip_ab, tip_ba,
                "V15-25: Different step orderings produce different chain tips"
            );
            // Merkle roots also differ (different leaf order)
            assert_ne!(root_ab, root_ba);
        }
        _ => panic!("expected HashIvc"),
    }
}

// ========================================================================
// V15-26: FixedPoint checked_mul overflow detection
// ========================================================================

/// checked_mul correctly returns None for values that would overflow.
#[test]
fn v15_26_fixedpoint_checked_mul_overflow() {
    let big = FixedPoint::from_raw(i128::MAX / 2);
    let three = FixedPoint::from_int(3);

    // (MAX/2) * 3 overflows i128
    let result = big.checked_mul(three);
    assert!(
        result.is_none(),
        "V15-26: checked_mul returns None on overflow"
    );

    // Small values work
    let a = FixedPoint::from_int(100);
    let b = FixedPoint::from_int(200);
    let c = a.checked_mul(b);
    assert!(c.is_some());
    assert_eq!(c.unwrap().to_i64(), 20000);
}

// ========================================================================
// V15-27: Commitment PartialEq reflexive for boundary values
// ========================================================================

/// Verify reflexivity of PartialEq for edge-case field values.
#[test]
fn v15_27_commitment_eq_reflexive() {
    let cases = vec![
        Commitment {
            root: ZERO_HASH,
            total_checkpoints: 0,
            chain_tip: ZERO_HASH,
            code_hash: ZERO_HASH,
        },
        Commitment {
            root: [0xFF; 32],
            total_checkpoints: u64::MAX,
            chain_tip: [0xFF; 32],
            code_hash: [0xFF; 32],
        },
        Commitment {
            root: [0x01; 32],
            total_checkpoints: 1,
            chain_tip: [0x02; 32],
            code_hash: [0x03; 32],
        },
    ];

    for c in &cases {
        assert_eq!(c, c, "V15-27: Commitment PartialEq must be reflexive");
    }

    // Different commitments
    assert_ne!(&cases[0], &cases[1]);
    assert_ne!(&cases[1], &cases[2]);
}

// ========================================================================
// V15-28: VerifiedResponse Private mode strips value_bytes
// ========================================================================

/// In Private mode, VerifiedResponse::new strips value_bytes and zeros
/// value_hash. Verify roundtrip behavior.
#[test]
fn v15_28_response_private_strips_value() {
    let proof = VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Private,
    };

    let secret_value = b"top_secret_value_do_not_leak".to_vec();
    let response = VerifiedResponse::new(&proof, [0x42; 32], secret_value, ZERO_HASH);

    // Value stripped
    assert!(response.value_bytes.is_empty(), "V15-28: Private strips value_bytes");
    assert_eq!(response.value_hash, ZERO_HASH, "V15-28: Private zeros value_hash");
    assert_eq!(response.input_hash, ZERO_HASH, "V15-28: Private zeros input_hash");

    // Roundtrip
    let bytes = response.to_bytes();
    let decoded = VerifiedResponse::from_bytes(&bytes).unwrap();
    assert!(decoded.value_bytes.is_empty());
    assert!(decoded.verify_value_integrity());
}

// ========================================================================
// V15-29: Disclosure with unsorted indices
// ========================================================================

/// create_disclosure accepts unsorted indices — they're collected into
/// a HashSet, so order doesn't matter.
#[test]
fn v15_29_disclosure_unsorted_indices() {
    let tokens = vec![10, 20, 30, 40, 50];
    let verified = make_verified(tokens);

    // Indices in reverse order
    let d1 = create_disclosure(&verified, &[4, 2, 0]).unwrap();
    // Indices in ascending order
    let d2 = create_disclosure(&verified, &[0, 2, 4]).unwrap();

    // Both should produce same disclosure (same revealed set)
    assert_eq!(d1.proofs.len(), d2.proofs.len());
    assert_eq!(d1.output_root, d2.output_root);
    assert!(verify_disclosure(&d1));
    assert!(verify_disclosure(&d2));

    // Both reveal the same tokens at the same positions
    for i in [0, 2, 4] {
        assert!(matches!(&d1.tokens[i], DisclosedToken::Revealed { .. }));
        assert!(matches!(&d2.tokens[i], DisclosedToken::Revealed { .. }));
    }
}

// ========================================================================
// V15-30: HashIvc PrivateInputs still shows code_hash
// ========================================================================

/// In PrivateInputs mode, the code_hash is still visible (only inputs
/// are hidden). Verify this behavior.
#[test]
fn v15_30_hashivc_private_inputs_code_hash_visible() {
    let code_hash = hash_data(b"my_secret_function_name");
    let proof = make_hash_ivc_proof(&code_hash, &ZERO_HASH, &ZERO_HASH);

    // In Transparent mode, code_hash is visible
    assert_eq!(proof.code_hash(), code_hash);

    // Build PrivateInputs proof
    let ivc = HashIvc;
    let mut acc = ivc.init(&code_hash, PrivacyMode::PrivateInputs);
    let w = StepWitness {
        state_before: hash_data(b"b"),
        state_after: hash_data(b"a"),
        step_inputs: hash_data(b"i"),
    };
    ivc.fold_step(&mut acc, &w).unwrap();
    let pi_proof = ivc.finalize(acc).unwrap();

    // PrivateInputs: code_hash is STILL visible
    assert_eq!(
        pi_proof.code_hash(), code_hash,
        "V15-30: PrivateInputs mode exposes code_hash"
    );

    // Only Private mode hides it
    let mut acc_priv = ivc.init(&code_hash, PrivacyMode::Private);
    ivc.fold_step(&mut acc_priv, &w).unwrap();
    let priv_proof = ivc.finalize(acc_priv).unwrap();
    assert_eq!(
        priv_proof.code_hash(), ZERO_HASH,
        "V15-30: Only Private mode hides code_hash"
    );
}

// ========================================================================
// V15-31: MerkleTree with 7 leaves — odd at multiple levels
// ========================================================================

/// 7 leaves: layer sizes are 7->4->2->1. The odd leaf at layer 0
/// gets duplicated. All proofs must verify.
#[test]
fn v15_31_merkle_seven_leaves() {
    let leaves: Vec<Hash> = (0..7u8).map(|i| hash_data(&[i])).collect();
    let tree = MerkleTree::build(&leaves);

    // Layer sizes: 7 -> 4 -> 2 -> 1
    assert_eq!(tree.layers[0].len(), 7);
    assert_eq!(tree.layers[1].len(), 4); // ceil(7/2) = 4, leaf 6 duplicated
    assert_eq!(tree.layers[2].len(), 2);
    assert_eq!(tree.layers[3].len(), 1);

    for i in 0..7u64 {
        let proof = tree.generate_proof(i, &ZERO_HASH).unwrap();
        assert!(
            verify_proof(&proof),
            "V15-31: Proof for index {} in 7-leaf tree must verify", i
        );
    }

    // Out of bounds
    assert!(tree.generate_proof(7, &ZERO_HASH).is_err());
}

// ========================================================================
// V15-32: FixedPoint Display for negative fractions
// ========================================================================

/// Verify Display formatting for small negative fractions near zero.
#[test]
fn v15_32_fixedpoint_display_negative_fractions() {
    // -0.5
    let neg_half = FixedPoint::from_decimal(-50, 2);
    let display = format!("{}", neg_half);
    assert!(
        display.starts_with("-0."),
        "V15-32: -0.5 should display as '-0.xxx', got '{}'", display
    );

    // -0.001 (very small negative)
    let neg_tiny = FixedPoint::from_decimal(-1, 3);
    let display_tiny = format!("{}", neg_tiny);
    assert!(
        display_tiny.starts_with("-0."),
        "V15-32: -0.001 should display as '-0.xxx', got '{}'", display_tiny
    );

    // Positive fractions for comparison
    let pos_half = FixedPoint::from_decimal(50, 2);
    let display_pos = format!("{}", pos_half);
    assert!(
        display_pos.starts_with("0."),
        "V15-32: 0.5 should display as '0.xxx', got '{}'", display_pos
    );
}

// ========================================================================
// V15-33: CodeAttestation from_bytes with all-zero fields
// ========================================================================

/// from_bytes accepts an all-zero CodeAttestation. This is structurally
/// valid but semantically meaningless (zero node_id, zero code_hash,
/// circuit_id=0, zero signature).
#[test]
fn v15_33_attestation_all_zeros() {
    let all_zero = [0u8; CodeAttestation::SIZE];
    let decoded = CodeAttestation::from_bytes(&all_zero).unwrap();

    assert_eq!(decoded.node_id, [0u8; 32]);
    assert_eq!(decoded.code_hash, ZERO_HASH);
    assert_eq!(decoded.circuit_id, 0);
    assert_eq!(decoded.signature, [0u8; 64]);

    // sign_message is deterministic
    let msg = decoded.sign_message();
    assert_eq!(msg, [0u8; 72], "V15-33: All-zero attestation sign_message is all zeros");

    // Roundtrip
    let re_encoded = decoded.to_bytes();
    assert_eq!(&re_encoded[..], &all_zero[..]);
}

// ========================================================================
// V15-34: CompositeProof serde roundtrip
// ========================================================================

/// Verify that CompositeProof survives serde roundtrip with all fields
/// preserved.
#[test]
fn v15_34_composite_serde_roundtrip() {
    let code_hash = hash_data(b"func");
    let outer = make_hash_ivc_proof(&code_hash, &ZERO_HASH, &ZERO_HASH);
    let inner = VerifiedProof::Mock {
        input_hash: [0x01; 32],
        output_hash: [0x02; 32],
        privacy_mode: PrivacyMode::PrivateInputs,
    };

    let composite = CompositeProof::compose(outer, vec![inner]);
    assert!(composite.verify_composition());

    let json = serde_json::to_string(&composite).unwrap();
    let decoded: CompositeProof = serde_json::from_str(&json).unwrap();

    assert_eq!(decoded.composition_hash, composite.composition_hash);
    assert_eq!(decoded.privacy_mode, composite.privacy_mode);
    assert_eq!(decoded.inner_proofs.len(), composite.inner_proofs.len());
    assert!(
        decoded.verify_composition(),
        "V15-34: Deserialized composite must still verify"
    );
}

// ========================================================================
// V15-35: SignedCommitment tampered commitment bytes
// ========================================================================

/// Tamper with the commitment portion of a SignedCommitment's wire bytes.
/// Signature verification should catch the tamper.
#[test]
fn v15_35_signed_commitment_tampered_body() {
    let checkpoints: Vec<Hash> = (0..4u8).map(|i| hash_data(&[i])).collect();
    let code_hash = hash_data(b"code");
    let (commitment, _) = create_commitment(&checkpoints, &code_hash);

    let key = SigningKey::from_bytes(&[0x42; 32]);
    let signed = sign_commitment(&commitment, &key);
    assert!(verify_signed_commitment(&signed).is_ok());

    let mut bytes = signed.to_bytes();
    // Tamper the root field (bytes 0..32)
    bytes[0] ^= 0xFF;

    let decoded = SignedCommitment::from_bytes(&bytes).unwrap();
    assert!(
        verify_signed_commitment(&decoded).is_err(),
        "V15-35: Tampered commitment body must fail signature verification"
    );
}

// ========================================================================
// V15-36: HashIvc verify rejects wrong code_hash via chain_tip
// ========================================================================

/// The chain_tip binds code_hash: tampering code_hash in the proof
/// produces a chain_tip mismatch during verification.
#[test]
fn v15_36_hashivc_code_hash_bound_to_chain_tip() {
    let ivc = HashIvc;
    let code_hash = hash_data(b"real_code");
    let mut acc = ivc.init(&code_hash, PrivacyMode::Transparent);
    let w = StepWitness {
        state_before: hash_data(b"b"),
        state_after: hash_data(b"a"),
        step_inputs: hash_data(b"i"),
    };
    ivc.fold_step(&mut acc, &w).unwrap();
    acc.input_hash = ZERO_HASH;
    acc.output_hash = ZERO_HASH;
    let proof = ivc.finalize(acc).unwrap();

    // Tamper code_hash via serde
    let mut json = serde_json::to_value(&proof).unwrap();
    if let Some(hashivc) = json.get_mut("HashIvc") {
        hashivc["code_hash"] = serde_json::json!(vec![0xFFu8; 32]);
    }
    let tampered: VerifiedProof = serde_json::from_value(json).unwrap();

    // chain_tip was computed with the real code_hash; tampered code_hash
    // produces different code_binding in verify
    assert!(
        !ivc.verify(&tampered, &ZERO_HASH, &ZERO_HASH).unwrap(),
        "V15-36: Tampered code_hash caught by chain_tip binding"
    );
}

// ========================================================================
// V15-37: token_leaf uses domain-separated hash
// ========================================================================

/// token_leaf(x) uses hash_leaf (0x00 prefix), not hash_data. This
/// means token_leaf(x) != hash_data(x_bytes) for the same input bytes.
#[test]
fn v15_37_token_leaf_domain_separation() {
    let token_id: u32 = 42;
    let leaf = token_leaf(token_id);

    // hash_leaf uses 0x00 prefix
    let expected = hash_leaf(&token_id.to_le_bytes());
    assert_eq!(leaf, expected);

    // hash_data does NOT use 0x00 prefix
    let raw = hash_data(&token_id.to_le_bytes());
    assert_ne!(
        leaf, raw,
        "V15-37: token_leaf uses domain-separated hash (0x00 prefix)"
    );
}

// ========================================================================
// V15-38: VerifiedResponse to_bytes capacity matches actual size
// ========================================================================

/// Verify that the allocated capacity matches the actual output size.
#[test]
fn v15_38_response_to_bytes_size() {
    let proof = VerifiedProof::Mock {
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
        privacy_mode: PrivacyMode::Transparent,
    };
    let value = b"test_value_data".to_vec();
    let response = VerifiedResponse::new(&proof, ZERO_HASH, value.clone(), ZERO_HASH);

    let bytes = response.to_bytes();
    let expected_size = 32 + 32 + 32 + 1 + 1 + 4 + response.proof_bytes.len() + 32 + value.len();
    assert_eq!(
        bytes.len(), expected_size,
        "V15-38: to_bytes output size matches expected layout"
    );
}

// ========================================================================
// V15-39: FixedPoint exp_approx(0) returns ONE
// ========================================================================

/// e^0 = 1 exactly. Verify this.
#[test]
fn v15_39_fixedpoint_exp_zero() {
    let zero = FixedPoint::ZERO;
    let result = zero.exp_approx(20);
    assert_eq!(
        result, FixedPoint::ONE,
        "V15-39: exp(0) must equal ONE exactly"
    );
}

// ========================================================================
// V15-40: MerkleProof 0 siblings roundtrip
// ========================================================================

/// A proof with 0 siblings (single-leaf tree) should roundtrip.
#[test]
fn v15_40_merkle_proof_zero_siblings_roundtrip() {
    let leaf = hash_data(b"only_leaf");
    let proof = MerkleProof {
        leaf,
        leaf_index: 0,
        siblings: vec![],
        root: leaf,
        code_hash: hash_data(b"code"),
    };

    let bytes = proof.to_bytes();
    assert_eq!(bytes.len(), 108); // 32 + 8 + 4 + 0*33 + 32 + 32

    let decoded = MerkleProof::from_bytes(&bytes).unwrap();
    assert_eq!(decoded.leaf, proof.leaf);
    assert_eq!(decoded.leaf_index, 0);
    assert!(decoded.siblings.is_empty());
    assert_eq!(decoded.root, proof.root);
    assert_eq!(decoded.code_hash, proof.code_hash);

    assert!(verify_proof(&decoded), "V15-40: 0-sibling proof verifies");
}

// ========================================================================
// V15-41: HashIvc PrivateInputs verify skips input, enforces output
// ========================================================================

/// In PrivateInputs mode, verify should NOT check input_hash but
/// SHOULD check output_hash.
#[test]
fn v15_41_hashivc_private_inputs_io_behavior() {
    let ivc = HashIvc;
    let code_hash = hash_data(b"func");
    let mut acc = ivc.init(&code_hash, PrivacyMode::PrivateInputs);
    let w = StepWitness {
        state_before: hash_data(b"b"),
        state_after: hash_data(b"a"),
        step_inputs: hash_data(b"i"),
    };
    ivc.fold_step(&mut acc, &w).unwrap();
    let output_hash = hash_data(b"real_output");
    acc.output_hash = output_hash;
    let proof = ivc.finalize(acc).unwrap();

    // Correct output, any input: should pass (inputs hidden)
    assert!(
        ivc.verify(&proof, &hash_data(b"wrong_input"), &output_hash).unwrap(),
        "V15-41: PrivateInputs skips input check"
    );

    // Wrong output: should fail
    assert!(
        !ivc.verify(&proof, &ZERO_HASH, &hash_data(b"wrong_output")).unwrap(),
        "V15-41: PrivateInputs enforces output check"
    );
}

// ========================================================================
// V15-42: Disclosure verify rejects extra proofs
// ========================================================================

/// verify_disclosure checks that all proofs are consumed (proof_idx ==
/// proofs.len()). Extra proofs should cause failure.
#[test]
fn v15_42_disclosure_extra_proofs_rejected() {
    let tokens = vec![10, 20, 30, 40];
    let verified = make_verified(tokens.clone());

    let mut disclosure = create_disclosure(&verified, &[0]).unwrap();
    assert_eq!(disclosure.proofs.len(), 1);

    // Add an extra proof (duplicate of the first)
    disclosure.proofs.push(disclosure.proofs[0].clone());

    // verify_disclosure should reject because proof_idx (1) != proofs.len() (2)
    assert!(
        !verify_disclosure(&disclosure),
        "V15-42: Extra proofs in disclosure must be rejected"
    );
}

// ========================================================================
// V15-43: CompositeProof empty inner_proofs privacy
// ========================================================================

/// With no inner proofs, the privacy mode should be the outer proof's mode.
#[test]
fn v15_43_composite_empty_inner_privacy() {
    for mode in [PrivacyMode::Transparent, PrivacyMode::Private, PrivacyMode::PrivateInputs] {
        let outer = VerifiedProof::Mock {
            input_hash: ZERO_HASH,
            output_hash: ZERO_HASH,
            privacy_mode: mode,
        };
        let composite = CompositeProof::compose(outer, vec![]);
        assert_eq!(
            composite.privacy_mode, mode,
            "V15-43: Empty inner_proofs: privacy should be outer's mode ({:?})", mode
        );
        assert!(composite.verify_composition());
    }
}

// ========================================================================
// V15-44: FixedPoint to_u64_saturating for large values
// ========================================================================

/// Verify to_u64_saturating clamps correctly at boundaries.
#[test]
fn v15_44_fixedpoint_to_u64_large() {
    // Very large positive: saturates at u64::MAX
    let big = FixedPoint::from_raw(i128::MAX);
    assert_eq!(
        big.to_u64_saturating(), u64::MAX,
        "V15-44: Very large positive saturates to u64::MAX"
    );

    // Negative: clamps to 0
    let neg = FixedPoint::from_int(-1);
    assert_eq!(neg.to_u64_saturating(), 0);

    // Normal positive
    let normal = FixedPoint::from_int(12345);
    assert_eq!(normal.to_u64_saturating(), 12345);

    // Zero
    assert_eq!(FixedPoint::ZERO.to_u64_saturating(), 0);
}

// ========================================================================
// V15-45: Commitment roundtrip with u64::MAX total_checkpoints
// ========================================================================

/// Verify that u64::MAX as total_checkpoints survives serialization roundtrip.
#[test]
fn v15_45_commitment_u64_max_checkpoints() {
    let commitment = Commitment {
        root: [0xAA; 32],
        total_checkpoints: u64::MAX,
        chain_tip: [0xBB; 32],
        code_hash: [0xCC; 32],
    };

    let bytes = commitment.to_bytes();
    let decoded = Commitment::from_bytes(&bytes).unwrap();

    assert_eq!(decoded.total_checkpoints, u64::MAX);
    assert_eq!(decoded.root, [0xAA; 32]);
    assert_eq!(decoded.chain_tip, [0xBB; 32]);
    assert_eq!(decoded.code_hash, [0xCC; 32]);
    assert_eq!(commitment, decoded);
}
