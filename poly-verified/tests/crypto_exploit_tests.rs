//! Cryptographic verification regression tests for poly-verified.
//!
//! These tests were originally exploit tests demonstrating real vulnerabilities
//! in the IVC verification system. Each test now confirms that the fix works:
//! forged, tampered, and mismatched proofs are REJECTED by verify().
//!
//! Fixed vulnerabilities:
//! - FIXED: HashIvc::verify() now checks chain_tip, merkle_root, I/O hashes, blinding
//! - FIXED: Proofs from fabricated computations are rejected
//! - FIXED: Input/output hash parameters are now properly verified
//! - FIXED: code_hash is now bound into chain_tip and verified by HashIvc::verify()

use poly_verified::crypto::hash::hash_data;
use poly_verified::ivc::hash_ivc::HashIvc;
use poly_verified::ivc::IvcBackend;
use poly_verified::types::{Hash, PrivacyMode, StepWitness, VerifiedProof, ZERO_HASH};

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 1: FORGED PROOFS ARE NOW REJECTED
//
// HashIvc::verify() now checks:
//   1. step_count > 0
//   2. checkpoints.len() == step_count
//   3. Rebuild hash chain from checkpoints → verify chain_tip
//   4. Rebuild Merkle tree from checkpoints → verify merkle_root
//   5. I/O hash verification (privacy-aware)
//   6. Blinding commitment verification (private modes)
//
// Fabricated proofs with empty checkpoints or garbage hashes are rejected.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Forged transparent proof with garbage hashes is now rejected.
#[test]
fn exploit_forge_transparent_proof_from_nothing() {
    let backend = HashIvc;

    // Attacker fabricates a proof with random bytes
    let forged_proof = VerifiedProof::HashIvc {
        chain_tip: [0xDE; 32],      // garbage
        merkle_root: [0xAD; 32],    // garbage
        step_count: 42,             // claim 42 steps happened
        code_hash: [0xBE; 32],      // garbage
        privacy_mode: PrivacyMode::Transparent,
        blinding_commitment: None,
        checkpoints: vec![],        // empty — won't match step_count
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
    };

    let result = backend.verify(&forged_proof, &ZERO_HASH, &ZERO_HASH).unwrap();

    assert!(
        !result,
        "FIXED: forged transparent proof must be rejected"
    );
    eprintln!("REGRESSION 1a PASSED: Forged transparent proof correctly rejected");
}

/// FIXED: Forged private proof with garbage hashes is now rejected.
#[test]
fn exploit_forge_private_proof_from_nothing() {
    let backend = HashIvc;

    let forged_proof = VerifiedProof::HashIvc {
        chain_tip: [0xCA; 32],
        merkle_root: [0xFE; 32],
        step_count: 1000,           // claim 1000 steps
        code_hash: [0x00; 32],
        privacy_mode: PrivacyMode::Private,
        blinding_commitment: Some([0xBA; 32]), // fake blinding
        checkpoints: vec![],        // empty — won't match step_count
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
    };

    let result = backend.verify(&forged_proof, &ZERO_HASH, &ZERO_HASH).unwrap();

    assert!(
        !result,
        "FIXED: forged private proof must be rejected"
    );
    eprintln!("REGRESSION 1b PASSED: Forged private proof correctly rejected");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 2: INPUT/OUTPUT HASH BINDING NOW WORKS
//
// verify() now checks I/O hashes in transparent mode:
//   - input_hash must match expected_input
//   - output_hash must match expected_output
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Same proof no longer verifies with mismatched I/O hashes.
#[test]
fn exploit_io_hashes_completely_ignored() {
    let backend = HashIvc;
    let code_hash = hash_data(b"real_computation");

    let real_input = hash_data(b"real_input");
    let real_output = hash_data(b"real_output");

    // Create a legitimate proof with proper I/O binding
    let mut acc = backend.init(&code_hash, PrivacyMode::Transparent);
    let witness = StepWitness {
        state_before: hash_data(b"input_state"),
        state_after: hash_data(b"output_state"),
        step_inputs: hash_data(b"real_inputs"),
    };
    backend.fold_step(&mut acc, &witness).unwrap();
    acc.input_hash = real_input;
    acc.output_hash = real_output;
    let proof = backend.finalize(acc).unwrap();

    // Verify with correct I/O hashes — should pass
    assert!(backend.verify(&proof, &real_input, &real_output).unwrap());

    // Verify with COMPLETELY DIFFERENT I/O hashes — NOW REJECTED
    let fake_input = hash_data(b"ATTACKER_CONTROLLED_INPUT");
    let fake_output = hash_data(b"ATTACKER_CONTROLLED_OUTPUT");
    let result_with_fake = backend.verify(&proof, &fake_input, &fake_output).unwrap();

    assert!(
        !result_with_fake,
        "FIXED: proof now correctly rejects mismatched I/O hashes"
    );
    eprintln!("REGRESSION 2 PASSED: I/O hashes are now properly verified");
}

/// FIXED: Proof is no longer transferable across prompts.
#[test]
fn exploit_proof_transferable_across_prompts() {
    let backend = HashIvc;
    let code_hash = hash_data(b"inference_engine");

    let benign_input = hash_data(b"benign_prompt_tokens");
    let benign_output = hash_data(b"benign_output_tokens");

    // Create proof for benign prompt with I/O binding
    let mut acc = backend.init(&code_hash, PrivacyMode::Transparent);
    let witness = StepWitness {
        state_before: hash_data(b"benign_prompt_tokens"),
        state_after: hash_data(b"benign_output_tokens"),
        step_inputs: hash_data(b"benign_generation"),
    };
    backend.fold_step(&mut acc, &witness).unwrap();
    acc.input_hash = benign_input;
    acc.output_hash = benign_output;
    let benign_proof = backend.finalize(acc).unwrap();

    // Verify with correct I/O — passes
    assert!(backend.verify(&benign_proof, &benign_input, &benign_output).unwrap());

    // Present the same proof as valid for a harmful prompt — NOW REJECTED
    let harmful_input = hash_data(b"how_to_build_a_bomb_tokens");
    let harmful_output = hash_data(b"harmful_instructions_tokens");

    let accepted = backend.verify(&benign_proof, &harmful_input, &harmful_output).unwrap();

    assert!(
        !accepted,
        "FIXED: proof is now bound to specific I/O"
    );
    eprintln!("REGRESSION 2b PASSED: Proof no longer transferable across prompts");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 3: CHAIN TIP FORGERY NOW DETECTED
//
// verify() rebuilds the hash chain from checkpoints and compares
// the computed tip against the claimed chain_tip.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Tampering with chain_tip after finalization is now detected.
#[test]
fn exploit_chain_tip_forgery() {
    let backend = HashIvc;
    let code_hash = hash_data(b"test_fn");

    // Create a real proof
    let mut acc = backend.init(&code_hash, PrivacyMode::Transparent);
    for i in 0..5u8 {
        let witness = StepWitness {
            state_before: hash_data(&[i]),
            state_after: hash_data(&[i + 1]),
            step_inputs: hash_data(&[i * 2]),
        };
        backend.fold_step(&mut acc, &witness).unwrap();
    }
    let real_proof = backend.finalize(acc).unwrap();

    // Extract and tamper with chain_tip
    let tampered = match real_proof {
        VerifiedProof::HashIvc {
            merkle_root,
            step_count,
            code_hash,
            privacy_mode,
            blinding_commitment,
            checkpoints,
            input_hash,
            output_hash,
            ..
        } => VerifiedProof::HashIvc {
            chain_tip: [0xFF; 32], // TAMPERED
            merkle_root,
            step_count,
            code_hash,
            privacy_mode,
            blinding_commitment,
            checkpoints,
            input_hash,
            output_hash,
        },
        _ => panic!("wrong proof type"),
    };

    let result = backend.verify(&tampered, &ZERO_HASH, &ZERO_HASH).unwrap();

    assert!(
        !result,
        "FIXED: tampered chain_tip now correctly rejected"
    );
    eprintln!("REGRESSION 3 PASSED: Tampered chain_tip correctly detected");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 4: MERKLE ROOT FORGERY NOW DETECTED
//
// verify() rebuilds the Merkle tree from checkpoints and compares
// the computed root against the claimed merkle_root.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Tampering with merkle_root after finalization is now detected.
#[test]
fn exploit_merkle_root_forgery() {
    let backend = HashIvc;
    let code_hash = hash_data(b"test_fn");

    let mut acc = backend.init(&code_hash, PrivacyMode::Transparent);
    let witness = StepWitness {
        state_before: hash_data(b"before"),
        state_after: hash_data(b"after"),
        step_inputs: hash_data(b"inputs"),
    };
    backend.fold_step(&mut acc, &witness).unwrap();
    let real_proof = backend.finalize(acc).unwrap();

    let tampered = match real_proof {
        VerifiedProof::HashIvc {
            chain_tip,
            step_count,
            code_hash,
            privacy_mode,
            blinding_commitment,
            checkpoints,
            input_hash,
            output_hash,
            ..
        } => VerifiedProof::HashIvc {
            chain_tip,
            merkle_root: [0x00; 32], // TAMPERED to zeros
            step_count,
            code_hash,
            privacy_mode,
            blinding_commitment,
            checkpoints,
            input_hash,
            output_hash,
        },
        _ => panic!("wrong proof type"),
    };

    let result = backend.verify(&tampered, &ZERO_HASH, &ZERO_HASH).unwrap();

    assert!(
        !result,
        "FIXED: tampered merkle_root now correctly rejected"
    );
    eprintln!("REGRESSION 4 PASSED: Tampered merkle_root correctly detected");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 5: CODE HASH FORGERY NOW DETECTED
//
// code_hash is now bound into chain_tip by finalize() and verify().
// Swapping code_hash causes chain_tip mismatch, so the forgery is detected.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: code_hash forgery is now detected (code_hash bound into chain_tip).
#[test]
fn exploit_code_hash_forgery() {
    let backend = HashIvc;

    // Create proof for "malicious_code"
    let real_code = hash_data(b"malicious_code");
    let mut acc = backend.init(&real_code, PrivacyMode::Transparent);
    let witness = StepWitness {
        state_before: hash_data(b"before"),
        state_after: hash_data(b"after"),
        step_inputs: hash_data(b"inputs"),
    };
    backend.fold_step(&mut acc, &witness).unwrap();
    let proof = backend.finalize(acc).unwrap();

    // Tamper: claim it was produced by "trusted_audited_code"
    let trusted_code = hash_data(b"trusted_audited_code");
    let disguised = match proof {
        VerifiedProof::HashIvc {
            chain_tip,
            merkle_root,
            step_count,
            privacy_mode,
            blinding_commitment,
            checkpoints,
            input_hash,
            output_hash,
            ..
        } => VerifiedProof::HashIvc {
            chain_tip,
            merkle_root,
            step_count,
            code_hash: trusted_code, // CHANGED (not verified by HashIvc)
            privacy_mode,
            blinding_commitment,
            checkpoints,
            input_hash,
            output_hash,
        },
        _ => panic!("wrong proof type"),
    };

    // FIXED: code_hash is now bound into chain_tip. Swapping code_hash causes
    // chain_tip mismatch, so the forgery is detected.
    let result = backend.verify(&disguised, &ZERO_HASH, &ZERO_HASH).unwrap();

    assert!(
        !result,
        "FIXED: code_hash forgery now detected (code_hash bound into chain_tip)"
    );
    eprintln!("REGRESSION 5 PASSED: code_hash forgery correctly detected (bound into chain_tip)");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 6: STEP COUNT INFLATION NOW DETECTED
//
// verify() checks checkpoints.len() == step_count. Inflating step_count
// without adding matching checkpoints causes rejection.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Inflated step count is now detected.
#[test]
fn exploit_step_count_inflation() {
    let backend = HashIvc;
    let code_hash = hash_data(b"test_fn");

    // Create a 1-step proof
    let mut acc = backend.init(&code_hash, PrivacyMode::Transparent);
    let witness = StepWitness {
        state_before: hash_data(b"before"),
        state_after: hash_data(b"after"),
        step_inputs: hash_data(b"inputs"),
    };
    backend.fold_step(&mut acc, &witness).unwrap();
    let proof = backend.finalize(acc).unwrap();

    // Tamper: inflate step count
    let inflated = match proof {
        VerifiedProof::HashIvc {
            chain_tip,
            merkle_root,
            code_hash,
            privacy_mode,
            blinding_commitment,
            checkpoints,
            input_hash,
            output_hash,
            ..
        } => VerifiedProof::HashIvc {
            chain_tip,
            merkle_root,
            step_count: 1_000_000, // INFLATED from 1
            code_hash,
            privacy_mode,
            blinding_commitment,
            checkpoints,
            input_hash,
            output_hash,
        },
        _ => panic!("wrong proof type"),
    };

    let result = backend.verify(&inflated, &ZERO_HASH, &ZERO_HASH).unwrap();

    assert!(
        !result,
        "FIXED: inflated step count now correctly rejected"
    );
    eprintln!("REGRESSION 6 PASSED: Step count inflation correctly detected");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 7: BLINDING COMMITMENT FORGERY NOW DETECTED
//
// verify() recomputes the expected blinding commitment from checkpoints
// and compares against the claimed blinding_commitment.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Forged blinding commitment is now detected.
#[test]
fn exploit_blinding_commitment_forgery() {
    let backend = HashIvc;
    let code_hash = hash_data(b"private_fn");

    // Create real private proof
    let mut acc = backend.init(&code_hash, PrivacyMode::Private);
    let witness = StepWitness {
        state_before: hash_data(b"before"),
        state_after: hash_data(b"after"),
        step_inputs: hash_data(b"inputs"),
    };
    backend.fold_step(&mut acc, &witness).unwrap();
    let proof = backend.finalize(acc).unwrap();

    // Get the real blinding commitment
    let real_blinding = match &proof {
        VerifiedProof::HashIvc { blinding_commitment, .. } => blinding_commitment.unwrap(),
        _ => panic!("wrong proof type"),
    };

    // Tamper: replace with attacker-chosen blinding
    let tampered = match proof {
        VerifiedProof::HashIvc {
            chain_tip,
            merkle_root,
            step_count,
            code_hash,
            privacy_mode,
            checkpoints,
            input_hash,
            output_hash,
            ..
        } => VerifiedProof::HashIvc {
            chain_tip,
            merkle_root,
            step_count,
            code_hash,
            privacy_mode,
            blinding_commitment: Some([0x42; 32]), // FORGED
            checkpoints,
            input_hash,
            output_hash,
        },
        _ => panic!("wrong proof type"),
    };

    // Confirm tampered value is different
    match &tampered {
        VerifiedProof::HashIvc { blinding_commitment, .. } => {
            assert_ne!(blinding_commitment.unwrap(), real_blinding);
        }
        _ => panic!("wrong proof type"),
    }

    let result = backend.verify(&tampered, &ZERO_HASH, &ZERO_HASH).unwrap();

    assert!(
        !result,
        "FIXED: forged blinding commitment now correctly rejected"
    );
    eprintln!("REGRESSION 7 PASSED: Forged blinding commitment correctly detected");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 8: COMPLETE PROOF FABRICATION NOW REJECTED
//
// An attacker who never ran any computation cannot create a proof that
// passes verification — empty checkpoints don't match step_count.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Complete proof fabrication is now rejected.
#[test]
fn exploit_complete_fabrication_attack() {
    let backend = HashIvc;

    // Attacker knows the code_hash of the trusted inference engine
    let trusted_code = hash_data(b"poly_inference_engine_v1");

    // Attacker fabricates a proof claiming:
    // - 500 steps of inference were run
    // - Using the trusted code
    // - In private mode (so chain_tip is "hidden" behind blinding)
    let fabricated = VerifiedProof::HashIvc {
        chain_tip: [0x11; 32],     // random
        merkle_root: [0x22; 32],   // random
        step_count: 500,
        code_hash: trusted_code,   // impersonating the real engine
        privacy_mode: PrivacyMode::Private,
        blinding_commitment: Some([0x33; 32]), // random
        checkpoints: vec![],       // empty — won't match step_count
        input_hash: ZERO_HASH,
        output_hash: ZERO_HASH,
    };

    // Verifier checks the proof with expected I/O
    let expected_input = hash_data(b"user_query_tokens");
    let expected_output = hash_data(b"model_response_tokens");

    let accepted = backend.verify(&fabricated, &expected_input, &expected_output).unwrap();

    assert!(
        !accepted,
        "FIXED: complete fabrication now correctly rejected"
    );

    // In private mode, code_hash() still returns ZERO_HASH (by design)
    assert_eq!(fabricated.code_hash(), ZERO_HASH);

    eprintln!("REGRESSION 8 PASSED: Complete proof fabrication correctly rejected");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 9: PRIVACY DOWNGRADE NOW DETECTED
//
// Switching from transparent to private mode requires a valid blinding
// commitment that matches the checkpoints. A fake blinding is rejected.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: Privacy mode downgrade is now detected.
#[test]
fn exploit_privacy_mode_downgrade() {
    let backend = HashIvc;
    let malicious_code = hash_data(b"malicious_backdoor_code");

    // Create transparent proof (code_hash is visible)
    let mut acc = backend.init(&malicious_code, PrivacyMode::Transparent);
    let witness = StepWitness {
        state_before: hash_data(b"before"),
        state_after: hash_data(b"after"),
        step_inputs: hash_data(b"inputs"),
    };
    backend.fold_step(&mut acc, &witness).unwrap();
    let transparent_proof = backend.finalize(acc).unwrap();

    // Verify code_hash is visible in transparent mode
    assert_eq!(transparent_proof.code_hash(), malicious_code);

    // Attacker switches to private mode to hide the malicious code identity
    let disguised = match transparent_proof {
        VerifiedProof::HashIvc {
            chain_tip,
            merkle_root,
            step_count,
            code_hash,
            checkpoints,
            input_hash,
            output_hash,
            ..
        } => VerifiedProof::HashIvc {
            chain_tip,
            merkle_root,
            step_count,
            code_hash,
            privacy_mode: PrivacyMode::Private, // SWITCHED
            blinding_commitment: Some([0xAA; 32]), // fake blinding
            checkpoints,
            input_hash,
            output_hash,
        },
        _ => panic!("wrong proof type"),
    };

    // Now code_hash returns ZERO_HASH, hiding the malicious identity
    assert_eq!(disguised.code_hash(), ZERO_HASH);

    // NOW REJECTED: fake blinding doesn't match computed blinding from checkpoints
    let result = backend.verify(&disguised, &ZERO_HASH, &ZERO_HASH).unwrap();
    assert!(
        !result,
        "FIXED: privacy downgrade now correctly rejected"
    );
    eprintln!("REGRESSION 9 PASSED: Privacy mode downgrade correctly detected");
}

// ═══════════════════════════════════════════════════════════════════════
// REGRESSION 10: I/O HASHES NOW AFFECT VERIFICATION
//
// In transparent mode, different I/O hash combinations now produce
// different verification results. Only the correct I/O passes.
// ═══════════════════════════════════════════════════════════════════════

/// FIXED: I/O hashes now properly affect verification results.
#[test]
fn exploit_io_hashes_have_zero_effect() {
    let backend = HashIvc;
    let code_hash = hash_data(b"io_test");

    // Create a real proof with specific I/O binding
    let mut acc = backend.init(&code_hash, PrivacyMode::Transparent);
    let witness = StepWitness {
        state_before: hash_data(b"before"),
        state_after: hash_data(b"after"),
        step_inputs: hash_data(b"inputs"),
    };
    backend.fold_step(&mut acc, &witness).unwrap();
    let bound_input = hash_data(&[0]);
    let bound_output = hash_data(&[1]);
    acc.input_hash = bound_input;
    acc.output_hash = bound_output;
    let proof = backend.finalize(acc).unwrap();

    // Correct I/O → passes
    assert!(backend.verify(&proof, &bound_input, &bound_output).unwrap());

    // Wrong I/O → fails (try 16 different wrong combinations)
    let test_hashes: Vec<Hash> = (2..6u8).map(|i| hash_data(&[i])).collect();
    for input in &test_hashes {
        for output in &test_hashes {
            let result = backend.verify(&proof, input, output).unwrap();
            assert!(
                !result,
                "FIXED: wrong I/O should fail verification"
            );
        }
    }

    eprintln!("REGRESSION 10 PASSED: I/O hashes now properly affect verification");
}
