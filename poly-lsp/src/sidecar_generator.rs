//! Sidecar Generator - Generates TypeScript definition files from TypeGraph
//!
//! This module creates `.d.ts` files that allow tsserver to understand
//! Rust and Python types, enabling cross-language type checking in JS/TS blocks.

use crate::shadow_indexer::{ShadowIndex, ShadowSignature, Visibility};
use crate::type_graph::TypeGraph;
use std::collections::{HashMap, HashSet};
use std::path::PathBuf;
use tower_lsp::lsp_types::Url;

/// Generator for TypeScript sidecar definition files
pub struct SidecarGenerator {
    /// Directory where generated files are written
    output_dir: PathBuf,
    /// Hash of last generated content per URI (to avoid unnecessary writes)
    last_generated: HashMap<String, String>,
    /// Type mappings from #[types] blocks
    custom_types: HashMap<String, String>,
}

impl SidecarGenerator {
    pub fn new(workspace_root: PathBuf) -> Self {
        let output_dir = workspace_root.join(".poly-lsp");
        // Ensure output directory exists
        let _ = std::fs::create_dir_all(&output_dir);

        Self {
            output_dir,
            last_generated: HashMap::new(),
            custom_types: HashMap::new(),
        }
    }

    /// Generate polyglot_types.d.ts from TypeGraph and ShadowIndex
    pub fn generate_dts(
        &mut self,
        type_graph: &TypeGraph,
        shadow_index: &ShadowIndex,
        uri: &Url,
    ) -> Option<PathBuf> {
        let mut content = String::new();

        // Header
        content.push_str("// polyglot_types.d.ts - Auto-generated by poly-lsp\n");
        content.push_str("// DO NOT EDIT - This file is regenerated on every change\n\n");

        // Collect type declarations from TypeGraph
        self.extract_type_declarations(type_graph, &mut content);

        // Generate namespace with all interface functions
        content.push_str("declare namespace polyglot {\n");

        // Add interface functions
        for sig in shadow_index.signatures_by_lang("interface") {
            self.emit_function_declaration(&sig, &mut content, "    ");
        }

        // Add Rust implementations as exports
        for sig in shadow_index.signatures_by_lang("rust") {
            if sig.visibility == Visibility::Public {
                self.emit_function_declaration(&sig, &mut content, "    ");
            }
        }

        // Add Python implementations as exports
        for sig in shadow_index.signatures_by_lang("python") {
            if sig.visibility == Visibility::Public {
                self.emit_function_declaration(&sig, &mut content, "    ");
            }
        }

        content.push_str("}\n\n");

        // Generate global declarations for direct function access
        content.push_str("// Global function declarations for direct access\n");
        content.push_str("declare global {\n");
        content.push_str("    interface Window {\n");
        content.push_str("        polyglot: typeof polyglot;\n");
        content.push_str("    }\n");

        // Emit global function declarations for interface functions
        for sig in shadow_index.signatures_by_lang("interface") {
            self.emit_global_function(&sig, &mut content, "    ");
        }

        content.push_str("}\n\n");

        // Export for module systems
        content.push_str("export = polyglot;\n");
        content.push_str("export as namespace polyglot;\n");

        // Check if content changed
        let uri_key = uri.to_string();
        if let Some(last) = self.last_generated.get(&uri_key) {
            if last == &content {
                // No change, skip write
                return Some(self.output_dir.join("polyglot_types.d.ts"));
            }
        }

        // Write to file
        let output_path = self.output_dir.join("polyglot_types.d.ts");
        if let Err(e) = std::fs::write(&output_path, &content) {
            eprintln!("Failed to write polyglot_types.d.ts: {}", e);
            return None;
        }

        // Cache the content
        self.last_generated.insert(uri_key, content);

        Some(output_path)
    }

    /// Extract type declarations from TypeGraph's type_declarations field
    fn extract_type_declarations(&mut self, type_graph: &TypeGraph, content: &mut String) {
        // Get type declarations from TypeGraph
        let type_decls = type_graph.get_type_declarations();

        if type_decls.is_empty() {
            return;
        }

        content.push_str("// Type declarations from #[types] block\n");

        for (name, (_rust_impl, _python_impl)) in type_decls {
            // Generate TypeScript interface for custom types
            content.push_str(&format!("interface {} {{\n", name));
            content.push_str("    // Auto-generated placeholder - extend as needed\n");
            content.push_str("    [key: string]: any;\n");
            content.push_str("}\n\n");

            self.custom_types.insert(name.clone(), name.clone());
        }
    }

    /// Emit a function declaration in TypeScript
    fn emit_function_declaration(&self, sig: &ShadowSignature, content: &mut String, indent: &str) {
        let ts_params = self.params_to_typescript(&sig.params, &sig.name);
        let ts_return = self.type_to_typescript(sig.return_type.as_deref().unwrap_or("void"));

        let async_prefix = if sig.is_async { "async " } else { "" };

        content.push_str(&format!(
            "{}{}function {}({}): {};\n",
            indent, async_prefix, sig.name, ts_params, ts_return
        ));
    }

    /// Emit a global function declaration
    fn emit_global_function(&self, sig: &ShadowSignature, content: &mut String, indent: &str) {
        let ts_params = self.params_to_typescript(&sig.params, &sig.name);
        let ts_return = self.type_to_typescript(sig.return_type.as_deref().unwrap_or("void"));

        content.push_str(&format!(
            "{}function {}({}): {};\n",
            indent, sig.name, ts_params, ts_return
        ));
    }

    /// Convert parameter list to TypeScript
    fn params_to_typescript(&self, params: &[String], fn_name: &str) -> String {
        if params.is_empty() {
            return String::new();
        }

        params
            .iter()
            .enumerate()
            .map(|(i, param_type)| {
                let ts_type = self.type_to_typescript(param_type);
                format!("arg{}: {}", i, ts_type)
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Convert a Polyglot/Rust/Python type to TypeScript
    fn type_to_typescript(&self, ty: &str) -> String {
        let ty = ty.trim();

        // Check custom types first
        if self.custom_types.contains_key(ty) {
            return ty.to_string();
        }

        match ty {
            // Numeric types
            "u8" | "u16" | "u32" | "i8" | "i16" | "i32" | "f32" | "f64" | "usize" | "isize" => {
                "number".to_string()
            }
            "u64" | "i64" | "u128" | "i128" => "bigint".to_string(),
            "int" | "float" => "number".to_string(), // Python types

            // Boolean
            "bool" => "boolean".to_string(),

            // String types
            "String" | "&str" | "str" => "string".to_string(),

            // Unit/void
            "()" | "None" | "void" => "void".to_string(),

            // Byte arrays
            "Vec<u8>" | "bytes" | "&[u8]" => "Uint8Array".to_string(),

            // Unknown/any
            "?" | "any" | "object" | "Object" => "any".to_string(),

            _ => {
                // Handle generic types
                if ty.starts_with("Vec<") || ty.starts_with("list[") {
                    let inner = self.extract_inner_type(ty);
                    let ts_inner = self.type_to_typescript(&inner);
                    return format!("{}[]", ts_inner);
                }

                if ty.starts_with("Option<") {
                    let inner = self.extract_inner_type(ty);
                    let ts_inner = self.type_to_typescript(&inner);
                    return format!("{} | null", ts_inner);
                }

                if ty.starts_with("Result<") {
                    // For Result<T, E>, we just return T (errors become exceptions in JS)
                    let inner = self.extract_inner_type(ty);
                    // Handle Result<T, E> by extracting just T
                    let t_type = inner.split(',').next().unwrap_or(&inner).trim();
                    return self.type_to_typescript(t_type);
                }

                if ty.starts_with("HashMap<") || ty.starts_with("dict[") {
                    return "Record<string, any>".to_string();
                }

                if ty.starts_with("HashSet<") || ty.starts_with("set[") {
                    let inner = self.extract_inner_type(ty);
                    let ts_inner = self.type_to_typescript(&inner);
                    return format!("Set<{}>", ts_inner);
                }

                if ty.starts_with("Tensor") {
                    return "Tensor".to_string();
                }

                // For complex types we don't recognize, use any
                // But preserve the type name if it looks like a custom type
                if ty.chars().next().map(|c| c.is_uppercase()).unwrap_or(false) {
                    ty.to_string()
                } else {
                    "any".to_string()
                }
            }
        }
    }

    /// Extract the inner type from generic types like Vec<T>, Option<T>, etc.
    fn extract_inner_type(&self, ty: &str) -> String {
        // Find opening bracket/angle
        let start = ty
            .find('<')
            .or_else(|| ty.find('['))
            .map(|i| i + 1)
            .unwrap_or(0);

        // Find closing bracket/angle
        let end = ty
            .rfind('>')
            .or_else(|| ty.rfind(']'))
            .unwrap_or(ty.len());

        ty[start..end].to_string()
    }

    /// Generate a tsconfig.json that includes the generated types
    pub fn generate_tsconfig(&self, workspace_root: &PathBuf) -> Option<PathBuf> {
        let tsconfig_path = workspace_root.join("tsconfig.polyglot.json");

        let config = serde_json::json!({
            "compilerOptions": {
                "target": "ES2020",
                "module": "ESNext",
                "moduleResolution": "node",
                "strict": true,
                "esModuleInterop": true,
                "skipLibCheck": true,
                "forceConsistentCasingInFileNames": true,
                "declaration": true,
                "types": [],
                "typeRoots": [".poly-lsp"]
            },
            "include": ["**/*.ts", "**/*.tsx", "**/*.poly"],
            "exclude": ["node_modules", "dist"]
        });

        let content = serde_json::to_string_pretty(&config).ok()?;

        std::fs::write(&tsconfig_path, content).ok()?;

        Some(tsconfig_path)
    }

    /// Get the output directory path
    pub fn output_dir(&self) -> &PathBuf {
        &self.output_dir
    }

    /// Check if the sidecar file exists and is recent
    pub fn is_fresh(&self, uri: &Url) -> bool {
        self.last_generated.contains_key(&uri.to_string())
    }

    /// Clear cached content for a URI
    pub fn invalidate(&mut self, uri: &Url) {
        self.last_generated.remove(&uri.to_string());
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::env::temp_dir;

    #[test]
    fn test_type_conversion() {
        let gen = SidecarGenerator::new(temp_dir());

        assert_eq!(gen.type_to_typescript("i32"), "number");
        assert_eq!(gen.type_to_typescript("u64"), "bigint");
        assert_eq!(gen.type_to_typescript("bool"), "boolean");
        assert_eq!(gen.type_to_typescript("String"), "string");
        assert_eq!(gen.type_to_typescript("Vec<u8>"), "Uint8Array");
        assert_eq!(gen.type_to_typescript("Vec<i32>"), "number[]");
        assert_eq!(gen.type_to_typescript("Option<String>"), "string | null");
        assert_eq!(gen.type_to_typescript("Result<i32, Error>"), "number");
    }

    #[test]
    fn test_inner_type_extraction() {
        let gen = SidecarGenerator::new(temp_dir());

        assert_eq!(gen.extract_inner_type("Vec<i32>"), "i32");
        assert_eq!(gen.extract_inner_type("Option<String>"), "String");
        assert_eq!(gen.extract_inner_type("list[int]"), "int");
        assert_eq!(gen.extract_inner_type("Result<i32, Error>"), "i32, Error");
    }
}
