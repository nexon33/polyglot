// calculator.poly - Working multi-block example
//
// Demonstrates interfaces + Rust implementation that actually compiles and runs.
// This is what works TODAY. Cross-language calls coming in Phase 26.
//
// Run: polyglot run calculator.poly

// ═══════════════════════════════════════════════════════════════════════════════
// INTERFACE - Define the contract
// ═══════════════════════════════════════════════════════════════════════════════

#[interface] {
    /// Calculator operations interface
    trait Calculator {
        fn add(a: i32, b: i32) -> i32;
        fn multiply(a: i32, b: i32) -> i32;
        fn factorial(n: i32) -> i32;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// RUST IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════════

#[rust] {
    /// Rust implementation of Calculator
    pub struct RustCalculator;

    impl RustCalculator {
        pub fn add(a: i32, b: i32) -> i32 {
            a + b
        }

        pub fn multiply(a: i32, b: i32) -> i32 {
            a * b
        }

        pub fn factorial(n: i32) -> i32 {
            if n <= 1 { 1 } else { n * Self::factorial(n - 1) }
        }
    }

    // Helper functions using iterators
    fn sum_range(start: i32, end: i32) -> i32 {
        (start..=end).sum()
    }

    fn fibonacci(n: usize) -> Vec<i32> {
        let mut fib = vec![0, 1];
        for i in 2..n {
            fib.push(fib[i - 1] + fib[i - 2]);
        }
        fib.truncate(n);
        fib
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN - Entry point
// ═══════════════════════════════════════════════════════════════════════════════

#[main]
fn main() {
    println!("=== Polyglot Calculator Demo ===\n");

    // Basic operations
    let a = 42;
    let b = 13;

    println!("Addition: {} + {} = {}", a, b, RustCalculator::add(a, b));
    println!("Multiply: {} * {} = {}", a, b, RustCalculator::multiply(a, b));
    println!("Factorial: {}! = {}", 7, RustCalculator::factorial(7));

    // Range operations
    println!("\nSum of 1..100 = {}", sum_range(1, 100));

    // Fibonacci
    let fib = fibonacci(10);
    println!("First 10 Fibonacci: {:?}", fib);

    // Functional style
    let numbers: Vec<i32> = (1..=10).collect();
    let squares: Vec<i32> = numbers.iter().map(|x| x * x).collect();
    let evens: Vec<i32> = numbers.iter().filter(|x| *x % 2 == 0).cloned().collect();

    println!("\nNumbers 1-10: {:?}", numbers);
    println!("Squares: {:?}", squares);
    println!("Evens: {:?}", evens);

    println!("\n=== Demo Complete ===");
}
